<!DOCTYPE html>
<html>
<head>
  <title>src.e31bb0bc.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../doc-style.css" />
  <script src="../doc-filelist.js"></script>
  <script>
    var relativeDir = "../";
    var thisFile = "dist\\src.e31bb0bc.js";
    var defaultSidebar = true;
  </script>
  <script src="../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#sourcemappingurlsrc.e31bb0bc.js.map">sourceMappingURL=/src.e31bb0bc.js.map</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>src.e31bb0bc.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<p>modules are defined as an array
[ module function, map of requires ]</p>
<p>map of requires is short require name -&gt; numeric require</p>
<p>anything defined in a previous bundle is accessed via the
orig method which is the require for previous bundles</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">parcelRequire = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">modules, cache, entry, globalName</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Save the require from previous bundle to this closure if any</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> previousRequire = <span class="hljs-keyword">typeof</span> parcelRequire === <span class="hljs-string">'function'</span> &amp;&amp; parcelRequire;
  <span class="hljs-keyword">var</span> nodeRequire = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-built_in">require</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newRequire</span>(<span class="hljs-params">name, jumped</span>) </span>{
    <span class="hljs-keyword">if</span> (!cache[name]) {
      <span class="hljs-keyword">if</span> (!modules[name]) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>if we cannot find the module within our internal map or
cache jump to the current global require ie. the last bundle
that was added to the page.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> currentRequire = <span class="hljs-keyword">typeof</span> parcelRequire === <span class="hljs-string">'function'</span> &amp;&amp; parcelRequire;
        <span class="hljs-keyword">if</span> (!jumped &amp;&amp; currentRequire) {
          <span class="hljs-keyword">return</span> currentRequire(name, <span class="hljs-literal">true</span>);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>If there are other bundles on this page the require from the
previous one is saved to 'previousRequire'. Repeat this as
many times as there are bundles until the module is found or
we exhaust the require chain.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (previousRequire) {
          <span class="hljs-keyword">return</span> previousRequire(name, <span class="hljs-literal">true</span>);
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Try the node require function if it exists.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (nodeRequire &amp;&amp; <span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span>) {
          <span class="hljs-keyword">return</span> nodeRequire(name);
        }

        <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Cannot find module \''</span> + name + <span class="hljs-string">'\''</span>);
        err.code = <span class="hljs-string">'MODULE_NOT_FOUND'</span>;
        <span class="hljs-keyword">throw</span> err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = cache[name] = <span class="hljs-keyword">new</span> newRequire.Module(name);

      modules[name][<span class="hljs-number">0</span>].call(<span class="hljs-built_in">module</span>.exports, localRequire, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, <span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">return</span> cache[name].exports;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">localRequire</span>(<span class="hljs-params">x</span>)</span>{
      <span class="hljs-keyword">return</span> newRequire(localRequire.resolve(x));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">x</span>)</span>{
      <span class="hljs-keyword">return</span> modules[name][<span class="hljs-number">1</span>][x] || x;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Module</span>(<span class="hljs-params">moduleName</span>) </span>{
    <span class="hljs-keyword">this</span>.id = moduleName;
    <span class="hljs-keyword">this</span>.bundle = newRequire;
    <span class="hljs-keyword">this</span>.exports = {};
  }

  newRequire.isParcelRequire = <span class="hljs-literal">true</span>;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, exports</span>) </span>{
    modules[id] = [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">require, module</span>) </span>{
      <span class="hljs-built_in">module</span>.exports = exports;
    }, {}];
  };

  <span class="hljs-keyword">var</span> error;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; entry.length; i++) {
    <span class="hljs-keyword">try</span> {
      newRequire(entry[i]);
    } <span class="hljs-keyword">catch</span> (e) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Save first error but execute all entries</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (!error) {
        error = e;
      }
    }
  }

  <span class="hljs-keyword">if</span> (entry.length) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Expose entry point to Node, AMD or browser globals
Based on https://github.com/ForbesLindesay/umd/blob/master/template.js</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> mainExports = newRequire(entry[entry.length - <span class="hljs-number">1</span>]);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>CommonJS</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">"undefined"</span>) {
      <span class="hljs-built_in">module</span>.exports = mainExports;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>RequireJS</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">"function"</span> &amp;&amp; define.amd) {
     define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
       <span class="hljs-keyword">return</span> mainExports;
     });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<script>

        </td>
        <td class="code highlight">
          <pre class="javascript">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (globalName) {
      <span class="hljs-keyword">this</span>[globalName] = mainExports;
    }
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Override the current require with this new one</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  parcelRequire = newRequire;

  <span class="hljs-keyword">if</span> (error) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>throw error from earlier, <em>after updating parcelRequire</em></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">throw</span> error;
  }

  <span class="hljs-keyword">return</span> newRequire;
})({<span class="hljs-string">"../node_modules/object-assign/index.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<div class="dox">
<div class="summary">
<p>object-assign
(c) Sindre Sorhus</p>
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;
<span class="hljs-comment">/* eslint-disable no-unused-vars */</span>

<span class="hljs-keyword">var</span> getOwnPropertySymbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols;
<span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
<span class="hljs-keyword">var</span> propIsEnumerable = <span class="hljs-built_in">Object</span>.prototype.propertyIsEnumerable;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toObject</span>(<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">if</span> (val === <span class="hljs-literal">null</span> || val === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Object.assign cannot be called with null or undefined'</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>(val);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldUseNative</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.assign) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// Detect buggy property enumeration order in older V8 versions.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>https://bugs.chromium.org/p/v8/issues/detail?id=4118</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> test1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'abc'</span>); <span class="hljs-comment">// eslint-disable-line no-new-wrappers</span>

    test1[<span class="hljs-number">5</span>] = <span class="hljs-string">'de'</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyNames(test1)[<span class="hljs-number">0</span>] === <span class="hljs-string">'5'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// https://bugs.chromium.org/p/v8/issues/detail?id=3056</span>


    <span class="hljs-keyword">var</span> test2 = {};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
      test2[<span class="hljs-string">'_'</span> + <span class="hljs-built_in">String</span>.fromCharCode(i)] = i;
    }

    <span class="hljs-keyword">var</span> order2 = <span class="hljs-built_in">Object</span>.getOwnPropertyNames(test2).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
      <span class="hljs-keyword">return</span> test2[n];
    });

    <span class="hljs-keyword">if</span> (order2.join(<span class="hljs-string">''</span>) !== <span class="hljs-string">'0123456789'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// https://bugs.chromium.org/p/v8/issues/detail?id=3056</span>


    <span class="hljs-keyword">var</span> test3 = {};
    <span class="hljs-string">'abcdefghijklmnopqrst'</span>.split(<span class="hljs-string">''</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">letter</span>) </span>{
      test3[letter] = letter;
    });

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Object</span>.assign({}, test3)).join(<span class="hljs-string">''</span>) !== <span class="hljs-string">'abcdefghijklmnopqrst'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">catch</span> (err) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>We don't expect any of the above to throw, but better to be safe.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}

<span class="hljs-built_in">module</span>.exports = shouldUseNative() ? <span class="hljs-built_in">Object</span>.assign : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, source</span>) </span>{
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span>;
  <span class="hljs-keyword">var</span> to = toObject(target);
  <span class="hljs-keyword">var</span> symbols;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> s = <span class="hljs-number">1</span>; s &lt; <span class="hljs-built_in">arguments</span>.length; s++) {
    <span class="hljs-keyword">from</span> = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">arguments</span>[s]);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) {
      <span class="hljs-keyword">if</span> (hasOwnProperty.call(<span class="hljs-keyword">from</span>, key)) {
        to[key] = <span class="hljs-keyword">from</span>[key];
      }
    }

    <span class="hljs-keyword">if</span> (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(<span class="hljs-keyword">from</span>);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; symbols.length; i++) {
        <span class="hljs-keyword">if</span> (propIsEnumerable.call(<span class="hljs-keyword">from</span>, symbols[i])) {
          to[symbols[i]] = <span class="hljs-keyword">from</span>[symbols[i]];
        }
      }
    }
  }

  <span class="hljs-keyword">return</span> to;
};
},{}],<span class="hljs-string">"../node_modules/prop-types/lib/ReactPropTypesSecret.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) 2013-present, Facebook, Inc.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">
'use strict'</span>;

<span class="hljs-keyword">var</span> ReactPropTypesSecret = <span class="hljs-string">'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'</span>;

<span class="hljs-built_in">module</span>.exports = ReactPropTypesSecret;

},{}],<span class="hljs-string">"../node_modules/prop-types/checkPropTypes.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) 2013-present, Facebook, Inc.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">var</span> printWarning = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">'production'</span>) {
  <span class="hljs-keyword">var</span> ReactPropTypesSecret = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/ReactPropTypesSecret'</span>);

  <span class="hljs-keyword">var</span> loggedTypeFailures = {};
  <span class="hljs-keyword">var</span> has = <span class="hljs-built_in">Function</span>.call.bind(<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty);

  printWarning = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>{
    <span class="hljs-keyword">var</span> message = <span class="hljs-string">'Warning: '</span> + text;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">'undefined'</span>) {
      <span class="hljs-built_in">console</span>.error(message);
    }

    <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>--- Welcome to debugging React ---
This error was thrown as a convenience so that you can use this stack
to find the callsite that caused this warning to fire.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
    } <span class="hljs-keyword">catch</span> (x) {}
  };
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<div class="dox">
<div class="summary">
<p>Assert that the values match with the type specs.
Error messages are memorized and will only be shown once.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">typeSpecs</span>
<span class="dox_type">object</span>
<span>Map of name to a ReactPropType
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">values</span>
<span class="dox_type">object</span>
<span>Runtime values that need to be type-checked
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">location</span>
<span class="dox_type">string</span>
<span>e.g. &quot;prop&quot;, &quot;context&quot;, &quot;child context&quot;
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">componentName</span>
<span class="dox_type">string</span>
<span>Name of the component for error messages.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">getStack</span>
<span class="dox_type">Function</span>
<span>Returns the component stack.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkPropTypes</span>(<span class="hljs-params">typeSpecs, values, location, componentName, getStack</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">'production'</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> typeSpecName <span class="hljs-keyword">in</span> typeSpecs) {
      <span class="hljs-keyword">if</span> (has(typeSpecs, typeSpecName)) {
        <span class="hljs-keyword">var</span> error; <span class="hljs-comment">// Prop type validation may throw. In case they do, we don't want to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>fail the render phase where it didn't fail before. So we log it.
After these have been cleaned up, we'll let them throw.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>This is intentionally an invariant that gets caught. It's the same
behavior as without this statement except with a better message.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> typeSpecs[typeSpecName] !== <span class="hljs-string">'function'</span>) {
            <span class="hljs-keyword">var</span> err = <span class="hljs-built_in">Error</span>((componentName || <span class="hljs-string">'React class'</span>) + <span class="hljs-string">': '</span> + location + <span class="hljs-string">' type `'</span> + typeSpecName + <span class="hljs-string">'` is invalid; '</span> + <span class="hljs-string">'it must be a function, usually from the `prop-types` package, but received `'</span> + <span class="hljs-keyword">typeof</span> typeSpecs[typeSpecName] + <span class="hljs-string">'`.'</span>);
            err.name = <span class="hljs-string">'Invariant Violation'</span>;
            <span class="hljs-keyword">throw</span> err;
          }

          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, <span class="hljs-literal">null</span>, ReactPropTypesSecret);
        } <span class="hljs-keyword">catch</span> (ex) {
          error = ex;
        }

        <span class="hljs-keyword">if</span> (error &amp;&amp; !(error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>)) {
          printWarning((componentName || <span class="hljs-string">'React class'</span>) + <span class="hljs-string">': type specification of '</span> + location + <span class="hljs-string">' `'</span> + typeSpecName + <span class="hljs-string">'` is invalid; the type checker '</span> + <span class="hljs-string">'function must return `null` or an `Error` but returned a '</span> + <span class="hljs-keyword">typeof</span> error + <span class="hljs-string">'. '</span> + <span class="hljs-string">'You may have forgotten to pass an argument to the type checker '</span> + <span class="hljs-string">'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '</span> + <span class="hljs-string">'shape all require an argument).'</span>);
        }

        <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> &amp;&amp; !(error.message <span class="hljs-keyword">in</span> loggedTypeFailures)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>Only monitor this failure once because there tends to be a lot of the
same error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          loggedTypeFailures[error.message] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">var</span> stack = getStack ? getStack() : <span class="hljs-string">''</span>;
          printWarning(<span class="hljs-string">'Failed '</span> + location + <span class="hljs-string">' type: '</span> + error.message + (stack != <span class="hljs-literal">null</span> ? stack : <span class="hljs-string">''</span>));
        }
      }
    }
  }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<div class="dox">
<div class="summary">
<p>Resets warning cache when testing.</p>
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

checkPropTypes.resetWarningCache = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">'production'</span>) {
    loggedTypeFailures = {};
  }
};

<span class="hljs-built_in">module</span>.exports = checkPropTypes;
},{<span class="hljs-string">"./lib/ReactPropTypesSecret"</span>:<span class="hljs-string">"../node_modules/prop-types/lib/ReactPropTypesSecret.js"</span>}],<span class="hljs-string">"../node_modules/react/cjs/react.development.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">"production"</span>) {
  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>;

    <span class="hljs-keyword">var</span> _assign = <span class="hljs-built_in">require</span>(<span class="hljs-string">'object-assign'</span>);

    <span class="hljs-keyword">var</span> checkPropTypes = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prop-types/checkPropTypes'</span>);

    <span class="hljs-keyword">var</span> ReactVersion = <span class="hljs-string">'16.13.1'</span>; <span class="hljs-comment">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>nor polyfill, then a plain number is used for performance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> hasSymbol = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.for;
    <span class="hljs-keyword">var</span> REACT_ELEMENT_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.element'</span>) : <span class="hljs-number">0xeac7</span>;
    <span class="hljs-keyword">var</span> REACT_PORTAL_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.portal'</span>) : <span class="hljs-number">0xeaca</span>;
    <span class="hljs-keyword">var</span> REACT_FRAGMENT_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.fragment'</span>) : <span class="hljs-number">0xeacb</span>;
    <span class="hljs-keyword">var</span> REACT_STRICT_MODE_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.strict_mode'</span>) : <span class="hljs-number">0xeacc</span>;
    <span class="hljs-keyword">var</span> REACT_PROFILER_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.profiler'</span>) : <span class="hljs-number">0xead2</span>;
    <span class="hljs-keyword">var</span> REACT_PROVIDER_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.provider'</span>) : <span class="hljs-number">0xeacd</span>;
    <span class="hljs-keyword">var</span> REACT_CONTEXT_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.context'</span>) : <span class="hljs-number">0xeace</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> We don't use AsyncMode or ConcurrentMode anymore. They were temporary</span>

    <span class="hljs-keyword">var</span> REACT_CONCURRENT_MODE_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.concurrent_mode'</span>) : <span class="hljs-number">0xeacf</span>;
    <span class="hljs-keyword">var</span> REACT_FORWARD_REF_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.forward_ref'</span>) : <span class="hljs-number">0xead0</span>;
    <span class="hljs-keyword">var</span> REACT_SUSPENSE_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.suspense'</span>) : <span class="hljs-number">0xead1</span>;
    <span class="hljs-keyword">var</span> REACT_SUSPENSE_LIST_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.suspense_list'</span>) : <span class="hljs-number">0xead8</span>;
    <span class="hljs-keyword">var</span> REACT_MEMO_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.memo'</span>) : <span class="hljs-number">0xead3</span>;
    <span class="hljs-keyword">var</span> REACT_LAZY_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.lazy'</span>) : <span class="hljs-number">0xead4</span>;
    <span class="hljs-keyword">var</span> REACT_BLOCK_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.block'</span>) : <span class="hljs-number">0xead9</span>;
    <span class="hljs-keyword">var</span> REACT_FUNDAMENTAL_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.fundamental'</span>) : <span class="hljs-number">0xead5</span>;
    <span class="hljs-keyword">var</span> REACT_RESPONDER_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.responder'</span>) : <span class="hljs-number">0xead6</span>;
    <span class="hljs-keyword">var</span> REACT_SCOPE_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.scope'</span>) : <span class="hljs-number">0xead7</span>;
    <span class="hljs-keyword">var</span> MAYBE_ITERATOR_SYMBOL = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.iterator;
    <span class="hljs-keyword">var</span> FAUX_ITERATOR_SYMBOL = <span class="hljs-string">'@@iterator'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIteratorFn</span>(<span class="hljs-params">maybeIterable</span>) </span>{
      <span class="hljs-keyword">if</span> (maybeIterable === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> maybeIterable !== <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> maybeIterator === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> maybeIterator;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<div class="dox">
<div class="summary">
<p>Keeps track of the current dispatcher.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> ReactCurrentDispatcher = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Type</div>
<div class="dox_tag_detail">
<span class="dox_type">ReactComponent</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      current: <span class="hljs-literal">null</span>
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<div class="dox">
<div class="summary">
<p>Keeps track of the current batch's configuration such as how long an update
should suspend for if it needs to.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> ReactCurrentBatchConfig = {
      <span class="hljs-attr">suspense</span>: <span class="hljs-literal">null</span>
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<div class="dox">
<div class="summary">
<p>Keeps track of the current owner.</p>
</div>
<div class="body">
<p>The current owner is the component who should own any components that are
currently being constructed.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> ReactCurrentOwner = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Type</div>
<div class="dox_tag_detail">
<span class="dox_type">ReactComponent</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      current: <span class="hljs-literal">null</span>
    };
    <span class="hljs-keyword">var</span> BEFORE_SLASH_RE = <span class="hljs-regexp">/^(.*)[\\\/]/</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">describeComponentFrame</span>(<span class="hljs-params">name, source, ownerName</span>) </span>{
      <span class="hljs-keyword">var</span> sourceInfo = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">if</span> (source) {
        <span class="hljs-keyword">var</span> path = source.fileName;
        <span class="hljs-keyword">var</span> fileName = path.replace(BEFORE_SLASH_RE, <span class="hljs-string">''</span>);
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>In DEV, include code for a common special case:
prefer &quot;folder/index.js&quot; instead of just &quot;index.js&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^index\./</span>.test(fileName)) {
            <span class="hljs-keyword">var</span> match = path.match(BEFORE_SLASH_RE);

            <span class="hljs-keyword">if</span> (match) {
              <span class="hljs-keyword">var</span> pathBeforeSlash = match[<span class="hljs-number">1</span>];

              <span class="hljs-keyword">if</span> (pathBeforeSlash) {
                <span class="hljs-keyword">var</span> folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, <span class="hljs-string">''</span>);
                fileName = folderName + <span class="hljs-string">'/'</span> + fileName;
              }
            }
          }
        }
        sourceInfo = <span class="hljs-string">' (at '</span> + fileName + <span class="hljs-string">':'</span> + source.lineNumber + <span class="hljs-string">')'</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ownerName) {
        sourceInfo = <span class="hljs-string">' (created by '</span> + ownerName + <span class="hljs-string">')'</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">'\n    in '</span> + (name || <span class="hljs-string">'Unknown'</span>) + sourceInfo;
    }

    <span class="hljs-keyword">var</span> Resolved = <span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refineResolvedLazyComponent</span>(<span class="hljs-params">lazyComponent</span>) </span>{
      <span class="hljs-keyword">return</span> lazyComponent._status === Resolved ? lazyComponent._result : <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWrappedName</span>(<span class="hljs-params">outerType, innerType, wrapperName</span>) </span>{
      <span class="hljs-keyword">var</span> functionName = innerType.displayName || innerType.name || <span class="hljs-string">''</span>;
      <span class="hljs-keyword">return</span> outerType.displayName || (functionName !== <span class="hljs-string">''</span> ? wrapperName + <span class="hljs-string">"("</span> + functionName + <span class="hljs-string">")"</span> : wrapperName);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getComponentName</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>Host root, text node or just invalid type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type.tag === <span class="hljs-string">'number'</span>) {
          error(<span class="hljs-string">'Received an unexpected object in getComponentName(). '</span> + <span class="hljs-string">'This is likely a bug in React. Please file an issue.'</span>);
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> type.displayName || type.name || <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'string'</span>) {
        <span class="hljs-keyword">return</span> type;
      }

      <span class="hljs-keyword">switch</span> (type) {
        <span class="hljs-keyword">case</span> REACT_FRAGMENT_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'Fragment'</span>;

        <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'Portal'</span>;

        <span class="hljs-keyword">case</span> REACT_PROFILER_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">"Profiler"</span>;

        <span class="hljs-keyword">case</span> REACT_STRICT_MODE_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'StrictMode'</span>;

        <span class="hljs-keyword">case</span> REACT_SUSPENSE_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'Suspense'</span>;

        <span class="hljs-keyword">case</span> REACT_SUSPENSE_LIST_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'SuspenseList'</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">switch</span> (type.$$<span class="hljs-keyword">typeof</span>) {
          <span class="hljs-keyword">case</span> REACT_CONTEXT_TYPE:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'Context.Consumer'</span>;

          <span class="hljs-keyword">case</span> REACT_PROVIDER_TYPE:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'Context.Provider'</span>;

          <span class="hljs-keyword">case</span> REACT_FORWARD_REF_TYPE:
            <span class="hljs-keyword">return</span> getWrappedName(type, type.render, <span class="hljs-string">'ForwardRef'</span>);

          <span class="hljs-keyword">case</span> REACT_MEMO_TYPE:
            <span class="hljs-keyword">return</span> getComponentName(type.type);

          <span class="hljs-keyword">case</span> REACT_BLOCK_TYPE:
            <span class="hljs-keyword">return</span> getComponentName(type.render);

          <span class="hljs-keyword">case</span> REACT_LAZY_TYPE:
            {
              <span class="hljs-keyword">var</span> thenable = type;
              <span class="hljs-keyword">var</span> resolvedThenable = refineResolvedLazyComponent(thenable);

              <span class="hljs-keyword">if</span> (resolvedThenable) {
                <span class="hljs-keyword">return</span> getComponentName(resolvedThenable);
              }

              <span class="hljs-keyword">break</span>;
            }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> ReactDebugCurrentFrame = {};
    <span class="hljs-keyword">var</span> currentlyValidatingElement = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCurrentlyValidatingElement</span>(<span class="hljs-params">element</span>) </span>{
      {
        currentlyValidatingElement = element;
      }
    }

    {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>Stack implementation injected by the current renderer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      ReactDebugCurrentFrame.getCurrentStack = <span class="hljs-literal">null</span>;

      ReactDebugCurrentFrame.getStackAddendum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> stack = <span class="hljs-string">''</span>; <span class="hljs-comment">// Add an extra top frame while an element is being validated</span>

        <span class="hljs-keyword">if</span> (currentlyValidatingElement) {
          <span class="hljs-keyword">var</span> name = getComponentName(currentlyValidatingElement.type);
          <span class="hljs-keyword">var</span> owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner &amp;&amp; getComponentName(owner.type));
        } <span class="hljs-comment">// Delegate to the injected renderer-specific implementation</span>


        <span class="hljs-keyword">var</span> impl = ReactDebugCurrentFrame.getCurrentStack;

        <span class="hljs-keyword">if</span> (impl) {
          stack += impl() || <span class="hljs-string">''</span>;
        }

        <span class="hljs-keyword">return</span> stack;
      };
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<div class="dox">
<div class="summary">
<p>Used by act() to track whether you're inside an act() scope.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> IsSomeRendererActing = {
      <span class="hljs-attr">current</span>: <span class="hljs-literal">false</span>
    };
    <span class="hljs-keyword">var</span> ReactSharedInternals = {
      <span class="hljs-attr">ReactCurrentDispatcher</span>: ReactCurrentDispatcher,
      <span class="hljs-attr">ReactCurrentBatchConfig</span>: ReactCurrentBatchConfig,
      <span class="hljs-attr">ReactCurrentOwner</span>: ReactCurrentOwner,
      <span class="hljs-attr">IsSomeRendererActing</span>: IsSomeRendererActing,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<p>Used by renderers to avoid bundling object-assign twice in UMD bundles:</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      assign: _assign
    };
    {
      _assign(ReactSharedInternals, {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>These should not be included in production.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>Shim for React DOM 16.0.0 which still destructured (but not used) this.
TODO: remove in React 17.0.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        ReactComponentTreeHook: {}
      });
    } <span class="hljs-comment">// by calls to these methods by a Babel plugin.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>In PROD (or in packages without access to React internals),
they are left as they are instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warn</span>(<span class="hljs-params">format</span>) </span>{
      {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len &gt; <span class="hljs-number">1</span> ? _len - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), _key = <span class="hljs-number">1</span>; _key &lt; _len; _key++) {
          args[_key - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[_key];
        }

        printWarning(<span class="hljs-string">'warn'</span>, format, args);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span>(<span class="hljs-params">format</span>) </span>{
      {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len2 = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len2 &gt; <span class="hljs-number">1</span> ? _len2 - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), _key2 = <span class="hljs-number">1</span>; _key2 &lt; _len2; _key2++) {
          args[_key2 - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[_key2];
        }

        printWarning(<span class="hljs-string">'error'</span>, format, args);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printWarning</span>(<span class="hljs-params">level, format, args</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>When changing this logic, you might want to also
update consoleWithStackDev.www.js as well.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      {
        <span class="hljs-keyword">var</span> hasExistingStack = args.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args[args.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'string'</span> &amp;&amp; args[args.length - <span class="hljs-number">1</span>].indexOf(<span class="hljs-string">'\n    in'</span>) === <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (!hasExistingStack) {
          <span class="hljs-keyword">var</span> ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          <span class="hljs-keyword">var</span> stack = ReactDebugCurrentFrame.getStackAddendum();

          <span class="hljs-keyword">if</span> (stack !== <span class="hljs-string">''</span>) {
            format += <span class="hljs-string">'%s'</span>;
            args = args.concat([stack]);
          }
        }

        <span class="hljs-keyword">var</span> argsWithFormat = args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + item;
        }); <span class="hljs-comment">// Careful: RN currently depends on this prefix</span>

        argsWithFormat.unshift(<span class="hljs-string">'Warning: '</span> + format); <span class="hljs-comment">// We intentionally don't use spread (or .apply) directly because it</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>breaks IE9: https://github.com/facebook/react/issues/13610
eslint-disable-next-line react-internal/no-production-logging</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-built_in">Function</span>.prototype.apply.call(<span class="hljs-built_in">console</span>[level], <span class="hljs-built_in">console</span>, argsWithFormat);

        <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>--- Welcome to debugging React ---
This error was thrown as a convenience so that you can use this stack
to find the callsite that caused this warning to fire.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> argIndex = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> message = <span class="hljs-string">'Warning: '</span> + format.replace(<span class="hljs-regexp">/%s/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> args[argIndex++];
          });
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
        } <span class="hljs-keyword">catch</span> (x) {}
      }
    }

    <span class="hljs-keyword">var</span> didWarnStateUpdateForUnmountedComponent = {};

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnNoop</span>(<span class="hljs-params">publicInstance, callerName</span>) </span>{
      {
        <span class="hljs-keyword">var</span> _constructor = publicInstance.constructor;
        <span class="hljs-keyword">var</span> componentName = _constructor &amp;&amp; (_constructor.displayName || _constructor.name) || <span class="hljs-string">'ReactClass'</span>;
        <span class="hljs-keyword">var</span> warningKey = componentName + <span class="hljs-string">"."</span> + callerName;

        <span class="hljs-keyword">if</span> (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          <span class="hljs-keyword">return</span>;
        }

        error(<span class="hljs-string">"Can't call %s on a component that is not yet mounted. "</span> + <span class="hljs-string">'This is a no-op, but it might indicate a bug in your application. '</span> + <span class="hljs-string">'Instead, assign to `this.state` directly or define a `state = {};` '</span> + <span class="hljs-string">'class property with the desired state in the %s component.'</span>, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = <span class="hljs-literal">true</span>;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<div class="dox">
<div class="summary">
<p>This is the abstract API for an update queue.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> ReactNoopUpdateQueue = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<div class="dox">
<div class="summary">
<p>Checks whether or not this composite component is mounted.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">publicInstance</span>
<span class="dox_type">ReactClass</span>
<span>The instance we want to test.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
<span>True if mounted, false otherwise.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      isMounted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">publicInstance</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      },

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<div class="dox">
<div class="summary">
<p>Forces an update. This should only be invoked when it is known with
certainty that we are <strong>not</strong> in a DOM transaction.</p>
</div>
<div class="body">
<p>You may want to call this when you know that some deeper aspect of the
component's state has changed but <code>setState</code> was not called.</p>
<p>This will not invoke <code>shouldComponentUpdate</code>, but it will invoke
<code>componentWillUpdate</code> and <code>componentDidUpdate</code>.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">publicInstance</span>
<span class="dox_type">ReactClass</span>
<span>The instance that should rerender.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callback</span>
<span class="dox_type">function</span>
<span>Called after component is updated.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callerName</span>
<span class="dox_type">string</span>
<span>name of the calling function in the public API.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      enqueueForceUpdate: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">publicInstance, callback, callerName</span>) </span>{
        warnNoop(publicInstance, <span class="hljs-string">'forceUpdate'</span>);
      },

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<div class="dox">
<div class="summary">
<p>Replaces all of the state. Always use this or <code>setState</code> to mutate state.
You should treat <code>this.state</code> as immutable.</p>
</div>
<div class="body">
<p>There is no guarantee that <code>this.state</code> will be immediately updated, so
accessing <code>this.state</code> after calling this method may return the old value.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">publicInstance</span>
<span class="dox_type">ReactClass</span>
<span>The instance that should rerender.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">completeState</span>
<span class="dox_type">object</span>
<span>Next state.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callback</span>
<span class="dox_type">function</span>
<span>Called after component is updated.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callerName</span>
<span class="dox_type">string</span>
<span>name of the calling function in the public API.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      enqueueReplaceState: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">publicInstance, completeState, callback, callerName</span>) </span>{
        warnNoop(publicInstance, <span class="hljs-string">'replaceState'</span>);
      },

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<div class="dox">
<div class="summary">
<p>Sets a subset of the state. This only exists because _pendingState is
internal. This provides a merging strategy that is not available to deep
properties which is confusing. TODO: Expose pendingState or don't use it
during the merge.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">publicInstance</span>
<span class="dox_type">ReactClass</span>
<span>The instance that should rerender.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">partialState</span>
<span class="dox_type">object</span>
<span>Next partial state to be merged with state.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callback</span>
<span class="dox_type">function</span>
<span>Called after component is updated.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">Name</span>
<span class="dox_type">string</span>
<span>of the calling function in the public API.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      enqueueSetState: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">publicInstance, partialState, callback, callerName</span>) </span>{
        warnNoop(publicInstance, <span class="hljs-string">'setState'</span>);
      }
    };
    <span class="hljs-keyword">var</span> emptyObject = {};
    {
      <span class="hljs-built_in">Object</span>.freeze(emptyObject);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<div class="dox">
<div class="summary">
<p>Base class helpers for the updating state of a component.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params">props, context, updater</span>) </span>{
      <span class="hljs-keyword">this</span>.props = props;
      <span class="hljs-keyword">this</span>.context = context; <span class="hljs-comment">// If a component has string refs, we will assign a different object later.</span>

      <span class="hljs-keyword">this</span>.refs = emptyObject; <span class="hljs-comment">// We initialize the default updater but the real one gets injected by the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>renderer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">this</span>.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<div class="dox">
<div class="summary">
<p>Sets a subset of the state. Always use this to mutate
state. You should treat <code>this.state</code> as immutable.</p>
</div>
<div class="body">
<p>There is no guarantee that <code>this.state</code> will be immediately updated, so
accessing <code>this.state</code> after calling this method may return the old value.</p>
<p>There is no guarantee that calls to <code>setState</code> will run synchronously,
as they may eventually be batched together.  You can provide an optional
callback that will be executed when the call to setState is actually
completed.</p>
<p>When a function is provided to setState, it will be called at some point in
the future (not synchronously). It will be called with the up to date
component arguments (state, props, context). These values can be different
from this.* because your function may be called after receiveProps but before
shouldComponentUpdate, and this new state, props, and context will not yet be
assigned to this.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">partialState</span>
<span class="dox_type">object</span>
<span class="dox_type">function</span>
<span>Next partial state or function to        produce next partial state to be merged with current state.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callback</span>
<span class="dox_type">function</span>
<span>Called after state is updated.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    Component.prototype.setState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">partialState, callback</span>) </span>{
      <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">'function'</span> || partialState == <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"setState(...): takes an object of state variables to update or a function which returns an object of state variables."</span>);
        }
      }

      <span class="hljs-keyword">this</span>.updater.enqueueSetState(<span class="hljs-keyword">this</span>, partialState, callback, <span class="hljs-string">'setState'</span>);
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<div class="dox">
<div class="summary">
<p>Forces an update. This should only be invoked when it is known with
certainty that we are <strong>not</strong> in a DOM transaction.</p>
</div>
<div class="body">
<p>You may want to call this when you know that some deeper aspect of the
component's state has changed but <code>setState</code> was not called.</p>
<p>This will not invoke <code>shouldComponentUpdate</code>, but it will invoke
<code>componentWillUpdate</code> and <code>componentDidUpdate</code>.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callback</span>
<span class="dox_type">function</span>
<span>Called after update is complete.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    Component.prototype.forceUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-keyword">this</span>.updater.enqueueForceUpdate(<span class="hljs-keyword">this</span>, callback, <span class="hljs-string">'forceUpdate'</span>);
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<div class="dox">
<div class="summary">
<p>Deprecated APIs. These APIs used to exist on classic React classes but since
we would like to deprecate them, we're not going to move them over to this
modern base class. Instead, we define a getter that warns if it's accessed.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    {
      <span class="hljs-keyword">var</span> deprecatedAPIs = {
        <span class="hljs-attr">isMounted</span>: [<span class="hljs-string">'isMounted'</span>, <span class="hljs-string">'Instead, make sure to clean up subscriptions and pending requests in '</span> + <span class="hljs-string">'componentWillUnmount to prevent memory leaks.'</span>],
        <span class="hljs-attr">replaceState</span>: [<span class="hljs-string">'replaceState'</span>, <span class="hljs-string">'Refactor your code to use setState instead (see '</span> + <span class="hljs-string">'https://github.com/facebook/react/issues/3236).'</span>]
      };

      <span class="hljs-keyword">var</span> defineDeprecationWarning = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">methodName, info</span>) </span>{
        <span class="hljs-built_in">Object</span>.defineProperty(Component.prototype, methodName, {
          <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            warn(<span class="hljs-string">'%s(...) is deprecated in plain JavaScript React classes. %s'</span>, info[<span class="hljs-number">0</span>], info[<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
          }
        });
      };

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> fnName <span class="hljs-keyword">in</span> deprecatedAPIs) {
        <span class="hljs-keyword">if</span> (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ComponentDummy</span>(<span class="hljs-params"></span>) </span>{}

    ComponentDummy.prototype = Component.prototype;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<div class="dox">
<div class="summary">
<p>Convenience component with default shallow equality check for sCU.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PureComponent</span>(<span class="hljs-params">props, context, updater</span>) </span>{
      <span class="hljs-keyword">this</span>.props = props;
      <span class="hljs-keyword">this</span>.context = context; <span class="hljs-comment">// If a component has string refs, we will assign a different object later.</span>

      <span class="hljs-keyword">this</span>.refs = emptyObject;
      <span class="hljs-keyword">this</span>.updater = updater || ReactNoopUpdateQueue;
    }

    <span class="hljs-keyword">var</span> pureComponentPrototype = PureComponent.prototype = <span class="hljs-keyword">new</span> ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; <span class="hljs-comment">// Avoid an extra prototype jump for these methods.</span>

    _assign(pureComponentPrototype, Component.prototype);

    pureComponentPrototype.isPureReactComponent = <span class="hljs-literal">true</span>; <span class="hljs-comment">// an immutable object with a single mutable value</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRef</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> refObject = {
        <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>
      };
      {
        <span class="hljs-built_in">Object</span>.seal(refObject);
      }
      <span class="hljs-keyword">return</span> refObject;
    }

    <span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
    <span class="hljs-keyword">var</span> RESERVED_PROPS = {
      <span class="hljs-attr">key</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">ref</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">__self</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">__source</span>: <span class="hljs-literal">true</span>
    };
    <span class="hljs-keyword">var</span> specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
    {
      didWarnAboutStringRefs = {};
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasValidRef</span>(<span class="hljs-params">config</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(config, <span class="hljs-string">'ref'</span>)) {
          <span class="hljs-keyword">var</span> getter = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(config, <span class="hljs-string">'ref'</span>).get;

          <span class="hljs-keyword">if</span> (getter &amp;&amp; getter.isReactWarning) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        }
      }
      <span class="hljs-keyword">return</span> config.ref !== <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasValidKey</span>(<span class="hljs-params">config</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(config, <span class="hljs-string">'key'</span>)) {
          <span class="hljs-keyword">var</span> getter = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(config, <span class="hljs-string">'key'</span>).get;

          <span class="hljs-keyword">if</span> (getter &amp;&amp; getter.isReactWarning) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        }
      }
      <span class="hljs-keyword">return</span> config.key !== <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineKeyPropWarningGetter</span>(<span class="hljs-params">props, displayName</span>) </span>{
      <span class="hljs-keyword">var</span> warnAboutAccessingKey = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        {
          <span class="hljs-keyword">if</span> (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'%s: `key` is not a prop. Trying to access it will result '</span> + <span class="hljs-string">'in `undefined` being returned. If you need to access the same '</span> + <span class="hljs-string">'value within the child component, you should pass it as a different '</span> + <span class="hljs-string">'prop. (https://fb.me/react-special-props)'</span>, displayName);
          }
        }
      };

      warnAboutAccessingKey.isReactWarning = <span class="hljs-literal">true</span>;
      <span class="hljs-built_in">Object</span>.defineProperty(props, <span class="hljs-string">'key'</span>, {
        <span class="hljs-attr">get</span>: warnAboutAccessingKey,
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineRefPropWarningGetter</span>(<span class="hljs-params">props, displayName</span>) </span>{
      <span class="hljs-keyword">var</span> warnAboutAccessingRef = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        {
          <span class="hljs-keyword">if</span> (!specialPropRefWarningShown) {
            specialPropRefWarningShown = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'%s: `ref` is not a prop. Trying to access it will result '</span> + <span class="hljs-string">'in `undefined` being returned. If you need to access the same '</span> + <span class="hljs-string">'value within the child component, you should pass it as a different '</span> + <span class="hljs-string">'prop. (https://fb.me/react-special-props)'</span>, displayName);
          }
        }
      };

      warnAboutAccessingRef.isReactWarning = <span class="hljs-literal">true</span>;
      <span class="hljs-built_in">Object</span>.defineProperty(props, <span class="hljs-string">'ref'</span>, {
        <span class="hljs-attr">get</span>: warnAboutAccessingRef,
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnIfStringRefCannotBeAutoConverted</span>(<span class="hljs-params">config</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config.ref === <span class="hljs-string">'string'</span> &amp;&amp; ReactCurrentOwner.current &amp;&amp; config.__self &amp;&amp; ReactCurrentOwner.current.stateNode !== config.__self) {
          <span class="hljs-keyword">var</span> componentName = getComponentName(ReactCurrentOwner.current.type);

          <span class="hljs-keyword">if</span> (!didWarnAboutStringRefs[componentName]) {
            error(<span class="hljs-string">'Component "%s" contains the string ref "%s". '</span> + <span class="hljs-string">'Support for string refs will be removed in a future major release. '</span> + <span class="hljs-string">'This case cannot be automatically converted to an arrow function. '</span> + <span class="hljs-string">'We ask you to manually fix this case by using useRef() or createRef() instead. '</span> + <span class="hljs-string">'Learn more about using refs safely here: '</span> + <span class="hljs-string">'https://fb.me/react-strict-mode-string-ref'</span>, getComponentName(ReactCurrentOwner.current.type), config.ref);
            didWarnAboutStringRefs[componentName] = <span class="hljs-literal">true</span>;
          }
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<div class="dox">
<div class="summary">
<p>Factory method to create a new React element. This no longer adheres to
the class pattern, so do not use new to call it. Also, instanceof check
will not work. Instead test $$typeof field against Symbol.for('react.element') to check
if something is a React Element.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">type</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">props</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">key</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">ref</span>
<span class="dox_type">string</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">owner</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">self</span>
<span>A <em>temporary</em> helper to detect places where <code>this</code> is different from the <code>owner</code> when React.createElement is called, so that we
can warn. We want to get rid of owner and replace string <code>ref</code>s with arrow
functions, and as long as <code>this</code> and owner are the same, there will be no
change in behavior.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">source</span>
<span>An annotation object (added by a transpiler or otherwise) indicating filename, line number, and/or other information.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> ReactElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, key, ref, self, source, owner, props</span>) </span>{
      <span class="hljs-keyword">var</span> element = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<p>This tag allows us to uniquely identify this as a React Element</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        $$<span class="hljs-keyword">typeof</span>: REACT_ELEMENT_TYPE,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<p>Built-in properties that belong on the element</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        type: type,
        <span class="hljs-attr">key</span>: key,
        <span class="hljs-attr">ref</span>: ref,
        <span class="hljs-attr">props</span>: props,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<p>Record the component responsible for creating this element.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        _owner: owner
      };
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<p>The validation flag is currently mutative. We put it on
an external backing store so that we can freeze the whole object.
This can be replaced with a WeakMap once they are implemented in
commonly used development environments.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        element._store = {}; <span class="hljs-comment">// To make comparing ReactElements easier for testing purposes, we make</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-58" id="section-58"></a>
</div>
<p>the validation flag non-enumerable (where possible, which should
include every environment we run tests in), so the test framework
ignores it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-built_in">Object</span>.defineProperty(element._store, <span class="hljs-string">'validated'</span>, {
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">value</span>: <span class="hljs-literal">false</span>
        }); <span class="hljs-comment">// self and source are DEV only properties.</span>

        <span class="hljs-built_in">Object</span>.defineProperty(element, <span class="hljs-string">'_self'</span>, {
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">value</span>: self
        }); <span class="hljs-comment">// Two elements created in two different places should be considered</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-59" id="section-59"></a>
</div>
<p>equal for testing purposes and therefore we hide it from enumeration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-built_in">Object</span>.defineProperty(element, <span class="hljs-string">'_source'</span>, {
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">value</span>: source
        });

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.freeze) {
          <span class="hljs-built_in">Object</span>.freeze(element.props);
          <span class="hljs-built_in">Object</span>.freeze(element);
        }
      }
      <span class="hljs-keyword">return</span> element;
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<div class="dox">
<div class="summary">
<p>Create and return a new ReactElement of the given type.
See https://reactjs.org/docs/react-api.html#createelement</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">type, config, children</span>) </span>{
      <span class="hljs-keyword">var</span> propName; <span class="hljs-comment">// Reserved names are extracted</span>

      <span class="hljs-keyword">var</span> props = {};
      <span class="hljs-keyword">var</span> key = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> ref = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> self = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> source = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (config != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (hasValidRef(config)) {
          ref = config.ref;
          {
            warnIfStringRefCannotBeAutoConverted(config);
          }
        }

        <span class="hljs-keyword">if</span> (hasValidKey(config)) {
          key = <span class="hljs-string">''</span> + config.key;
        }

        self = config.__self === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config.__self;
        source = config.__source === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config.__source; <span class="hljs-comment">// Remaining properties are added to a new props object</span>

        <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> config) {
          <span class="hljs-keyword">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      } <span class="hljs-comment">// Children can be more than one argument, and those are transferred onto</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-61" id="section-61"></a>
</div>
<p>the newly allocated props object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> childrenLength = <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (childrenLength === <span class="hljs-number">1</span>) {
        props.children = children;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childrenLength &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> childArray = <span class="hljs-built_in">Array</span>(childrenLength);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; childrenLength; i++) {
          childArray[i] = <span class="hljs-built_in">arguments</span>[i + <span class="hljs-number">2</span>];
        }

        {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.freeze) {
            <span class="hljs-built_in">Object</span>.freeze(childArray);
          }
        }
        props.children = childArray;
      } <span class="hljs-comment">// Resolve default props</span>


      <span class="hljs-keyword">if</span> (type &amp;&amp; type.defaultProps) {
        <span class="hljs-keyword">var</span> defaultProps = type.defaultProps;

        <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> defaultProps) {
          <span class="hljs-keyword">if</span> (props[propName] === <span class="hljs-literal">undefined</span>) {
            props[propName] = defaultProps[propName];
          }
        }
      }

      {
        <span class="hljs-keyword">if</span> (key || ref) {
          <span class="hljs-keyword">var</span> displayName = <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'function'</span> ? type.displayName || type.name || <span class="hljs-string">'Unknown'</span> : type;

          <span class="hljs-keyword">if</span> (key) {
            defineKeyPropWarningGetter(props, displayName);
          }

          <span class="hljs-keyword">if</span> (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
      }
      <span class="hljs-keyword">return</span> ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneAndReplaceKey</span>(<span class="hljs-params">oldElement, newKey</span>) </span>{
      <span class="hljs-keyword">var</span> newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      <span class="hljs-keyword">return</span> newElement;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-62" id="section-62"></a>
</div>
<div class="dox">
<div class="summary">
<p>Clone and return a new ReactElement using element as the starting point.
See https://reactjs.org/docs/react-api.html#cloneelement</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneElement</span>(<span class="hljs-params">element, config, children</span>) </span>{
      <span class="hljs-keyword">if</span> (!!(element === <span class="hljs-literal">null</span> || element === <span class="hljs-literal">undefined</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"React.cloneElement(...): The argument must be a React element, but you passed "</span> + element + <span class="hljs-string">"."</span>);
        }
      }

      <span class="hljs-keyword">var</span> propName; <span class="hljs-comment">// Original props are copied</span>

      <span class="hljs-keyword">var</span> props = _assign({}, element.props); <span class="hljs-comment">// Reserved names are extracted</span>


      <span class="hljs-keyword">var</span> key = element.key;
      <span class="hljs-keyword">var</span> ref = element.ref; <span class="hljs-comment">// Self is preserved since the owner is preserved.</span>

      <span class="hljs-keyword">var</span> self = element._self; <span class="hljs-comment">// Source is preserved since cloneElement is unlikely to be targeted by a</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-63" id="section-63"></a>
</div>
<p>transpiler, and the original source is probably a better indicator of the
true owner.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> source = element._source; <span class="hljs-comment">// Owner will be preserved, unless ref is overridden</span>

      <span class="hljs-keyword">var</span> owner = element._owner;

      <span class="hljs-keyword">if</span> (config != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (hasValidRef(config)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-64" id="section-64"></a>
</div>
<p>Silently steal the ref from the parent.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }

        <span class="hljs-keyword">if</span> (hasValidKey(config)) {
          key = <span class="hljs-string">''</span> + config.key;
        } <span class="hljs-comment">// Remaining properties override existing props</span>


        <span class="hljs-keyword">var</span> defaultProps;

        <span class="hljs-keyword">if</span> (element.type &amp;&amp; element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }

        <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> config) {
          <span class="hljs-keyword">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {
            <span class="hljs-keyword">if</span> (config[propName] === <span class="hljs-literal">undefined</span> &amp;&amp; defaultProps !== <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-65" id="section-65"></a>
</div>
<p>Resolve default props</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              props[propName] = defaultProps[propName];
            } <span class="hljs-keyword">else</span> {
              props[propName] = config[propName];
            }
          }
        }
      } <span class="hljs-comment">// Children can be more than one argument, and those are transferred onto</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-66" id="section-66"></a>
</div>
<p>the newly allocated props object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> childrenLength = <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (childrenLength === <span class="hljs-number">1</span>) {
        props.children = children;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childrenLength &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> childArray = <span class="hljs-built_in">Array</span>(childrenLength);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; childrenLength; i++) {
          childArray[i] = <span class="hljs-built_in">arguments</span>[i + <span class="hljs-number">2</span>];
        }

        props.children = childArray;
      }

      <span class="hljs-keyword">return</span> ReactElement(element.type, key, ref, self, source, owner, props);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-67" id="section-67"></a>
</div>
<div class="dox">
<div class="summary">
<p>Verifies the object is a ReactElement.
See https://reactjs.org/docs/react-api.html#isvalidelement</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">object</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
<span>True if <code>object</code> is a ReactElement.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidElement</span>(<span class="hljs-params">object</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> object === <span class="hljs-string">'object'</span> &amp;&amp; object !== <span class="hljs-literal">null</span> &amp;&amp; object.$$<span class="hljs-keyword">typeof</span> === REACT_ELEMENT_TYPE;
    }

    <span class="hljs-keyword">var</span> SEPARATOR = <span class="hljs-string">'.'</span>;
    <span class="hljs-keyword">var</span> SUBSEPARATOR = <span class="hljs-string">':'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-68" id="section-68"></a>
</div>
<div class="dox">
<div class="summary">
<p>Escape and wrap key so it is safe to use as a reactid</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">key</span>
<span class="dox_type">string</span>
<span>to be escaped.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
<span>the escaped key.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escape</span>(<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">var</span> escapeRegex = <span class="hljs-regexp">/[=:]/g</span>;
      <span class="hljs-keyword">var</span> escaperLookup = {
        <span class="hljs-string">'='</span>: <span class="hljs-string">'=0'</span>,
        <span class="hljs-string">':'</span>: <span class="hljs-string">'=2'</span>
      };
      <span class="hljs-keyword">var</span> escapedString = (<span class="hljs-string">''</span> + key).replace(escapeRegex, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>{
        <span class="hljs-keyword">return</span> escaperLookup[match];
      });
      <span class="hljs-keyword">return</span> <span class="hljs-string">'$'</span> + escapedString;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-69" id="section-69"></a>
</div>
<div class="dox">
<div class="summary">
<p>TODO: Test that a single child and an array with one item have the same key
pattern.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> didWarnAboutMaps = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> userProvidedKeyEscapeRegex = <span class="hljs-regexp">/\/+/g</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapeUserProvidedKey</span>(<span class="hljs-params">text</span>) </span>{
      <span class="hljs-keyword">return</span> (<span class="hljs-string">''</span> + text).replace(userProvidedKeyEscapeRegex, <span class="hljs-string">'$&amp;/'</span>);
    }

    <span class="hljs-keyword">var</span> POOL_SIZE = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">var</span> traverseContextPool = [];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPooledTraverseContext</span>(<span class="hljs-params">mapResult, keyPrefix, mapFunction, mapContext</span>) </span>{
      <span class="hljs-keyword">if</span> (traverseContextPool.length) {
        <span class="hljs-keyword">var</span> traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> traverseContext;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">result</span>: mapResult,
          <span class="hljs-attr">keyPrefix</span>: keyPrefix,
          <span class="hljs-attr">func</span>: mapFunction,
          <span class="hljs-attr">context</span>: mapContext,
          <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
        };
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">releaseTraverseContext</span>(<span class="hljs-params">traverseContext</span>) </span>{
      traverseContext.result = <span class="hljs-literal">null</span>;
      traverseContext.keyPrefix = <span class="hljs-literal">null</span>;
      traverseContext.func = <span class="hljs-literal">null</span>;
      traverseContext.context = <span class="hljs-literal">null</span>;
      traverseContext.count = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (traverseContextPool.length &lt; POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-70" id="section-70"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">children</span>
<span>Children tree container.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nameSoFar</span>
<span class="dox_type">string</span>
<span>Name of the key path so far.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callback</span>
<span class="dox_type">function</span>
<span>Callback to invoke with each child found.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">traverseContext</span>
<span>Used to pass information throughout the traversal process.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">number</span>
<span>The number of children in this subtree.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseAllChildrenImpl</span>(<span class="hljs-params">children, nameSoFar, callback, traverseContext</span>) </span>{
      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> children;

      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'undefined'</span> || type === <span class="hljs-string">'boolean'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-71" id="section-71"></a>
</div>
<p>All of the above are perceived as null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        children = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> invokeCallback = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (children === <span class="hljs-literal">null</span>) {
        invokeCallback = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">switch</span> (type) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:
            invokeCallback = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:
            <span class="hljs-keyword">switch</span> (children.$$<span class="hljs-keyword">typeof</span>) {
              <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
              <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
                invokeCallback = <span class="hljs-literal">true</span>;
            }

        }
      }

      <span class="hljs-keyword">if</span> (invokeCallback) {
        callback(traverseContext, children, <span class="hljs-comment">// If it's the only child, treat the name as if it was wrapped in an array</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-72" id="section-72"></a>
</div>
<p>so that it's consistent if the number of children grows.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        nameSoFar === <span class="hljs-string">''</span> ? SEPARATOR + getComponentKey(children, <span class="hljs-number">0</span>) : nameSoFar);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">var</span> child;
      <span class="hljs-keyword">var</span> nextName;
      <span class="hljs-keyword">var</span> subtreeCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Count of children found in the current subtree.</span>

      <span class="hljs-keyword">var</span> nextNamePrefix = nameSoFar === <span class="hljs-string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(children)) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> iteratorFn = getIteratorFn(children);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> iteratorFn === <span class="hljs-string">'function'</span>) {
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-73" id="section-73"></a>
</div>
<p>Warn about using Maps as children</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (iteratorFn === children.entries) {
              <span class="hljs-keyword">if</span> (!didWarnAboutMaps) {
                warn(<span class="hljs-string">'Using Maps as children is deprecated and will be removed in '</span> + <span class="hljs-string">'a future major release. Consider converting children to '</span> + <span class="hljs-string">'an array of keyed ReactElements instead.'</span>);
              }

              didWarnAboutMaps = <span class="hljs-literal">true</span>;
            }
          }
          <span class="hljs-keyword">var</span> iterator = iteratorFn.call(children);
          <span class="hljs-keyword">var</span> step;
          <span class="hljs-keyword">var</span> ii = <span class="hljs-number">0</span>;

          <span class="hljs-keyword">while</span> (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'object'</span>) {
          <span class="hljs-keyword">var</span> addendum = <span class="hljs-string">''</span>;
          {
            addendum = <span class="hljs-string">' If you meant to render a collection of children, use an array '</span> + <span class="hljs-string">'instead.'</span> + ReactDebugCurrentFrame.getStackAddendum();
          }
          <span class="hljs-keyword">var</span> childrenString = <span class="hljs-string">''</span> + children;
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Objects are not valid as a React child (found: "</span> + (childrenString === <span class="hljs-string">'[object Object]'</span> ? <span class="hljs-string">'object with keys {'</span> + <span class="hljs-built_in">Object</span>.keys(children).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'}'</span> : childrenString) + <span class="hljs-string">")."</span> + addendum);
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> subtreeCount;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-74" id="section-74"></a>
</div>
<div class="dox">
<div class="summary">
<p>Traverses children that are typically specified as <code>props.children</code>, but
might also be specified through attributes:</p>
</div>
<div class="body">
<ul>
<li><code>traverseAllChildren(this.props.children, ...)</code></li>
<li><code>traverseAllChildren(this.props.leftPanelChildren, ...)</code></li>
</ul>
<p>The <code>traverseContext</code> is an optional argument that is passed through the
entire traversal. It can be used to store accumulations or anything else that
the callback might find relevant.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">children</span>
<span>Children tree object.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">callback</span>
<span class="dox_type">function</span>
<span>To invoke upon traversing each child.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">traverseContext</span>
<span>Context for traversal.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">number</span>
<span>The number of children in this subtree.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseAllChildren</span>(<span class="hljs-params">children, callback, traverseContext</span>) </span>{
      <span class="hljs-keyword">if</span> (children == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }

      <span class="hljs-keyword">return</span> traverseAllChildrenImpl(children, <span class="hljs-string">''</span>, callback, traverseContext);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-75" id="section-75"></a>
</div>
<div class="dox">
<div class="summary">
<p>Generate a key string that identifies a component within a set.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">component</span>
<span>A component that could contain a manual key.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">index</span>
<span class="dox_type">number</span>
<span>Index that is used if a manual key is not provided.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getComponentKey</span>(<span class="hljs-params">component, index</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-76" id="section-76"></a>
</div>
<p>Do some typechecking here since we call this blindly. We want to ensure
that we don't block potential future ES APIs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> component === <span class="hljs-string">'object'</span> &amp;&amp; component !== <span class="hljs-literal">null</span> &amp;&amp; component.key != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-77" id="section-77"></a>
</div>
<p>Explicit key</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">escape</span>(component.key);
      } <span class="hljs-comment">// Implicit key determined by the index in the set</span>


      <span class="hljs-keyword">return</span> index.toString(<span class="hljs-number">36</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachSingleChild</span>(<span class="hljs-params">bookKeeping, child, name</span>) </span>{
      <span class="hljs-keyword">var</span> func = bookKeeping.func,
          context = bookKeeping.context;
      func.call(context, child, bookKeeping.count++);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-78" id="section-78"></a>
</div>
<div class="dox">
<div class="summary">
<p>Iterates through children that are typically specified as <code>props.children</code>.</p>
</div>
<div class="body">
<p>See https://reactjs.org/docs/react-api.html#reactchildrenforeach</p>
<p>The provided forEachFunc(child, index) will be called for each
leaf child.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">children</span>
<span>Children tree container.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">forEachFunc</span>
<span class="dox_type">function(*, int)</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">forEachContext</span>
<span>Context for forEachContext.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachChildren</span>(<span class="hljs-params">children, forEachFunc, forEachContext</span>) </span>{
      <span class="hljs-keyword">if</span> (children == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> children;
      }

      <span class="hljs-keyword">var</span> traverseContext = getPooledTraverseContext(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapSingleChildIntoContext</span>(<span class="hljs-params">bookKeeping, child, childKey</span>) </span>{
      <span class="hljs-keyword">var</span> result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;
      <span class="hljs-keyword">var</span> mappedChild = func.call(context, child, bookKeeping.count++);

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>{
          <span class="hljs-keyword">return</span> c;
        });
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappedChild != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild, <span class="hljs-comment">// Keep both the (mapped) and old keys if they differ, just as</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-79" id="section-79"></a>
</div>
<p>traverseAllChildren used to do for objects as children</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + <span class="hljs-string">'/'</span> : <span class="hljs-string">''</span>) + childKey);
        }

        result.push(mappedChild);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapIntoWithKeyPrefixInternal</span>(<span class="hljs-params">children, array, prefix, func, context</span>) </span>{
      <span class="hljs-keyword">var</span> escapedPrefix = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">if</span> (prefix != <span class="hljs-literal">null</span>) {
        escapedPrefix = escapeUserProvidedKey(prefix) + <span class="hljs-string">'/'</span>;
      }

      <span class="hljs-keyword">var</span> traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-80" id="section-80"></a>
</div>
<div class="dox">
<div class="summary">
<p>Maps children that are typically specified as <code>props.children</code>.</p>
</div>
<div class="body">
<p>See https://reactjs.org/docs/react-api.html#reactchildrenmap</p>
<p>The provided mapFunction(child, key, index) will be called for each
leaf child.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">children</span>
<span>Children tree container.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">func</span>
<span class="dox_type">function(*, int)</span>
<span>The map function.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">context</span>
<span>Context for mapFunction.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
<span>Object containing the ordered map of results.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapChildren</span>(<span class="hljs-params">children, func, context</span>) </span>{
      <span class="hljs-keyword">if</span> (children == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> children;
      }

      <span class="hljs-keyword">var</span> result = [];
      mapIntoWithKeyPrefixInternal(children, result, <span class="hljs-literal">null</span>, func, context);
      <span class="hljs-keyword">return</span> result;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-81" id="section-81"></a>
</div>
<div class="dox">
<div class="summary">
<p>Count the number of children that are typically specified as
<code>props.children</code>.</p>
</div>
<div class="body">
<p>See https://reactjs.org/docs/react-api.html#reactchildrencount</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">children</span>
<span>Children tree container.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">number</span>
<span>The number of children.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countChildren</span>(<span class="hljs-params">children</span>) </span>{
      <span class="hljs-keyword">return</span> traverseAllChildren(children, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }, <span class="hljs-literal">null</span>);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-82" id="section-82"></a>
</div>
<div class="dox">
<div class="summary">
<p>Flatten a children object (typically specified as <code>props.children</code>) and
return an array with appropriately re-keyed children.</p>
</div>
<div class="body">
<p>See https://reactjs.org/docs/react-api.html#reactchildrentoarray</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">children</span>) </span>{
      <span class="hljs-keyword">var</span> result = [];
      mapIntoWithKeyPrefixInternal(children, result, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
        <span class="hljs-keyword">return</span> child;
      });
      <span class="hljs-keyword">return</span> result;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-83" id="section-83"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the first child in a collection of children and verifies that there
is only one child in the collection.</p>
</div>
<div class="body">
<p>See https://reactjs.org/docs/react-api.html#reactchildrenonly</p>
<p>The current implementation of this function assumes that a single child gets
passed without a wrapper, but the purpose of this helper function is to
abstract away the particular structure of children.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">children</span>
<span class="dox_type">object</span>
<span>Child collection structure.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">ReactElement</span>
<span>The first and only <code>ReactElement</code> contained in the structure.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onlyChild</span>(<span class="hljs-params">children</span>) </span>{
      <span class="hljs-keyword">if</span> (!isValidElement(children)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"React.Children.only expected to receive a single React element child."</span>);
        }
      }

      <span class="hljs-keyword">return</span> children;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContext</span>(<span class="hljs-params">defaultValue, calculateChangedBits</span>) </span>{
      <span class="hljs-keyword">if</span> (calculateChangedBits === <span class="hljs-literal">undefined</span>) {
        calculateChangedBits = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        {
          <span class="hljs-keyword">if</span> (calculateChangedBits !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> calculateChangedBits !== <span class="hljs-string">'function'</span>) {
            error(<span class="hljs-string">'createContext: Expected the optional second argument to be a '</span> + <span class="hljs-string">'function. Instead received: %s'</span>, calculateChangedBits);
          }
        }
      }

      <span class="hljs-keyword">var</span> context = {
        <span class="hljs-attr">$$typeof</span>: REACT_CONTEXT_TYPE,
        <span class="hljs-attr">_calculateChangedBits</span>: calculateChangedBits,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-84" id="section-84"></a>
</div>
<p>As a workaround to support multiple concurrent renderers, we categorize
some renderers as primary and others as secondary. We only expect
there to be two concurrent renderers at most: React Native (primary) and
Fabric (secondary); React DOM (primary) and React ART (secondary).
Secondary renderers store their context values on separate fields.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        _currentValue: defaultValue,
        <span class="hljs-attr">_currentValue2</span>: defaultValue,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-85" id="section-85"></a>
</div>
<p>Used to track how many concurrent renderers this context currently
supports within in a single renderer. Such as parallel server rendering.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        _threadCount: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-86" id="section-86"></a>
</div>
<p>These are circular</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        Provider: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">Consumer</span>: <span class="hljs-literal">null</span>
      };
      context.Provider = {
        <span class="hljs-attr">$$typeof</span>: REACT_PROVIDER_TYPE,
        <span class="hljs-attr">_context</span>: context
      };
      <span class="hljs-keyword">var</span> hasWarnedAboutUsingNestedContextConsumers = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> hasWarnedAboutUsingConsumerProvider = <span class="hljs-literal">false</span>;
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-87" id="section-87"></a>
</div>
<p>A separate object, but proxies back to the original context object for
backwards compatibility. It has a different $$typeof, so we can properly
warn for the incorrect usage of Context as a Consumer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> Consumer = {
          <span class="hljs-attr">$$typeof</span>: REACT_CONTEXT_TYPE,
          <span class="hljs-attr">_context</span>: context,
          <span class="hljs-attr">_calculateChangedBits</span>: context._calculateChangedBits
        }; <span class="hljs-comment">// $FlowFixMe: Flow complains about not setting a value, which is intentional here</span>

        <span class="hljs-built_in">Object</span>.defineProperties(Consumer, {
          <span class="hljs-attr">Provider</span>: {
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">if</span> (!hasWarnedAboutUsingConsumerProvider) {
                hasWarnedAboutUsingConsumerProvider = <span class="hljs-literal">true</span>;
                error(<span class="hljs-string">'Rendering &lt;Context.Consumer.Provider&gt; is not supported and will be removed in '</span> + <span class="hljs-string">'a future major release. Did you mean to render &lt;Context.Provider&gt; instead?'</span>);
              }

              <span class="hljs-keyword">return</span> context.Provider;
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Provider</span>) </span>{
              context.Provider = _Provider;
            }
          },
          <span class="hljs-attr">_currentValue</span>: {
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> context._currentValue;
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_currentValue</span>) </span>{
              context._currentValue = _currentValue;
            }
          },
          <span class="hljs-attr">_currentValue2</span>: {
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> context._currentValue2;
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_currentValue2</span>) </span>{
              context._currentValue2 = _currentValue2;
            }
          },
          <span class="hljs-attr">_threadCount</span>: {
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> context._threadCount;
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_threadCount</span>) </span>{
              context._threadCount = _threadCount;
            }
          },
          <span class="hljs-attr">Consumer</span>: {
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">if</span> (!hasWarnedAboutUsingNestedContextConsumers) {
                hasWarnedAboutUsingNestedContextConsumers = <span class="hljs-literal">true</span>;
                error(<span class="hljs-string">'Rendering &lt;Context.Consumer.Consumer&gt; is not supported and will be removed in '</span> + <span class="hljs-string">'a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?'</span>);
              }

              <span class="hljs-keyword">return</span> context.Consumer;
            }
          }
        }); <span class="hljs-comment">// $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty</span>

        context.Consumer = Consumer;
      }
      {
        context._currentRenderer = <span class="hljs-literal">null</span>;
        context._currentRenderer2 = <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">return</span> context;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazy</span>(<span class="hljs-params">ctor</span>) </span>{
      <span class="hljs-keyword">var</span> lazyType = {
        <span class="hljs-attr">$$typeof</span>: REACT_LAZY_TYPE,
        <span class="hljs-attr">_ctor</span>: ctor,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-88" id="section-88"></a>
</div>
<p>React uses these fields to store the result.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        _status: <span class="hljs-number">-1</span>,
        <span class="hljs-attr">_result</span>: <span class="hljs-literal">null</span>
      };
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-89" id="section-89"></a>
</div>
<p>In production, this would just set it on the object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> defaultProps;
        <span class="hljs-keyword">var</span> propTypes;
        <span class="hljs-built_in">Object</span>.defineProperties(lazyType, {
          <span class="hljs-attr">defaultProps</span>: {
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> defaultProps;
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newDefaultProps</span>) </span>{
              error(<span class="hljs-string">'React.lazy(...): It is not supported to assign `defaultProps` to '</span> + <span class="hljs-string">'a lazy component import. Either specify them where the component '</span> + <span class="hljs-string">'is defined, or create a wrapping component around it.'</span>);
              defaultProps = newDefaultProps; <span class="hljs-comment">// Match production behavior more closely:</span>

              <span class="hljs-built_in">Object</span>.defineProperty(lazyType, <span class="hljs-string">'defaultProps'</span>, {
                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
              });
            }
          },
          <span class="hljs-attr">propTypes</span>: {
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">return</span> propTypes;
            },
            <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newPropTypes</span>) </span>{
              error(<span class="hljs-string">'React.lazy(...): It is not supported to assign `propTypes` to '</span> + <span class="hljs-string">'a lazy component import. Either specify them where the component '</span> + <span class="hljs-string">'is defined, or create a wrapping component around it.'</span>);
              propTypes = newPropTypes; <span class="hljs-comment">// Match production behavior more closely:</span>

              <span class="hljs-built_in">Object</span>.defineProperty(lazyType, <span class="hljs-string">'propTypes'</span>, {
                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
              });
            }
          }
        });
      }
      <span class="hljs-keyword">return</span> lazyType;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forwardRef</span>(<span class="hljs-params">render</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (render != <span class="hljs-literal">null</span> &amp;&amp; render.$$<span class="hljs-keyword">typeof</span> === REACT_MEMO_TYPE) {
          error(<span class="hljs-string">'forwardRef requires a render function but received a `memo` '</span> + <span class="hljs-string">'component. Instead of forwardRef(memo(...)), use '</span> + <span class="hljs-string">'memo(forwardRef(...)).'</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> render !== <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'forwardRef requires a render function but was given %s.'</span>, render === <span class="hljs-literal">null</span> ? <span class="hljs-string">'null'</span> : <span class="hljs-keyword">typeof</span> render);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (render.length !== <span class="hljs-number">0</span> &amp;&amp; render.length !== <span class="hljs-number">2</span>) {
            error(<span class="hljs-string">'forwardRef render functions accept exactly two parameters: props and ref. %s'</span>, render.length === <span class="hljs-number">1</span> ? <span class="hljs-string">'Did you forget to use the ref parameter?'</span> : <span class="hljs-string">'Any additional parameter will be undefined.'</span>);
          }
        }

        <span class="hljs-keyword">if</span> (render != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (render.defaultProps != <span class="hljs-literal">null</span> || render.propTypes != <span class="hljs-literal">null</span>) {
            error(<span class="hljs-string">'forwardRef render functions do not support propTypes or defaultProps. '</span> + <span class="hljs-string">'Did you accidentally pass a React component?'</span>);
          }
        }
      }
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">$$typeof</span>: REACT_FORWARD_REF_TYPE,
        <span class="hljs-attr">render</span>: render
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidElementType</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'function'</span> || <span class="hljs-comment">// Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.</span>
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'object'</span> &amp;&amp; type !== <span class="hljs-literal">null</span> &amp;&amp; (type.$$<span class="hljs-keyword">typeof</span> === REACT_LAZY_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_MEMO_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_PROVIDER_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_CONTEXT_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_FORWARD_REF_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_FUNDAMENTAL_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_RESPONDER_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_SCOPE_TYPE || type.$$<span class="hljs-keyword">typeof</span> === REACT_BLOCK_TYPE);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memo</span>(<span class="hljs-params">type, compare</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!isValidElementType(type)) {
          error(<span class="hljs-string">'memo: The first argument must be a component. Instead '</span> + <span class="hljs-string">'received: %s'</span>, type === <span class="hljs-literal">null</span> ? <span class="hljs-string">'null'</span> : <span class="hljs-keyword">typeof</span> type);
        }
      }
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">$$typeof</span>: REACT_MEMO_TYPE,
        <span class="hljs-attr">type</span>: type,
        <span class="hljs-attr">compare</span>: compare === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : compare
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveDispatcher</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = ReactCurrentDispatcher.current;

      <span class="hljs-keyword">if</span> (!(dispatcher !== <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem."</span>);
        }
      }

      <span class="hljs-keyword">return</span> dispatcher;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useContext</span>(<span class="hljs-params">Context, unstable_observedBits</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      {
        <span class="hljs-keyword">if</span> (unstable_observedBits !== <span class="hljs-literal">undefined</span>) {
          error(<span class="hljs-string">'useContext() second argument is reserved for future '</span> + <span class="hljs-string">'use in React. Passing it is not supported. '</span> + <span class="hljs-string">'You passed: %s.%s'</span>, unstable_observedBits, <span class="hljs-keyword">typeof</span> unstable_observedBits === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]) ? <span class="hljs-string">'\n\nDid you call array.map(useContext)? '</span> + <span class="hljs-string">'Calling Hooks inside a loop is not supported. '</span> + <span class="hljs-string">'Learn more at https://fb.me/rules-of-hooks'</span> : <span class="hljs-string">''</span>);
        } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add a more generic warning for invalid values.</span>


        <span class="hljs-keyword">if</span> (Context._context !== <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">var</span> realContext = Context._context; <span class="hljs-comment">// Don't deduplicate because this legitimately causes bugs</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-90" id="section-90"></a>
</div>
<p>and nobody should be using this in existing code.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">if</span> (realContext.Consumer === Context) {
            error(<span class="hljs-string">'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be '</span> + <span class="hljs-string">'removed in a future major release. Did you mean to call useContext(Context) instead?'</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (realContext.Provider === Context) {
            error(<span class="hljs-string">'Calling useContext(Context.Provider) is not supported. '</span> + <span class="hljs-string">'Did you mean to call useContext(Context) instead?'</span>);
          }
        }
      }
      <span class="hljs-keyword">return</span> dispatcher.useContext(Context, unstable_observedBits);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>(<span class="hljs-params">initialState</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useState(initialState);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useReducer(reducer, initialArg, init);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useRef</span>(<span class="hljs-params">initialValue</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useRef(initialValue);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useEffect</span>(<span class="hljs-params">create, deps</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useEffect(create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useLayoutEffect</span>(<span class="hljs-params">create, deps</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useLayoutEffect(create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useCallback</span>(<span class="hljs-params">callback, deps</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useCallback(callback, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMemo</span>(<span class="hljs-params">create, deps</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useMemo(create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useImperativeHandle</span>(<span class="hljs-params">ref, create, deps</span>) </span>{
      <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
      <span class="hljs-keyword">return</span> dispatcher.useImperativeHandle(ref, create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useDebugValue</span>(<span class="hljs-params">value, formatterFn</span>) </span>{
      {
        <span class="hljs-keyword">var</span> dispatcher = resolveDispatcher();
        <span class="hljs-keyword">return</span> dispatcher.useDebugValue(value, formatterFn);
      }
    }

    <span class="hljs-keyword">var</span> propTypesMisspellWarningShown;
    {
      propTypesMisspellWarningShown = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDeclarationErrorAddendum</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (ReactCurrentOwner.current) {
        <span class="hljs-keyword">var</span> name = getComponentName(ReactCurrentOwner.current.type);

        <span class="hljs-keyword">if</span> (name) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">'\n\nCheck the render method of `'</span> + name + <span class="hljs-string">'`.'</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSourceInfoErrorAddendum</span>(<span class="hljs-params">source</span>) </span>{
      <span class="hljs-keyword">if</span> (source !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> fileName = source.fileName.replace(<span class="hljs-regexp">/^.*[\\\/]/</span>, <span class="hljs-string">''</span>);
        <span class="hljs-keyword">var</span> lineNumber = source.lineNumber;
        <span class="hljs-keyword">return</span> <span class="hljs-string">'\n\nCheck your code at '</span> + fileName + <span class="hljs-string">':'</span> + lineNumber + <span class="hljs-string">'.'</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSourceInfoErrorAddendumForProps</span>(<span class="hljs-params">elementProps</span>) </span>{
      <span class="hljs-keyword">if</span> (elementProps !== <span class="hljs-literal">null</span> &amp;&amp; elementProps !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">return</span> getSourceInfoErrorAddendum(elementProps.__source);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-91" id="section-91"></a>
</div>
<div class="dox">
<div class="summary">
<p>Warn if there's no key explicitly set on dynamic arrays of children or
object keys are not valid. This allows us to keep track of children between
updates.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> ownerHasKeyUseWarning = {};

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrentComponentErrorInfo</span>(<span class="hljs-params">parentType</span>) </span>{
      <span class="hljs-keyword">var</span> info = getDeclarationErrorAddendum();

      <span class="hljs-keyword">if</span> (!info) {
        <span class="hljs-keyword">var</span> parentName = <span class="hljs-keyword">typeof</span> parentType === <span class="hljs-string">'string'</span> ? parentType : parentType.displayName || parentType.name;

        <span class="hljs-keyword">if</span> (parentName) {
          info = <span class="hljs-string">"\n\nCheck the top-level render call using &lt;"</span> + parentName + <span class="hljs-string">"&gt;."</span>;
        }
      }

      <span class="hljs-keyword">return</span> info;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-92" id="section-92"></a>
</div>
<div class="dox">
<div class="summary">
<p>Warn if the element doesn't have an explicit key assigned to it.
This element is in an array. The array could grow and shrink or be
reordered. All children that haven't already been validated are required to
have a &quot;key&quot; property assigned to it. Error statuses are cached so a warning
will only be shown once.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">element</span>
<span class="dox_type">ReactElement</span>
<span>Element that requires a key.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">parentType</span>
<span>element's parent's type.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateExplicitKey</span>(<span class="hljs-params">element, parentType</span>) </span>{
      <span class="hljs-keyword">if</span> (!element._store || element._store.validated || element.key != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>;
      }

      element._store.validated = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

      <span class="hljs-keyword">if</span> (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        <span class="hljs-keyword">return</span>;
      }

      ownerHasKeyUseWarning[currentComponentErrorInfo] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Usually the current owner is the offender, but if it accepts children as a</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-93" id="section-93"></a>
</div>
<p>property, it may be the creator of the child that's responsible for
assigning it a key.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> childOwner = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">if</span> (element &amp;&amp; element._owner &amp;&amp; element._owner !== ReactCurrentOwner.current) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-94" id="section-94"></a>
</div>
<p>Give the component that originally created this child.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        childOwner = <span class="hljs-string">" It was passed a child from "</span> + getComponentName(element._owner.type) + <span class="hljs-string">"."</span>;
      }

      setCurrentlyValidatingElement(element);
      {
        error(<span class="hljs-string">'Each child in a list should have a unique "key" prop.'</span> + <span class="hljs-string">'%s%s See https://fb.me/react-warning-keys for more information.'</span>, currentComponentErrorInfo, childOwner);
      }
      setCurrentlyValidatingElement(<span class="hljs-literal">null</span>);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-95" id="section-95"></a>
</div>
<div class="dox">
<div class="summary">
<p>Ensure that every element either is passed in a static location, in an
array with an explicit keys property defined, or in an object literal
with valid key property.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">ReactNode</span>
<span>Statically passed child of any type.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">parentType</span>
<span>node's parent's type.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateChildKeys</span>(<span class="hljs-params">node, parentType</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node !== <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(node)) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; node.length; i++) {
          <span class="hljs-keyword">var</span> child = node[i];

          <span class="hljs-keyword">if</span> (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isValidElement(node)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-96" id="section-96"></a>
</div>
<p>This element was passed in a valid location.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (node._store) {
          node._store.validated = <span class="hljs-literal">true</span>;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node) {
        <span class="hljs-keyword">var</span> iteratorFn = getIteratorFn(node);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> iteratorFn === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-97" id="section-97"></a>
</div>
<p>Entry iterators used to provide implicit keys,
but now we print a separate warning for them later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (iteratorFn !== node.entries) {
            <span class="hljs-keyword">var</span> iterator = iteratorFn.call(node);
            <span class="hljs-keyword">var</span> step;

            <span class="hljs-keyword">while</span> (!(step = iterator.next()).done) {
              <span class="hljs-keyword">if</span> (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-98" id="section-98"></a>
</div>
<div class="dox">
<div class="summary">
<p>Given an element, validate that its props follow the propTypes definition,
provided by the type.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">element</span>
<span class="dox_type">ReactElement</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validatePropTypes</span>(<span class="hljs-params">element</span>) </span>{
      {
        <span class="hljs-keyword">var</span> type = element.type;

        <span class="hljs-keyword">if</span> (type === <span class="hljs-literal">null</span> || type === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'string'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> name = getComponentName(type);
        <span class="hljs-keyword">var</span> propTypes;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'function'</span>) {
          propTypes = type.propTypes;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'object'</span> &amp;&amp; (type.$$<span class="hljs-keyword">typeof</span> === REACT_FORWARD_REF_TYPE || <span class="hljs-comment">// Note: Memo only checks outer props here.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-99" id="section-99"></a>
</div>
<p>Inner props are checked in the reconciler.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        type.$$<span class="hljs-keyword">typeof</span> === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (propTypes) {
          setCurrentlyValidatingElement(element);
          checkPropTypes(propTypes, element.props, <span class="hljs-string">'prop'</span>, name, ReactDebugCurrentFrame.getStackAddendum);
          setCurrentlyValidatingElement(<span class="hljs-literal">null</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.PropTypes !== <span class="hljs-literal">undefined</span> &amp;&amp; !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = <span class="hljs-literal">true</span>;
          error(<span class="hljs-string">'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?'</span>, name || <span class="hljs-string">'Unknown'</span>);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type.getDefaultProps === <span class="hljs-string">'function'</span> &amp;&amp; !type.getDefaultProps.isReactClassApproved) {
          error(<span class="hljs-string">'getDefaultProps is only used on classic React.createClass '</span> + <span class="hljs-string">'definitions. Use a static property named `defaultProps` instead.'</span>);
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-100" id="section-100"></a>
</div>
<div class="dox">
<div class="summary">
<p>Given a fragment, validate that it can only be provided with fragment props</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">fragment</span>
<span class="dox_type">ReactElement</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateFragmentProps</span>(<span class="hljs-params">fragment</span>) </span>{
      {
        setCurrentlyValidatingElement(fragment);
        <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(fragment.props);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
          <span class="hljs-keyword">var</span> key = keys[i];

          <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'children'</span> &amp;&amp; key !== <span class="hljs-string">'key'</span>) {
            error(<span class="hljs-string">'Invalid prop `%s` supplied to `React.Fragment`. '</span> + <span class="hljs-string">'React.Fragment can only have `key` and `children` props.'</span>, key);
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">if</span> (fragment.ref !== <span class="hljs-literal">null</span>) {
          error(<span class="hljs-string">'Invalid attribute `ref` supplied to `React.Fragment`.'</span>);
        }

        setCurrentlyValidatingElement(<span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElementWithValidation</span>(<span class="hljs-params">type, props, children</span>) </span>{
      <span class="hljs-keyword">var</span> validType = isValidElementType(type); <span class="hljs-comment">// We warn in this case but don't throw. We expect the element creation to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-101" id="section-101"></a>
</div>
<p>succeed and there will likely be errors in render.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (!validType) {
        <span class="hljs-keyword">var</span> info = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">if</span> (type === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'object'</span> &amp;&amp; type !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys(type).length === <span class="hljs-number">0</span>) {
          info += <span class="hljs-string">' You likely forgot to export your component from the file '</span> + <span class="hljs-string">"it's defined in, or you might have mixed up default and named imports."</span>;
        }

        <span class="hljs-keyword">var</span> sourceInfo = getSourceInfoErrorAddendumForProps(props);

        <span class="hljs-keyword">if</span> (sourceInfo) {
          info += sourceInfo;
        } <span class="hljs-keyword">else</span> {
          info += getDeclarationErrorAddendum();
        }

        <span class="hljs-keyword">var</span> typeString;

        <span class="hljs-keyword">if</span> (type === <span class="hljs-literal">null</span>) {
          typeString = <span class="hljs-string">'null'</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(type)) {
          typeString = <span class="hljs-string">'array'</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type !== <span class="hljs-literal">undefined</span> &amp;&amp; type.$$<span class="hljs-keyword">typeof</span> === REACT_ELEMENT_TYPE) {
          typeString = <span class="hljs-string">"&lt;"</span> + (getComponentName(type.type) || <span class="hljs-string">'Unknown'</span>) + <span class="hljs-string">" /&gt;"</span>;
          info = <span class="hljs-string">' Did you accidentally export a JSX literal instead of a component?'</span>;
        } <span class="hljs-keyword">else</span> {
          typeString = <span class="hljs-keyword">typeof</span> type;
        }

        {
          error(<span class="hljs-string">'React.createElement: type is invalid -- expected a string (for '</span> + <span class="hljs-string">'built-in components) or a class/function (for composite '</span> + <span class="hljs-string">'components) but got: %s.%s'</span>, typeString, info);
        }
      }

      <span class="hljs-keyword">var</span> element = createElement.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// The result can be nullish if a mock or a custom function is used.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-102" id="section-102"></a>
</div>
<p>TODO: Drop this when these are no longer allowed as the type argument.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (element == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> element;
      } <span class="hljs-comment">// Skip key warning if the type isn't valid since our key validation logic</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-103" id="section-103"></a>
</div>
<p>doesn't expect a non-string/function type and can throw confusing errors.
We don't want exception behavior to differ between dev and prod.
(Rendering will throw with a helpful message and as soon as the type is
fixed, the key warnings will appear.)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (validType) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
          validateChildKeys(<span class="hljs-built_in">arguments</span>[i], type);
        }
      }

      <span class="hljs-keyword">if</span> (type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } <span class="hljs-keyword">else</span> {
        validatePropTypes(element);
      }

      <span class="hljs-keyword">return</span> element;
    }

    <span class="hljs-keyword">var</span> didWarnAboutDeprecatedCreateFactory = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFactoryWithValidation</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">var</span> validatedFactory = createElementWithValidation.bind(<span class="hljs-literal">null</span>, type);
      validatedFactory.type = type;
      {
        <span class="hljs-keyword">if</span> (!didWarnAboutDeprecatedCreateFactory) {
          didWarnAboutDeprecatedCreateFactory = <span class="hljs-literal">true</span>;
          warn(<span class="hljs-string">'React.createFactory() is deprecated and will be removed in '</span> + <span class="hljs-string">'a future major release. Consider using JSX '</span> + <span class="hljs-string">'or use React.createElement() directly instead.'</span>);
        } <span class="hljs-comment">// Legacy hook: remove it</span>


        <span class="hljs-built_in">Object</span>.defineProperty(validatedFactory, <span class="hljs-string">'type'</span>, {
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            warn(<span class="hljs-string">'Factory.type is deprecated. Access the class directly '</span> + <span class="hljs-string">'before passing it to createFactory.'</span>);
            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">'type'</span>, {
              <span class="hljs-attr">value</span>: type
            });
            <span class="hljs-keyword">return</span> type;
          }
        });
      }
      <span class="hljs-keyword">return</span> validatedFactory;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneElementWithValidation</span>(<span class="hljs-params">element, props, children</span>) </span>{
      <span class="hljs-keyword">var</span> newElement = cloneElement.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
        validateChildKeys(<span class="hljs-built_in">arguments</span>[i], newElement.type);
      }

      validatePropTypes(newElement);
      <span class="hljs-keyword">return</span> newElement;
    }

    {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> frozenObject = <span class="hljs-built_in">Object</span>.freeze({});
        <span class="hljs-keyword">var</span> testMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[frozenObject, <span class="hljs-literal">null</span>]]);
        <span class="hljs-keyword">var</span> testSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([frozenObject]); <span class="hljs-comment">// This is necessary for Rollup to not consider these unused.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-104" id="section-104"></a>
</div>
<p>https://github.com/rollup/rollup/issues/1771
TODO: we can remove these if Rollup fixes the bug.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        testMap.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        testSet.add(<span class="hljs-number">0</span>);
      } <span class="hljs-keyword">catch</span> (e) {}
    }
    <span class="hljs-keyword">var</span> createElement$<span class="hljs-number">1</span> = createElementWithValidation;
    <span class="hljs-keyword">var</span> cloneElement$<span class="hljs-number">1</span> = cloneElementWithValidation;
    <span class="hljs-keyword">var</span> createFactory = createFactoryWithValidation;
    <span class="hljs-keyword">var</span> Children = {
      <span class="hljs-attr">map</span>: mapChildren,
      <span class="hljs-attr">forEach</span>: forEachChildren,
      <span class="hljs-attr">count</span>: countChildren,
      <span class="hljs-attr">toArray</span>: toArray,
      <span class="hljs-attr">only</span>: onlyChild
    };
    exports.Children = Children;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
    exports.cloneElement = cloneElement$<span class="hljs-number">1</span>;
    exports.createContext = createContext;
    exports.createElement = createElement$<span class="hljs-number">1</span>;
    exports.createFactory = createFactory;
    exports.createRef = createRef;
    exports.forwardRef = forwardRef;
    exports.isValidElement = isValidElement;
    exports.lazy = lazy;
    exports.memo = memo;
    exports.useCallback = useCallback;
    exports.useContext = useContext;
    exports.useDebugValue = useDebugValue;
    exports.useEffect = useEffect;
    exports.useImperativeHandle = useImperativeHandle;
    exports.useLayoutEffect = useLayoutEffect;
    exports.useMemo = useMemo;
    exports.useReducer = useReducer;
    exports.useRef = useRef;
    exports.useState = useState;
    exports.version = ReactVersion;
  })();
}
},{<span class="hljs-string">"object-assign"</span>:<span class="hljs-string">"../node_modules/object-assign/index.js"</span>,<span class="hljs-string">"prop-types/checkPropTypes"</span>:<span class="hljs-string">"../node_modules/prop-types/checkPropTypes.js"</span>}],<span class="hljs-string">"../node_modules/react/index.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
<span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> === <span class="hljs-string">'production'</span>) {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/react.production.min.js'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/react.development.js'</span>);
}
},{<span class="hljs-string">"./cjs/react.development.js"</span>:<span class="hljs-string">"../node_modules/react/cjs/react.development.js"</span>}],<span class="hljs-string">"../node_modules/scheduler/cjs/scheduler.development.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-105" id="section-105"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">"production"</span>) {
  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>;

    <span class="hljs-keyword">var</span> enableSchedulerDebugging = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> enableProfiling = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> requestHostCallback;
    <span class="hljs-keyword">var</span> requestHostTimeout;
    <span class="hljs-keyword">var</span> cancelHostTimeout;
    <span class="hljs-keyword">var</span> shouldYieldToHost;
    <span class="hljs-keyword">var</span> requestPaint;

    <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// If Scheduler runs in a non-DOM environment, it falls back to a naive</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-106" id="section-106"></a>
</div>
<p>implementation using setTimeout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">'undefined'</span> || <span class="hljs-comment">// Check if MessageChannel is supported, too.</span>
    <span class="hljs-keyword">typeof</span> MessageChannel !== <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-107" id="section-107"></a>
</div>
<p>If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
fallback to a naive implementation.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> _callback = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> _timeoutID = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">var</span> _flushCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (_callback !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> currentTime = exports.unstable_now();
            <span class="hljs-keyword">var</span> hasRemainingTime = <span class="hljs-literal">true</span>;

            _callback(hasRemainingTime, currentTime);

            _callback = <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">catch</span> (e) {
            setTimeout(_flushCallback, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">throw</span> e;
          }
        }
      };

      <span class="hljs-keyword">var</span> initialTime = <span class="hljs-built_in">Date</span>.now();

      exports.unstable_now = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now() - initialTime;
      };

      requestHostCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
        <span class="hljs-keyword">if</span> (_callback !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-108" id="section-108"></a>
</div>
<p>Protect against re-entrancy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          setTimeout(requestHostCallback, <span class="hljs-number">0</span>, cb);
        } <span class="hljs-keyword">else</span> {
          _callback = cb;
          setTimeout(_flushCallback, <span class="hljs-number">0</span>);
        }
      };

      requestHostTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb, ms</span>) </span>{
        _timeoutID = setTimeout(cb, ms);
      };

      cancelHostTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        clearTimeout(_timeoutID);
      };

      shouldYieldToHost = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      };

      requestPaint = exports.unstable_forceFrameRate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-109" id="section-109"></a>
</div>
<p>Capture local references to native APIs, in case a polyfill overrides them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> performance = <span class="hljs-built_in">window</span>.performance;
      <span class="hljs-keyword">var</span> _Date = <span class="hljs-built_in">window</span>.Date;
      <span class="hljs-keyword">var</span> _setTimeout = <span class="hljs-built_in">window</span>.setTimeout;
      <span class="hljs-keyword">var</span> _clearTimeout = <span class="hljs-built_in">window</span>.clearTimeout;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">'undefined'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-110" id="section-110"></a>
</div>
<p>TODO: Scheduler no longer requires these methods to be polyfilled. But
maybe we want to continue warning if they don't exist, to preserve the
option to rely on it in the future?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> requestAnimationFrame = <span class="hljs-built_in">window</span>.requestAnimationFrame;
        <span class="hljs-keyword">var</span> cancelAnimationFrame = <span class="hljs-built_in">window</span>.cancelAnimationFrame; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove fb.me link</span>

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> requestAnimationFrame !== <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-111" id="section-111"></a>
</div>
<p>Using console['error'] to evade Babel and ESLint</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-built_in">console</span>[<span class="hljs-string">'error'</span>](<span class="hljs-string">"This browser doesn't support requestAnimationFrame. "</span> + <span class="hljs-string">'Make sure that you load a '</span> + <span class="hljs-string">'polyfill in older browsers. https://fb.me/react-polyfills'</span>);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cancelAnimationFrame !== <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-112" id="section-112"></a>
</div>
<p>Using console['error'] to evade Babel and ESLint</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-built_in">console</span>[<span class="hljs-string">'error'</span>](<span class="hljs-string">"This browser doesn't support cancelAnimationFrame. "</span> + <span class="hljs-string">'Make sure that you load a '</span> + <span class="hljs-string">'polyfill in older browsers. https://fb.me/react-polyfills'</span>);
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> performance === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> performance.now === <span class="hljs-string">'function'</span>) {
        exports.unstable_now = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> performance.now();
        };
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> _initialTime = _Date.now();

        exports.unstable_now = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> _Date.now() - _initialTime;
        };
      }

      <span class="hljs-keyword">var</span> isMessageLoopRunning = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> scheduledHostCallback = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> taskTimeoutID = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Scheduler periodically yields in case there is other work on the main</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-113" id="section-113"></a>
</div>
<p>thread, like user events. By default, it yields multiple times per frame.
It does not attempt to align with frame boundaries, since most tasks don't
need to be frame aligned; for those that do, use requestAnimationFrame.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> yieldInterval = <span class="hljs-number">5</span>;
      <span class="hljs-keyword">var</span> deadline = <span class="hljs-number">0</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make this configurable</span>

      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-114" id="section-114"></a>
</div>
<p><code>isInputPending</code> is not available. Since we have no way of knowing if
there's pending input, always yield at the end of the frame.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        shouldYieldToHost = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> exports.unstable_now() &gt;= deadline;
        }; <span class="hljs-comment">// Since we yield every frame regardless, `requestPaint` has no effect.</span>


        requestPaint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
      }

      exports.unstable_forceFrameRate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fps</span>) </span>{
        <span class="hljs-keyword">if</span> (fps &lt; <span class="hljs-number">0</span> || fps &gt; <span class="hljs-number">125</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-115" id="section-115"></a>
</div>
<p>Using console['error'] to evade Babel and ESLint</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-built_in">console</span>[<span class="hljs-string">'error'</span>](<span class="hljs-string">'forceFrameRate takes a positive int between 0 and 125, '</span> + <span class="hljs-string">'forcing framerates higher than 125 fps is not unsupported'</span>);
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (fps &gt; <span class="hljs-number">0</span>) {
          yieldInterval = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">1000</span> / fps);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-116" id="section-116"></a>
</div>
<p>reset the framerate</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          yieldInterval = <span class="hljs-number">5</span>;
        }
      };

      <span class="hljs-keyword">var</span> performWorkUntilDeadline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (scheduledHostCallback !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> currentTime = exports.unstable_now(); <span class="hljs-comment">// Yield after `yieldInterval` ms, regardless of where we are in the vsync</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-117" id="section-117"></a>
</div>
<p>cycle. This means there's always time remaining at the beginning of
the message event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          deadline = currentTime + yieldInterval;
          <span class="hljs-keyword">var</span> hasTimeRemaining = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);

            <span class="hljs-keyword">if</span> (!hasMoreWork) {
              isMessageLoopRunning = <span class="hljs-literal">false</span>;
              scheduledHostCallback = <span class="hljs-literal">null</span>;
            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-118" id="section-118"></a>
</div>
<p>If there's more work, schedule the next message event at the end
of the preceding one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              port.postMessage(<span class="hljs-literal">null</span>);
            }
          } <span class="hljs-keyword">catch</span> (error) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-119" id="section-119"></a>
</div>
<p>If a scheduler task throws, exit the current browser task so the
error can be observed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            port.postMessage(<span class="hljs-literal">null</span>);
            <span class="hljs-keyword">throw</span> error;
          }
        } <span class="hljs-keyword">else</span> {
          isMessageLoopRunning = <span class="hljs-literal">false</span>;
        } <span class="hljs-comment">// Yielding to the browser will give it a chance to paint, so we can</span>

      };

      <span class="hljs-keyword">var</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
      <span class="hljs-keyword">var</span> port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;

      requestHostCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
        scheduledHostCallback = callback;

        <span class="hljs-keyword">if</span> (!isMessageLoopRunning) {
          isMessageLoopRunning = <span class="hljs-literal">true</span>;
          port.postMessage(<span class="hljs-literal">null</span>);
        }
      };

      requestHostTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, ms</span>) </span>{
        taskTimeoutID = _setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          callback(exports.unstable_now());
        }, ms);
      };

      cancelHostTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        _clearTimeout(taskTimeoutID);

        taskTimeoutID = <span class="hljs-number">-1</span>;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">heap, node</span>) </span>{
      <span class="hljs-keyword">var</span> index = heap.length;
      heap.push(node);
      siftUp(heap, node, index);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peek</span>(<span class="hljs-params">heap</span>) </span>{
      <span class="hljs-keyword">var</span> first = heap[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">return</span> first === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : first;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params">heap</span>) </span>{
      <span class="hljs-keyword">var</span> first = heap[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">if</span> (first !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> last = heap.pop();

        <span class="hljs-keyword">if</span> (last !== first) {
          heap[<span class="hljs-number">0</span>] = last;
          siftDown(heap, last, <span class="hljs-number">0</span>);
        }

        <span class="hljs-keyword">return</span> first;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftUp</span>(<span class="hljs-params">heap, node, i</span>) </span>{
      <span class="hljs-keyword">var</span> index = i;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> parentIndex = index - <span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> parent = heap[parentIndex];

        <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(parent, node) &gt; <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-120" id="section-120"></a>
</div>
<p>The parent is larger. Swap positions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          heap[parentIndex] = node;
          heap[index] = parent;
          index = parentIndex;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-121" id="section-121"></a>
</div>
<p>The parent is smaller. Exit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftDown</span>(<span class="hljs-params">heap, node, i</span>) </span>{
      <span class="hljs-keyword">var</span> index = i;
      <span class="hljs-keyword">var</span> length = heap.length;

      <span class="hljs-keyword">while</span> (index &lt; length) {
        <span class="hljs-keyword">var</span> leftIndex = (index + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> left = heap[leftIndex];
        <span class="hljs-keyword">var</span> rightIndex = leftIndex + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> right = heap[rightIndex]; <span class="hljs-comment">// If the left or right node is smaller, swap with the smaller of those.</span>

        <span class="hljs-keyword">if</span> (left !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(left, node) &lt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(right, left) &lt; <span class="hljs-number">0</span>) {
            heap[index] = right;
            heap[rightIndex] = node;
            index = rightIndex;
          } <span class="hljs-keyword">else</span> {
            heap[index] = left;
            heap[leftIndex] = node;
            index = leftIndex;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">undefined</span> &amp;&amp; compare(right, node) &lt; <span class="hljs-number">0</span>) {
          heap[index] = right;
          heap[rightIndex] = node;
          index = rightIndex;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-122" id="section-122"></a>
</div>
<p>Neither child is smaller. Exit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-123" id="section-123"></a>
</div>
<p>Compare sort index first, then task id.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> diff = a.sortIndex - b.sortIndex;
      <span class="hljs-keyword">return</span> diff !== <span class="hljs-number">0</span> ? diff : a.id - b.id;
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Use symbols?</span>


    <span class="hljs-keyword">var</span> NoPriority = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> ImmediatePriority = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> UserBlockingPriority = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> NormalPriority = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> LowPriority = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> IdlePriority = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">var</span> runIdCounter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> mainThreadIdCounter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> profilingStateSize = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> sharedProfilingBuffer = <span class="hljs-comment">// $FlowFixMe Flow doesn't know about SharedArrayBuffer</span>
    <span class="hljs-keyword">typeof</span> SharedArrayBuffer === <span class="hljs-string">'function'</span> ? <span class="hljs-keyword">new</span> SharedArrayBuffer(profilingStateSize * <span class="hljs-built_in">Int32Array</span>.BYTES_PER_ELEMENT) : <span class="hljs-comment">// $FlowFixMe Flow doesn't know about ArrayBuffer</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">ArrayBuffer</span> === <span class="hljs-string">'function'</span> ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(profilingStateSize * <span class="hljs-built_in">Int32Array</span>.BYTES_PER_ELEMENT) : <span class="hljs-literal">null</span> <span class="hljs-comment">// Don't crash the init path on IE9</span>
    ;
    <span class="hljs-keyword">var</span> profilingState = sharedProfilingBuffer !== <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(sharedProfilingBuffer) : []; <span class="hljs-comment">// We can't read this but it helps save bytes for null checks</span>

    <span class="hljs-keyword">var</span> PRIORITY = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> CURRENT_TASK_ID = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> CURRENT_RUN_ID = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> QUEUE_SIZE = <span class="hljs-number">3</span>;
    {
      profilingState[PRIORITY] = NoPriority; <span class="hljs-comment">// This is maintained with a counter, because the size of the priority queue</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-124" id="section-124"></a>
</div>
<p>array might include canceled tasks.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      profilingState[QUEUE_SIZE] = <span class="hljs-number">0</span>;
      profilingState[CURRENT_TASK_ID] = <span class="hljs-number">0</span>;
    } <span class="hljs-comment">// Bytes per element is 4</span>

    <span class="hljs-keyword">var</span> INITIAL_EVENT_LOG_SIZE = <span class="hljs-number">131072</span>;
    <span class="hljs-keyword">var</span> MAX_EVENT_LOG_SIZE = <span class="hljs-number">524288</span>; <span class="hljs-comment">// Equivalent to 2 megabytes</span>

    <span class="hljs-keyword">var</span> eventLogSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> eventLogBuffer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> eventLog = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> eventLogIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> TaskStartEvent = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> TaskCompleteEvent = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> TaskErrorEvent = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> TaskCancelEvent = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> TaskRunEvent = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">var</span> TaskYieldEvent = <span class="hljs-number">6</span>;
    <span class="hljs-keyword">var</span> SchedulerSuspendEvent = <span class="hljs-number">7</span>;
    <span class="hljs-keyword">var</span> SchedulerResumeEvent = <span class="hljs-number">8</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logEvent</span>(<span class="hljs-params">entries</span>) </span>{
      <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> offset = eventLogIndex;
        eventLogIndex += entries.length;

        <span class="hljs-keyword">if</span> (eventLogIndex + <span class="hljs-number">1</span> &gt; eventLogSize) {
          eventLogSize *= <span class="hljs-number">2</span>;

          <span class="hljs-keyword">if</span> (eventLogSize &gt; MAX_EVENT_LOG_SIZE) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-125" id="section-125"></a>
</div>
<p>Using console['error'] to evade Babel and ESLint</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-built_in">console</span>[<span class="hljs-string">'error'</span>](<span class="hljs-string">"Scheduler Profiling: Event log exceeded maximum size. Don't "</span> + <span class="hljs-string">'forget to call `stopLoggingProfilingEvents()`.'</span>);
            stopLoggingProfilingEvents();
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">var</span> newEventLog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(eventLogSize * <span class="hljs-number">4</span>);
          newEventLog.set(eventLog);
          eventLogBuffer = newEventLog.buffer;
          eventLog = newEventLog;
        }

        eventLog.set(entries, offset);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startLoggingProfilingEvents</span>(<span class="hljs-params"></span>) </span>{
      eventLogSize = INITIAL_EVENT_LOG_SIZE;
      eventLogBuffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(eventLogSize * <span class="hljs-number">4</span>);
      eventLog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(eventLogBuffer);
      eventLogIndex = <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopLoggingProfilingEvents</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> buffer = eventLogBuffer;
      eventLogSize = <span class="hljs-number">0</span>;
      eventLogBuffer = <span class="hljs-literal">null</span>;
      eventLog = <span class="hljs-literal">null</span>;
      eventLogIndex = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> buffer;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markTaskStart</span>(<span class="hljs-params">task, ms</span>) </span>{
      {
        profilingState[QUEUE_SIZE]++;

        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-126" id="section-126"></a>
</div>
<p>performance.now returns a float, representing milliseconds. When the
event is logged, it's coerced to an int. Convert to microseconds to
maintain extra degrees of precision.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          logEvent([TaskStartEvent, ms * <span class="hljs-number">1000</span>, task.id, task.priorityLevel]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markTaskCompleted</span>(<span class="hljs-params">task, ms</span>) </span>{
      {
        profilingState[PRIORITY] = NoPriority;
        profilingState[CURRENT_TASK_ID] = <span class="hljs-number">0</span>;
        profilingState[QUEUE_SIZE]--;

        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
          logEvent([TaskCompleteEvent, ms * <span class="hljs-number">1000</span>, task.id]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markTaskCanceled</span>(<span class="hljs-params">task, ms</span>) </span>{
      {
        profilingState[QUEUE_SIZE]--;

        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
          logEvent([TaskCancelEvent, ms * <span class="hljs-number">1000</span>, task.id]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markTaskErrored</span>(<span class="hljs-params">task, ms</span>) </span>{
      {
        profilingState[PRIORITY] = NoPriority;
        profilingState[CURRENT_TASK_ID] = <span class="hljs-number">0</span>;
        profilingState[QUEUE_SIZE]--;

        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
          logEvent([TaskErrorEvent, ms * <span class="hljs-number">1000</span>, task.id]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markTaskRun</span>(<span class="hljs-params">task, ms</span>) </span>{
      {
        runIdCounter++;
        profilingState[PRIORITY] = task.priorityLevel;
        profilingState[CURRENT_TASK_ID] = task.id;
        profilingState[CURRENT_RUN_ID] = runIdCounter;

        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
          logEvent([TaskRunEvent, ms * <span class="hljs-number">1000</span>, task.id, runIdCounter]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markTaskYield</span>(<span class="hljs-params">task, ms</span>) </span>{
      {
        profilingState[PRIORITY] = NoPriority;
        profilingState[CURRENT_TASK_ID] = <span class="hljs-number">0</span>;
        profilingState[CURRENT_RUN_ID] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
          logEvent([TaskYieldEvent, ms * <span class="hljs-number">1000</span>, task.id, runIdCounter]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markSchedulerSuspended</span>(<span class="hljs-params">ms</span>) </span>{
      {
        mainThreadIdCounter++;

        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
          logEvent([SchedulerSuspendEvent, ms * <span class="hljs-number">1000</span>, mainThreadIdCounter]);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markSchedulerUnsuspended</span>(<span class="hljs-params">ms</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (eventLog !== <span class="hljs-literal">null</span>) {
          logEvent([SchedulerResumeEvent, ms * <span class="hljs-number">1000</span>, mainThreadIdCounter]);
        }
      }
    }
    <span class="hljs-comment">/* eslint-disable no-var */</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-127" id="section-127"></a>
</div>
<p>Math.pow(2, 30) - 1
0b111111111111111111111111111111</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> maxSigned31BitInt = <span class="hljs-number">1073741823</span>; <span class="hljs-comment">// Times out immediately</span>

    <span class="hljs-keyword">var</span> IMMEDIATE_PRIORITY_TIMEOUT = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Eventually times out</span>

    <span class="hljs-keyword">var</span> USER_BLOCKING_PRIORITY = <span class="hljs-number">250</span>;
    <span class="hljs-keyword">var</span> NORMAL_PRIORITY_TIMEOUT = <span class="hljs-number">5000</span>;
    <span class="hljs-keyword">var</span> LOW_PRIORITY_TIMEOUT = <span class="hljs-number">10000</span>; <span class="hljs-comment">// Never times out</span>

    <span class="hljs-keyword">var</span> IDLE_PRIORITY = maxSigned31BitInt; <span class="hljs-comment">// Tasks are stored on a min heap</span>

    <span class="hljs-keyword">var</span> taskQueue = [];
    <span class="hljs-keyword">var</span> timerQueue = []; <span class="hljs-comment">// Incrementing id counter. Used to maintain insertion order.</span>

    <span class="hljs-keyword">var</span> taskIdCounter = <span class="hljs-number">1</span>; <span class="hljs-comment">// Pausing the scheduler is useful for debugging.</span>

    <span class="hljs-keyword">var</span> currentTask = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> currentPriorityLevel = NormalPriority; <span class="hljs-comment">// This is set while performing work, to prevent re-entrancy.</span>

    <span class="hljs-keyword">var</span> isPerformingWork = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> isHostCallbackScheduled = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> isHostTimeoutScheduled = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advanceTimers</span>(<span class="hljs-params">currentTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-128" id="section-128"></a>
</div>
<p>Check for tasks that are no longer delayed and add them to the queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> timer = peek(timerQueue);

      <span class="hljs-keyword">while</span> (timer !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (timer.callback === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-129" id="section-129"></a>
</div>
<p>Timer was cancelled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          pop(timerQueue);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timer.startTime &lt;= currentTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-130" id="section-130"></a>
</div>
<p>Timer fired. Transfer to the task queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          pop(timerQueue);
          timer.sortIndex = timer.expirationTime;
          push(taskQueue, timer);
          {
            markTaskStart(timer, currentTime);
            timer.isQueued = <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-131" id="section-131"></a>
</div>
<p>Remaining timers are pending.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        }

        timer = peek(timerQueue);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleTimeout</span>(<span class="hljs-params">currentTime</span>) </span>{
      isHostTimeoutScheduled = <span class="hljs-literal">false</span>;
      advanceTimers(currentTime);

      <span class="hljs-keyword">if</span> (!isHostCallbackScheduled) {
        <span class="hljs-keyword">if</span> (peek(taskQueue) !== <span class="hljs-literal">null</span>) {
          isHostCallbackScheduled = <span class="hljs-literal">true</span>;
          requestHostCallback(flushWork);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> firstTimer = peek(timerQueue);

          <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) {
            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushWork</span>(<span class="hljs-params">hasTimeRemaining, initialTime</span>) </span>{
      {
        markSchedulerUnsuspended(initialTime);
      } <span class="hljs-comment">// We'll need a host callback the next time work is scheduled.</span>

      isHostCallbackScheduled = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (isHostTimeoutScheduled) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-132" id="section-132"></a>
</div>
<p>We scheduled a timeout but it's no longer needed. Cancel it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        isHostTimeoutScheduled = <span class="hljs-literal">false</span>;
        cancelHostTimeout();
      }

      isPerformingWork = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> previousPriorityLevel = currentPriorityLevel;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (enableProfiling) {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> workLoop(hasTimeRemaining, initialTime);
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> currentTime = exports.unstable_now();
              markTaskErrored(currentTask, currentTime);
              currentTask.isQueued = <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">throw</span> error;
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-133" id="section-133"></a>
</div>
<p>No catch in prod codepath.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> workLoop(hasTimeRemaining, initialTime);
        }
      } <span class="hljs-keyword">finally</span> {
        currentTask = <span class="hljs-literal">null</span>;
        currentPriorityLevel = previousPriorityLevel;
        isPerformingWork = <span class="hljs-literal">false</span>;
        {
          <span class="hljs-keyword">var</span> _currentTime = exports.unstable_now();

          markSchedulerSuspended(_currentTime);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoop</span>(<span class="hljs-params">hasTimeRemaining, initialTime</span>) </span>{
      <span class="hljs-keyword">var</span> currentTime = initialTime;
      advanceTimers(currentTime);
      currentTask = peek(taskQueue);

      <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span> &amp;&amp; !enableSchedulerDebugging) {
        <span class="hljs-keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost())) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-134" id="section-134"></a>
</div>
<p>This currentTask hasn't expired, and we've reached the deadline.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> callback = currentTask.callback;

        <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
          currentTask.callback = <span class="hljs-literal">null</span>;
          currentPriorityLevel = currentTask.priorityLevel;
          <span class="hljs-keyword">var</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
          markTaskRun(currentTask, currentTime);
          <span class="hljs-keyword">var</span> continuationCallback = callback(didUserCallbackTimeout);
          currentTime = exports.unstable_now();

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> continuationCallback === <span class="hljs-string">'function'</span>) {
            currentTask.callback = continuationCallback;
            markTaskYield(currentTask, currentTime);
          } <span class="hljs-keyword">else</span> {
            {
              markTaskCompleted(currentTask, currentTime);
              currentTask.isQueued = <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">if</span> (currentTask === peek(taskQueue)) {
              pop(taskQueue);
            }
          }

          advanceTimers(currentTime);
        } <span class="hljs-keyword">else</span> {
          pop(taskQueue);
        }

        currentTask = peek(taskQueue);
      } <span class="hljs-comment">// Return whether there's additional work</span>


      <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> firstTimer = peek(timerQueue);

        <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) {
          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_runWithPriority</span>(<span class="hljs-params">priorityLevel, eventHandler</span>) </span>{
      <span class="hljs-keyword">switch</span> (priorityLevel) {
        <span class="hljs-keyword">case</span> ImmediatePriority:
        <span class="hljs-keyword">case</span> UserBlockingPriority:
        <span class="hljs-keyword">case</span> NormalPriority:
        <span class="hljs-keyword">case</span> LowPriority:
        <span class="hljs-keyword">case</span> IdlePriority:
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          priorityLevel = NormalPriority;
      }

      <span class="hljs-keyword">var</span> previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> eventHandler();
      } <span class="hljs-keyword">finally</span> {
        currentPriorityLevel = previousPriorityLevel;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_next</span>(<span class="hljs-params">eventHandler</span>) </span>{
      <span class="hljs-keyword">var</span> priorityLevel;

      <span class="hljs-keyword">switch</span> (currentPriorityLevel) {
        <span class="hljs-keyword">case</span> ImmediatePriority:
        <span class="hljs-keyword">case</span> UserBlockingPriority:
        <span class="hljs-keyword">case</span> NormalPriority:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-135" id="section-135"></a>
</div>
<p>Shift down to normal priority</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          priorityLevel = NormalPriority;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-136" id="section-136"></a>
</div>
<p>Anything lower than normal priority should remain at the current level.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          priorityLevel = currentPriorityLevel;
          <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">var</span> previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> eventHandler();
      } <span class="hljs-keyword">finally</span> {
        currentPriorityLevel = previousPriorityLevel;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_wrapCallback</span>(<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-keyword">var</span> parentPriorityLevel = currentPriorityLevel;
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-137" id="section-137"></a>
</div>
<p>This is a fork of runWithPriority, inlined for performance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> callback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        } <span class="hljs-keyword">finally</span> {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeoutForPriorityLevel</span>(<span class="hljs-params">priorityLevel</span>) </span>{
      <span class="hljs-keyword">switch</span> (priorityLevel) {
        <span class="hljs-keyword">case</span> ImmediatePriority:
          <span class="hljs-keyword">return</span> IMMEDIATE_PRIORITY_TIMEOUT;

        <span class="hljs-keyword">case</span> UserBlockingPriority:
          <span class="hljs-keyword">return</span> USER_BLOCKING_PRIORITY;

        <span class="hljs-keyword">case</span> IdlePriority:
          <span class="hljs-keyword">return</span> IDLE_PRIORITY;

        <span class="hljs-keyword">case</span> LowPriority:
          <span class="hljs-keyword">return</span> LOW_PRIORITY_TIMEOUT;

        <span class="hljs-keyword">case</span> NormalPriority:
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> NORMAL_PRIORITY_TIMEOUT;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_scheduleCallback</span>(<span class="hljs-params">priorityLevel, callback, options</span>) </span>{
      <span class="hljs-keyword">var</span> currentTime = exports.unstable_now();
      <span class="hljs-keyword">var</span> startTime;
      <span class="hljs-keyword">var</span> timeout;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'object'</span> &amp;&amp; options !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> delay = options.delay;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> delay === <span class="hljs-string">'number'</span> &amp;&amp; delay &gt; <span class="hljs-number">0</span>) {
          startTime = currentTime + delay;
        } <span class="hljs-keyword">else</span> {
          startTime = currentTime;
        }

        timeout = <span class="hljs-keyword">typeof</span> options.timeout === <span class="hljs-string">'number'</span> ? options.timeout : timeoutForPriorityLevel(priorityLevel);
      } <span class="hljs-keyword">else</span> {
        timeout = timeoutForPriorityLevel(priorityLevel);
        startTime = currentTime;
      }

      <span class="hljs-keyword">var</span> expirationTime = startTime + timeout;
      <span class="hljs-keyword">var</span> newTask = {
        <span class="hljs-attr">id</span>: taskIdCounter++,
        <span class="hljs-attr">callback</span>: callback,
        <span class="hljs-attr">priorityLevel</span>: priorityLevel,
        <span class="hljs-attr">startTime</span>: startTime,
        <span class="hljs-attr">expirationTime</span>: expirationTime,
        <span class="hljs-attr">sortIndex</span>: <span class="hljs-number">-1</span>
      };
      {
        newTask.isQueued = <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (startTime &gt; currentTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-138" id="section-138"></a>
</div>
<p>This is a delayed task.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        newTask.sortIndex = startTime;
        push(timerQueue, newTask);

        <span class="hljs-keyword">if</span> (peek(taskQueue) === <span class="hljs-literal">null</span> &amp;&amp; newTask === peek(timerQueue)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-139" id="section-139"></a>
</div>
<p>All tasks are delayed, and this is the task with the earliest delay.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (isHostTimeoutScheduled) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-140" id="section-140"></a>
</div>
<p>Cancel an existing timeout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            cancelHostTimeout();
          } <span class="hljs-keyword">else</span> {
            isHostTimeoutScheduled = <span class="hljs-literal">true</span>;
          } <span class="hljs-comment">// Schedule a timeout.</span>


          requestHostTimeout(handleTimeout, startTime - currentTime);
        }
      } <span class="hljs-keyword">else</span> {
        newTask.sortIndex = expirationTime;
        push(taskQueue, newTask);
        {
          markTaskStart(newTask, currentTime);
          newTask.isQueued = <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// Schedule a host callback, if needed. If we're already performing work,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-141" id="section-141"></a>
</div>
<p>wait until the next time we yield.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
          isHostCallbackScheduled = <span class="hljs-literal">true</span>;
          requestHostCallback(flushWork);
        }
      }

      <span class="hljs-keyword">return</span> newTask;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_pauseExecution</span>(<span class="hljs-params"></span>) </span>{}

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_continueExecution</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
        isHostCallbackScheduled = <span class="hljs-literal">true</span>;
        requestHostCallback(flushWork);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_getFirstCallbackNode</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> peek(taskQueue);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_cancelCallback</span>(<span class="hljs-params">task</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (task.isQueued) {
          <span class="hljs-keyword">var</span> currentTime = exports.unstable_now();
          markTaskCanceled(task, currentTime);
          task.isQueued = <span class="hljs-literal">false</span>;
        }
      } <span class="hljs-comment">// Null out the callback to indicate the task has been canceled. (Can't</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-142" id="section-142"></a>
</div>
<p>remove from the queue because you can't remove arbitrary nodes from an
array based heap, only the first one.)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      task.callback = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_getCurrentPriorityLevel</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> currentPriorityLevel;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_shouldYield</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> currentTime = exports.unstable_now();
      advanceTimers(currentTime);
      <span class="hljs-keyword">var</span> firstTask = peek(taskQueue);
      <span class="hljs-keyword">return</span> firstTask !== currentTask &amp;&amp; currentTask !== <span class="hljs-literal">null</span> &amp;&amp; firstTask !== <span class="hljs-literal">null</span> &amp;&amp; firstTask.callback !== <span class="hljs-literal">null</span> &amp;&amp; firstTask.startTime &lt;= currentTime &amp;&amp; firstTask.expirationTime &lt; currentTask.expirationTime || shouldYieldToHost();
    }

    <span class="hljs-keyword">var</span> unstable_requestPaint = requestPaint;
    <span class="hljs-keyword">var</span> unstable_Profiling = {
      <span class="hljs-attr">startLoggingProfilingEvents</span>: startLoggingProfilingEvents,
      <span class="hljs-attr">stopLoggingProfilingEvents</span>: stopLoggingProfilingEvents,
      <span class="hljs-attr">sharedProfilingBuffer</span>: sharedProfilingBuffer
    };
    exports.unstable_IdlePriority = IdlePriority;
    exports.unstable_ImmediatePriority = ImmediatePriority;
    exports.unstable_LowPriority = LowPriority;
    exports.unstable_NormalPriority = NormalPriority;
    exports.unstable_Profiling = unstable_Profiling;
    exports.unstable_UserBlockingPriority = UserBlockingPriority;
    exports.unstable_cancelCallback = unstable_cancelCallback;
    exports.unstable_continueExecution = unstable_continueExecution;
    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
    exports.unstable_next = unstable_next;
    exports.unstable_pauseExecution = unstable_pauseExecution;
    exports.unstable_requestPaint = unstable_requestPaint;
    exports.unstable_runWithPriority = unstable_runWithPriority;
    exports.unstable_scheduleCallback = unstable_scheduleCallback;
    exports.unstable_shouldYield = unstable_shouldYield;
    exports.unstable_wrapCallback = unstable_wrapCallback;
  })();
}
},{}],<span class="hljs-string">"../node_modules/scheduler/index.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
<span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> === <span class="hljs-string">'production'</span>) {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/scheduler.production.min.js'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/scheduler.development.js'</span>);
}
},{<span class="hljs-string">"./cjs/scheduler.development.js"</span>:<span class="hljs-string">"../node_modules/scheduler/cjs/scheduler.development.js"</span>}],<span class="hljs-string">"../node_modules/scheduler/cjs/scheduler-tracing.development.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-143" id="section-143"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">"production"</span>) {
  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>;

    <span class="hljs-keyword">var</span> DEFAULT_THREAD_ID = <span class="hljs-number">0</span>; <span class="hljs-comment">// Counters used to generate unique IDs.</span>

    <span class="hljs-keyword">var</span> interactionIDCounter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> threadIDCounter = <span class="hljs-number">0</span>; <span class="hljs-comment">// Set of currently traced interactions.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-144" id="section-144"></a>
</div>
<p>Interactions &quot;stack&quot;–
Meaning that newly traced interactions are appended to the previously active set.
When an interaction goes out of scope, the previous set (if any) is restored.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    exports.__interactionsRef = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Listener(s) to notify when interactions begin and end.</span>

    exports.__subscriberRef = <span class="hljs-literal">null</span>;
    {
      exports.__interactionsRef = {
        <span class="hljs-attr">current</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
      };
      exports.__subscriberRef = {
        <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_clear</span>(<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-keyword">var</span> prevInteractions = exports.__interactionsRef.current;
      exports.__interactionsRef.current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> callback();
      } <span class="hljs-keyword">finally</span> {
        exports.__interactionsRef.current = prevInteractions;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_getCurrent</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">return</span> exports.__interactionsRef.current;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_getThreadID</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> ++threadIDCounter;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_trace</span>(<span class="hljs-params">name, timestamp, callback</span>) </span>{
      <span class="hljs-keyword">var</span> threadID = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] : DEFAULT_THREAD_ID;
      <span class="hljs-keyword">var</span> interaction = {
        <span class="hljs-attr">__count</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">id</span>: interactionIDCounter++,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">timestamp</span>: timestamp
      };
      <span class="hljs-keyword">var</span> prevInteractions = exports.__interactionsRef.current; <span class="hljs-comment">// Traced interactions should stack/accumulate.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-145" id="section-145"></a>
</div>
<p>To do that, clone the current interactions.
The previous set will be restored upon completion.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> interactions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(prevInteractions);
      interactions.add(interaction);
      exports.__interactionsRef.current = interactions;
      <span class="hljs-keyword">var</span> subscriber = exports.__subscriberRef.current;
      <span class="hljs-keyword">var</span> returnValue;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
          subscriber.onInteractionTraced(interaction);
        }
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
            subscriber.onWorkStarted(interactions, threadID);
          }
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-keyword">try</span> {
            returnValue = callback();
          } <span class="hljs-keyword">finally</span> {
            exports.__interactionsRef.current = prevInteractions;

            <span class="hljs-keyword">try</span> {
              <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
                subscriber.onWorkStopped(interactions, threadID);
              }
            } <span class="hljs-keyword">finally</span> {
              interaction.__count--; <span class="hljs-comment">// If no async work was scheduled for this interaction,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-146" id="section-146"></a>
</div>
<p>Notify subscribers that it's completed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span> &amp;&amp; interaction.__count === <span class="hljs-number">0</span>) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> returnValue;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_wrap</span>(<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-keyword">var</span> threadID = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] : DEFAULT_THREAD_ID;
      <span class="hljs-keyword">var</span> wrappedInteractions = exports.__interactionsRef.current;
      <span class="hljs-keyword">var</span> subscriber = exports.__subscriberRef.current;

      <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
        subscriber.onWorkScheduled(wrappedInteractions, threadID);
      } <span class="hljs-comment">// Update the pending async work count for the current interactions.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-147" id="section-147"></a>
</div>
<p>Update after calling subscribers in case of error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      wrappedInteractions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) </span>{
        interaction.__count++;
      });
      <span class="hljs-keyword">var</span> hasRun = <span class="hljs-literal">false</span>;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapped</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = wrappedInteractions;
        subscriber = exports.__subscriberRef.current;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> returnValue;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
              subscriber.onWorkStarted(wrappedInteractions, threadID);
            }
          } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
              returnValue = callback.apply(<span class="hljs-literal">undefined</span>, <span class="hljs-built_in">arguments</span>);
            } <span class="hljs-keyword">finally</span> {
              exports.__interactionsRef.current = prevInteractions;

              <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
                subscriber.onWorkStopped(wrappedInteractions, threadID);
              }
            }
          }

          <span class="hljs-keyword">return</span> returnValue;
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-keyword">if</span> (!hasRun) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-148" id="section-148"></a>
</div>
<p>We only expect a wrapped function to be executed once,
But in the event that it's executed more than once–
Only decrement the outstanding interaction counts once.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            hasRun = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Update pending async counts for all wrapped interactions.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-149" id="section-149"></a>
</div>
<p>If this was the last scheduled async work for any of them,
Mark them as completed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            wrappedInteractions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) </span>{
              interaction.__count--;

              <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span> &amp;&amp; interaction.__count === <span class="hljs-number">0</span>) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            });
          }
        }
      }

      wrapped.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancel</span>(<span class="hljs-params"></span>) </span>{
        subscriber = exports.__subscriberRef.current;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
            subscriber.onWorkCanceled(wrappedInteractions, threadID);
          }
        } <span class="hljs-keyword">finally</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-150" id="section-150"></a>
</div>
<p>Update pending async counts for all wrapped interactions.
If this was the last scheduled async work for any of them,
Mark them as completed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          wrappedInteractions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) </span>{
            interaction.__count--;

            <span class="hljs-keyword">if</span> (subscriber &amp;&amp; interaction.__count === <span class="hljs-number">0</span>) {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            }
          });
        }
      };

      <span class="hljs-keyword">return</span> wrapped;
    }

    <span class="hljs-keyword">var</span> subscribers = <span class="hljs-literal">null</span>;
    {
      subscribers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_subscribe</span>(<span class="hljs-params">subscriber</span>) </span>{
      {
        subscribers.add(subscriber);

        <span class="hljs-keyword">if</span> (subscribers.size === <span class="hljs-number">1</span>) {
          exports.__subscriberRef.current = {
            <span class="hljs-attr">onInteractionScheduledWorkCompleted</span>: onInteractionScheduledWorkCompleted,
            <span class="hljs-attr">onInteractionTraced</span>: onInteractionTraced,
            <span class="hljs-attr">onWorkCanceled</span>: onWorkCanceled,
            <span class="hljs-attr">onWorkScheduled</span>: onWorkScheduled,
            <span class="hljs-attr">onWorkStarted</span>: onWorkStarted,
            <span class="hljs-attr">onWorkStopped</span>: onWorkStopped
          };
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_unsubscribe</span>(<span class="hljs-params">subscriber</span>) </span>{
      {
        subscribers.delete(subscriber);

        <span class="hljs-keyword">if</span> (subscribers.size === <span class="hljs-number">0</span>) {
          exports.__subscriberRef.current = <span class="hljs-literal">null</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onInteractionTraced</span>(<span class="hljs-params">interaction</span>) </span>{
      <span class="hljs-keyword">var</span> didCatchError = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>;
      subscribers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscriber</span>) </span>{
        <span class="hljs-keyword">try</span> {
          subscriber.onInteractionTraced(interaction);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (!didCatchError) {
            didCatchError = <span class="hljs-literal">true</span>;
            caughtError = error;
          }
        }
      });

      <span class="hljs-keyword">if</span> (didCatchError) {
        <span class="hljs-keyword">throw</span> caughtError;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onInteractionScheduledWorkCompleted</span>(<span class="hljs-params">interaction</span>) </span>{
      <span class="hljs-keyword">var</span> didCatchError = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>;
      subscribers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscriber</span>) </span>{
        <span class="hljs-keyword">try</span> {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (!didCatchError) {
            didCatchError = <span class="hljs-literal">true</span>;
            caughtError = error;
          }
        }
      });

      <span class="hljs-keyword">if</span> (didCatchError) {
        <span class="hljs-keyword">throw</span> caughtError;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onWorkScheduled</span>(<span class="hljs-params">interactions, threadID</span>) </span>{
      <span class="hljs-keyword">var</span> didCatchError = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>;
      subscribers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscriber</span>) </span>{
        <span class="hljs-keyword">try</span> {
          subscriber.onWorkScheduled(interactions, threadID);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (!didCatchError) {
            didCatchError = <span class="hljs-literal">true</span>;
            caughtError = error;
          }
        }
      });

      <span class="hljs-keyword">if</span> (didCatchError) {
        <span class="hljs-keyword">throw</span> caughtError;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onWorkStarted</span>(<span class="hljs-params">interactions, threadID</span>) </span>{
      <span class="hljs-keyword">var</span> didCatchError = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>;
      subscribers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscriber</span>) </span>{
        <span class="hljs-keyword">try</span> {
          subscriber.onWorkStarted(interactions, threadID);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (!didCatchError) {
            didCatchError = <span class="hljs-literal">true</span>;
            caughtError = error;
          }
        }
      });

      <span class="hljs-keyword">if</span> (didCatchError) {
        <span class="hljs-keyword">throw</span> caughtError;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onWorkStopped</span>(<span class="hljs-params">interactions, threadID</span>) </span>{
      <span class="hljs-keyword">var</span> didCatchError = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>;
      subscribers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscriber</span>) </span>{
        <span class="hljs-keyword">try</span> {
          subscriber.onWorkStopped(interactions, threadID);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (!didCatchError) {
            didCatchError = <span class="hljs-literal">true</span>;
            caughtError = error;
          }
        }
      });

      <span class="hljs-keyword">if</span> (didCatchError) {
        <span class="hljs-keyword">throw</span> caughtError;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onWorkCanceled</span>(<span class="hljs-params">interactions, threadID</span>) </span>{
      <span class="hljs-keyword">var</span> didCatchError = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>;
      subscribers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscriber</span>) </span>{
        <span class="hljs-keyword">try</span> {
          subscriber.onWorkCanceled(interactions, threadID);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (!didCatchError) {
            didCatchError = <span class="hljs-literal">true</span>;
            caughtError = error;
          }
        }
      });

      <span class="hljs-keyword">if</span> (didCatchError) {
        <span class="hljs-keyword">throw</span> caughtError;
      }
    }

    exports.unstable_clear = unstable_clear;
    exports.unstable_getCurrent = unstable_getCurrent;
    exports.unstable_getThreadID = unstable_getThreadID;
    exports.unstable_subscribe = unstable_subscribe;
    exports.unstable_trace = unstable_trace;
    exports.unstable_unsubscribe = unstable_unsubscribe;
    exports.unstable_wrap = unstable_wrap;
  })();
}
},{}],<span class="hljs-string">"../node_modules/scheduler/tracing.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
<span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> === <span class="hljs-string">'production'</span>) {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/scheduler-tracing.production.min.js'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/scheduler-tracing.development.js'</span>);
}
},{<span class="hljs-string">"./cjs/scheduler-tracing.development.js"</span>:<span class="hljs-string">"../node_modules/scheduler/cjs/scheduler-tracing.development.js"</span>}],<span class="hljs-string">"../node_modules/react-dom/cjs/react-dom.development.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-151" id="section-151"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">"production"</span>) {
  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>;

    <span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);

    <span class="hljs-keyword">var</span> _assign = <span class="hljs-built_in">require</span>(<span class="hljs-string">'object-assign'</span>);

    <span class="hljs-keyword">var</span> Scheduler = <span class="hljs-built_in">require</span>(<span class="hljs-string">'scheduler'</span>);

    <span class="hljs-keyword">var</span> checkPropTypes = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prop-types/checkPropTypes'</span>);

    <span class="hljs-keyword">var</span> tracing = <span class="hljs-built_in">require</span>(<span class="hljs-string">'scheduler/tracing'</span>);

    <span class="hljs-keyword">var</span> ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; <span class="hljs-comment">// Prevent newer renderers from RTE when used with older react package versions.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-152" id="section-152"></a>
</div>
<p>Current owner and dispatcher used to share the same ref,
but PR #14548 split them out to better support the react-debug-tools package.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">if</span> (!ReactSharedInternals.hasOwnProperty(<span class="hljs-string">'ReactCurrentDispatcher'</span>)) {
      ReactSharedInternals.ReactCurrentDispatcher = {
        <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>
      };
    }

    <span class="hljs-keyword">if</span> (!ReactSharedInternals.hasOwnProperty(<span class="hljs-string">'ReactCurrentBatchConfig'</span>)) {
      ReactSharedInternals.ReactCurrentBatchConfig = {
        <span class="hljs-attr">suspense</span>: <span class="hljs-literal">null</span>
      };
    } <span class="hljs-comment">// by calls to these methods by a Babel plugin.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-153" id="section-153"></a>
</div>
<p>In PROD (or in packages without access to React internals),
they are left as they are instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warn</span>(<span class="hljs-params">format</span>) </span>{
      {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len &gt; <span class="hljs-number">1</span> ? _len - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), _key = <span class="hljs-number">1</span>; _key &lt; _len; _key++) {
          args[_key - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[_key];
        }

        printWarning(<span class="hljs-string">'warn'</span>, format, args);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span>(<span class="hljs-params">format</span>) </span>{
      {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len2 = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len2 &gt; <span class="hljs-number">1</span> ? _len2 - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), _key2 = <span class="hljs-number">1</span>; _key2 &lt; _len2; _key2++) {
          args[_key2 - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[_key2];
        }

        printWarning(<span class="hljs-string">'error'</span>, format, args);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printWarning</span>(<span class="hljs-params">level, format, args</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-154" id="section-154"></a>
</div>
<p>When changing this logic, you might want to also
update consoleWithStackDev.www.js as well.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      {
        <span class="hljs-keyword">var</span> hasExistingStack = args.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args[args.length - <span class="hljs-number">1</span>] === <span class="hljs-string">'string'</span> &amp;&amp; args[args.length - <span class="hljs-number">1</span>].indexOf(<span class="hljs-string">'\n    in'</span>) === <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (!hasExistingStack) {
          <span class="hljs-keyword">var</span> ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          <span class="hljs-keyword">var</span> stack = ReactDebugCurrentFrame.getStackAddendum();

          <span class="hljs-keyword">if</span> (stack !== <span class="hljs-string">''</span>) {
            format += <span class="hljs-string">'%s'</span>;
            args = args.concat([stack]);
          }
        }

        <span class="hljs-keyword">var</span> argsWithFormat = args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + item;
        }); <span class="hljs-comment">// Careful: RN currently depends on this prefix</span>

        argsWithFormat.unshift(<span class="hljs-string">'Warning: '</span> + format); <span class="hljs-comment">// We intentionally don't use spread (or .apply) directly because it</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-155" id="section-155"></a>
</div>
<p>breaks IE9: https://github.com/facebook/react/issues/13610
eslint-disable-next-line react-internal/no-production-logging</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-built_in">Function</span>.prototype.apply.call(<span class="hljs-built_in">console</span>[level], <span class="hljs-built_in">console</span>, argsWithFormat);

        <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-156" id="section-156"></a>
</div>
<p>--- Welcome to debugging React ---
This error was thrown as a convenience so that you can use this stack
to find the callsite that caused this warning to fire.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> argIndex = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> message = <span class="hljs-string">'Warning: '</span> + format.replace(<span class="hljs-regexp">/%s/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> args[argIndex++];
          });
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
        } <span class="hljs-keyword">catch</span> (x) {}
      }
    }

    <span class="hljs-keyword">if</span> (!React) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM."</span>);
      }
    }

    <span class="hljs-keyword">var</span> invokeGuardedCallbackImpl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) </span>{
      <span class="hljs-keyword">var</span> funcArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">3</span>);

      <span class="hljs-keyword">try</span> {
        func.apply(context, funcArgs);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">this</span>.onError(error);
      }
    };

    {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-157" id="section-157"></a>
</div>
<p>In DEV mode, we swap out invokeGuardedCallback for a special version
that plays more nicely with the browser's DevTools. The idea is to preserve
&quot;Pause on exceptions&quot; behavior. Because React wraps all user-provided
functions in invokeGuardedCallback, and the production version of
invokeGuardedCallback uses a try-catch, all user exceptions are treated
like caught exceptions, and the DevTools won't pause unless the developer
takes the extra step of enabling pause on caught exceptions. This is
unintuitive, though, because even though React has caught the error, from
the developer's perspective, the error is uncaught.</p>
<p>To preserve the expected &quot;Pause on exceptions&quot; behavior, we don't use a
try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
DOM node, and call the user-provided callback from inside an event handler
for that fake event. If the callback throws, the error is &quot;captured&quot; using
a global event handler. But because the error happens in a different
event loop context, it does not interrupt the normal program flow.
Effectively, this gives us try-catch behavior without actually using
try-catch. Neat!
Check that the browser supports the APIs we need to implement our special
DEV version of invokeGuardedCallback</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.dispatchEvent === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">document</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">document</span>.createEvent === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">var</span> fakeNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'react'</span>);

        <span class="hljs-keyword">var</span> invokeGuardedCallbackDev = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-158" id="section-158"></a>
</div>
<p>If document doesn't exist we know for sure we will crash in this method
when we call document.createEvent(). However this can cause confusing
errors: https://github.com/facebookincubator/create-react-app/issues/3482
So we preemptively throw with a better message instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">document</span> !== <span class="hljs-string">'undefined'</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous."</span>);
            }
          }

          <span class="hljs-keyword">var</span> evt = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">'Event'</span>); <span class="hljs-comment">// Keeps track of whether the user-provided callback threw an error. We</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-159" id="section-159"></a>
</div>
<p>set this to true at the beginning, then set it to false right after
calling the function. If the function errors, <code>didError</code> will never be
set to false. This strategy works even if the browser is flaky and
fails to call our global error handler, because it doesn't rely on
the error event at all.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">var</span> didError = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Keeps track of the value of window.event so that we can reset it</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-160" id="section-160"></a>
</div>
<p>during the callback to let user code access window.event in the
browsers that support it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">var</span> windowEvent = <span class="hljs-built_in">window</span>.event; <span class="hljs-comment">// Keeps track of the descriptor of window.event to restore it after event</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-161" id="section-161"></a>
</div>
<p>dispatching: https://github.com/facebook/react/issues/13688</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">var</span> windowEventDescriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">window</span>, <span class="hljs-string">'event'</span>); <span class="hljs-comment">// Create an event handler for our fake event. We will synchronously</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-162" id="section-162"></a>
</div>
<p>dispatch our fake event using <code>dispatchEvent</code>. Inside the handler, we
call the user-provided callback.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">var</span> funcArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">3</span>);

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callCallback</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-163" id="section-163"></a>
</div>
<p>We immediately remove the callback from event listeners so that
nested <code>invokeGuardedCallback</code> calls do not clash. Otherwise, a
nested call would trigger the fake event handlers of any call higher
in the stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            fakeNode.removeEventListener(evtType, callCallback, <span class="hljs-literal">false</span>); <span class="hljs-comment">// We check for window.hasOwnProperty('event') to prevent the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-164" id="section-164"></a>
</div>
<p>window.event assignment in both IE &lt;= 10 as they throw an error
&quot;Member not found&quot; in strict mode, and in Firefox which does not
support window.event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.event !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">window</span>.hasOwnProperty(<span class="hljs-string">'event'</span>)) {
              <span class="hljs-built_in">window</span>.event = windowEvent;
            }

            func.apply(context, funcArgs);
            didError = <span class="hljs-literal">false</span>;
          } <span class="hljs-comment">// Create a global error event handler. We use this to capture the value</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-165" id="section-165"></a>
</div>
<p>that was thrown. It's possible that this error handler will fire more
than once; for example, if non-React code also calls <code>dispatchEvent</code>
and a handler for that event throws. We should be resilient to most of
those cases. Even if our error event handler fires more than once, the
last error event is always used. If the callback actually does error,
we know that the last error event is the correct one, because it's not
possible for anything else to have happened in between our callback
erroring and the code that follows the <code>dispatchEvent</code> call below. If
the callback doesn't error, but the error event was fired, we know to
ignore it because <code>didError</code> will be false, as described above.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          <span class="hljs-keyword">var</span> error; <span class="hljs-comment">// Use this to track whether the error event is ever called.</span>

          <span class="hljs-keyword">var</span> didSetError = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">var</span> isCrossOriginError = <span class="hljs-literal">false</span>;

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleWindowError</span>(<span class="hljs-params">event</span>) </span>{
            error = event.error;
            didSetError = <span class="hljs-literal">true</span>;

            <span class="hljs-keyword">if</span> (error === <span class="hljs-literal">null</span> &amp;&amp; event.colno === <span class="hljs-number">0</span> &amp;&amp; event.lineno === <span class="hljs-number">0</span>) {
              isCrossOriginError = <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (event.defaultPrevented) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-166" id="section-166"></a>
</div>
<p>Some other error handler has prevented default.
Browsers silence the error report if this happens.
We'll remember this to later decide whether to log it or not.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">'object'</span>) {
                <span class="hljs-keyword">try</span> {
                  error._suppressLogging = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">catch</span> (inner) {<span class="hljs-comment">// Ignore.</span>
                }
              }
            }
          } <span class="hljs-comment">// Create a fake event type.</span>


          <span class="hljs-keyword">var</span> evtType = <span class="hljs-string">"react-"</span> + (name ? name : <span class="hljs-string">'invokeguardedcallback'</span>); <span class="hljs-comment">// Attach our event handlers</span>

          <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, handleWindowError);
          fakeNode.addEventListener(evtType, callCallback, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Synchronously dispatch our fake event. If the user-provided function</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-167" id="section-167"></a>
</div>
<p>errors, it will trigger our global error handler.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          evt.initEvent(evtType, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
          fakeNode.dispatchEvent(evt);

          <span class="hljs-keyword">if</span> (windowEventDescriptor) {
            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">'event'</span>, windowEventDescriptor);
          }

          <span class="hljs-keyword">if</span> (didError) {
            <span class="hljs-keyword">if</span> (!didSetError) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-168" id="section-168"></a>
</div>
<p>The callback errored, but the error event never fired.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'An error was thrown inside one of your components, but React '</span> + <span class="hljs-string">"doesn't know what it was. This is likely due to browser "</span> + <span class="hljs-string">'flakiness. React does its best to preserve the "Pause on '</span> + <span class="hljs-string">'exceptions" behavior of the DevTools, which requires some '</span> + <span class="hljs-string">"DEV-mode only tricks. It's possible that these don't work in "</span> + <span class="hljs-string">'your browser. Try triggering the error in production mode, '</span> + <span class="hljs-string">'or switching to a modern browser. If you suspect that this is '</span> + <span class="hljs-string">'actually an issue with React, please file an issue.'</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCrossOriginError) {
              error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"A cross-origin error was thrown. React doesn't have access to "</span> + <span class="hljs-string">'the actual error object in development. '</span> + <span class="hljs-string">'See https://fb.me/react-crossorigin-error for more information.'</span>);
            }

            <span class="hljs-keyword">this</span>.onError(error);
          } <span class="hljs-comment">// Remove our event listeners</span>


          <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'error'</span>, handleWindowError);
        };

        invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
      }
    }
    <span class="hljs-keyword">var</span> invokeGuardedCallbackImpl$<span class="hljs-number">1</span> = invokeGuardedCallbackImpl;
    <span class="hljs-keyword">var</span> hasError = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Used by event system to capture/rethrow the first error.</span>

    <span class="hljs-keyword">var</span> hasRethrowError = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> rethrowError = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> reporter = {
      <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
        hasError = <span class="hljs-literal">true</span>;
        caughtError = error;
      }
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-169" id="section-169"></a>
</div>
<div class="dox">
<div class="summary">
<p>Call a function while guarding against errors that happens within it.
Returns an error if it throws, otherwise null.</p>
</div>
<div class="body">
<p>In production, this is implemented using a try-catch. The reason we don't
use a try-catch directly is so that we can swap out a different
implementation in DEV mode.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">name</span>
<span class="dox_type">String</span>
<span>of the guard to use for logging or debugging
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">func</span>
<span class="dox_type">Function</span>
<span>The function to invoke
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">context</span>
<span>The context to use when calling the function
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">args</span>
<span>Arguments for function
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeGuardedCallback</span>(<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) </span>{
      hasError = <span class="hljs-literal">false</span>;
      caughtError = <span class="hljs-literal">null</span>;
      invokeGuardedCallbackImpl$<span class="hljs-number">1.</span>apply(reporter, <span class="hljs-built_in">arguments</span>);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-170" id="section-170"></a>
</div>
<div class="dox">
<div class="summary">
<p>Same as invokeGuardedCallback, but instead of returning an error, it stores
it in a global so it can be rethrown by <code>rethrowCaughtError</code> later.
TODO: See if caughtError and rethrowError can be unified.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">name</span>
<span class="dox_type">String</span>
<span>of the guard to use for logging or debugging
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">func</span>
<span class="dox_type">Function</span>
<span>The function to invoke
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">context</span>
<span>The context to use when calling the function
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">args</span>
<span>Arguments for function
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeGuardedCallbackAndCatchFirstError</span>(<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) </span>{
      invokeGuardedCallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">if</span> (hasError) {
        <span class="hljs-keyword">var</span> error = clearCaughtError();

        <span class="hljs-keyword">if</span> (!hasRethrowError) {
          hasRethrowError = <span class="hljs-literal">true</span>;
          rethrowError = error;
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-171" id="section-171"></a>
</div>
<div class="dox">
<div class="summary">
<p>During execution of guarded functions we will capture the first error which
we will rethrow to be handled by the top level error handler.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rethrowCaughtError</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (hasRethrowError) {
        <span class="hljs-keyword">var</span> error = rethrowError;
        hasRethrowError = <span class="hljs-literal">false</span>;
        rethrowError = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">throw</span> error;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCaughtError</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> hasError;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearCaughtError</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (hasError) {
        <span class="hljs-keyword">var</span> error = caughtError;
        hasError = <span class="hljs-literal">false</span>;
        caughtError = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> error;
      } <span class="hljs-keyword">else</span> {
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }
      }
    }

    <span class="hljs-keyword">var</span> getFiberCurrentPropsFromNode = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> getInstanceFromNode = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> getNodeFromInstance = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setComponentTree</span>(<span class="hljs-params">getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl</span>) </span>{
      getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
      getInstanceFromNode = getInstanceFromNodeImpl;
      getNodeFromInstance = getNodeFromInstanceImpl;
      {
        <span class="hljs-keyword">if</span> (!getNodeFromInstance || !getInstanceFromNode) {
          error(<span class="hljs-string">'EventPluginUtils.setComponentTree(...): Injected '</span> + <span class="hljs-string">'module is missing getNodeFromInstance or getInstanceFromNode.'</span>);
        }
      }
    }

    <span class="hljs-keyword">var</span> validateEventDispatches;
    {
      validateEventDispatches = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">var</span> dispatchListeners = event._dispatchListeners;
        <span class="hljs-keyword">var</span> dispatchInstances = event._dispatchInstances;
        <span class="hljs-keyword">var</span> listenersIsArr = <span class="hljs-built_in">Array</span>.isArray(dispatchListeners);
        <span class="hljs-keyword">var</span> listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> instancesIsArr = <span class="hljs-built_in">Array</span>.isArray(dispatchInstances);
        <span class="hljs-keyword">var</span> instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {
          error(<span class="hljs-string">'EventPluginUtils: Invalid `event`.'</span>);
        }
      };
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-172" id="section-172"></a>
</div>
<div class="dox">
<div class="summary">
<p>Dispatch the event to the listener.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">event</span>
<span class="dox_type">SyntheticEvent</span>
<span>SyntheticEvent to handle
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">listener</span>
<span class="dox_type">function</span>
<span>Application-level callback
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">inst</span>
<span>Internal component instance
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeDispatch</span>(<span class="hljs-params">event, listener, inst</span>) </span>{
      <span class="hljs-keyword">var</span> type = event.type || <span class="hljs-string">'unknown-event'</span>;
      event.currentTarget = getNodeFromInstance(inst);
      invokeGuardedCallbackAndCatchFirstError(type, listener, <span class="hljs-literal">undefined</span>, event);
      event.currentTarget = <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-173" id="section-173"></a>
</div>
<div class="dox">
<div class="summary">
<p>Standard/simple iteration through an event's collected dispatches.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executeDispatchesInOrder</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">var</span> dispatchListeners = event._dispatchListeners;
      <span class="hljs-keyword">var</span> dispatchInstances = event._dispatchInstances;
      {
        validateEventDispatches(event);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(dispatchListeners)) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dispatchListeners.length; i++) {
          <span class="hljs-keyword">if</span> (event.isPropagationStopped()) {
            <span class="hljs-keyword">break</span>;
          } <span class="hljs-comment">// Listeners and Instances are two parallel arrays that are always in sync.</span>


          executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dispatchListeners) {
        executeDispatch(event, dispatchListeners, dispatchInstances);
      }

      event._dispatchListeners = <span class="hljs-literal">null</span>;
      event._dispatchInstances = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> FunctionComponent = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> ClassComponent = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> IndeterminateComponent = <span class="hljs-number">2</span>; <span class="hljs-comment">// Before we know whether it is function or class</span>

    <span class="hljs-keyword">var</span> HostRoot = <span class="hljs-number">3</span>; <span class="hljs-comment">// Root of a host tree. Could be nested inside another node.</span>

    <span class="hljs-keyword">var</span> HostPortal = <span class="hljs-number">4</span>; <span class="hljs-comment">// A subtree. Could be an entry point to a different renderer.</span>

    <span class="hljs-keyword">var</span> HostComponent = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">var</span> HostText = <span class="hljs-number">6</span>;
    <span class="hljs-keyword">var</span> Fragment = <span class="hljs-number">7</span>;
    <span class="hljs-keyword">var</span> Mode = <span class="hljs-number">8</span>;
    <span class="hljs-keyword">var</span> ContextConsumer = <span class="hljs-number">9</span>;
    <span class="hljs-keyword">var</span> ContextProvider = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">var</span> ForwardRef = <span class="hljs-number">11</span>;
    <span class="hljs-keyword">var</span> Profiler = <span class="hljs-number">12</span>;
    <span class="hljs-keyword">var</span> SuspenseComponent = <span class="hljs-number">13</span>;
    <span class="hljs-keyword">var</span> MemoComponent = <span class="hljs-number">14</span>;
    <span class="hljs-keyword">var</span> SimpleMemoComponent = <span class="hljs-number">15</span>;
    <span class="hljs-keyword">var</span> LazyComponent = <span class="hljs-number">16</span>;
    <span class="hljs-keyword">var</span> IncompleteClassComponent = <span class="hljs-number">17</span>;
    <span class="hljs-keyword">var</span> DehydratedFragment = <span class="hljs-number">18</span>;
    <span class="hljs-keyword">var</span> SuspenseListComponent = <span class="hljs-number">19</span>;
    <span class="hljs-keyword">var</span> FundamentalComponent = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">var</span> ScopeComponent = <span class="hljs-number">21</span>;
    <span class="hljs-keyword">var</span> Block = <span class="hljs-number">22</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-174" id="section-174"></a>
</div>
<div class="dox">
<div class="summary">
<p>Injectable ordering of event plugins.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> eventPluginOrder = <span class="hljs-literal">null</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-175" id="section-175"></a>
</div>
<div class="dox">
<div class="summary">
<p>Injectable mapping from names to event plugin modules.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> namesToPlugins = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-176" id="section-176"></a>
</div>
<div class="dox">
<div class="summary">
<p>Recomputes the plugin list using the injected plugins and plugin ordering.</p>
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recomputePluginOrdering</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!eventPluginOrder) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-177" id="section-177"></a>
</div>
<p>Wait until an <code>eventPluginOrder</code> is injected.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pluginName <span class="hljs-keyword">in</span> namesToPlugins) {
        <span class="hljs-keyword">var</span> pluginModule = namesToPlugins[pluginName];
        <span class="hljs-keyword">var</span> pluginIndex = eventPluginOrder.indexOf(pluginName);

        <span class="hljs-keyword">if</span> (!(pluginIndex &gt; <span class="hljs-number">-1</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `"</span> + pluginName + <span class="hljs-string">"`."</span>);
          }
        }

        <span class="hljs-keyword">if</span> (plugins[pluginIndex]) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (!pluginModule.extractEvents) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `"</span> + pluginName + <span class="hljs-string">"` does not."</span>);
          }
        }

        plugins[pluginIndex] = pluginModule;
        <span class="hljs-keyword">var</span> publishedEvents = pluginModule.eventTypes;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> eventName <span class="hljs-keyword">in</span> publishedEvents) {
          <span class="hljs-keyword">if</span> (!publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EventPluginRegistry: Failed to publish event `"</span> + eventName + <span class="hljs-string">"` for plugin `"</span> + pluginName + <span class="hljs-string">"`."</span>);
            }
          }
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-178" id="section-178"></a>
</div>
<div class="dox">
<div class="summary">
<p>Publishes an event so that it can be dispatched by the supplied plugin.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">dispatchConfig</span>
<span class="dox_type">object</span>
<span>Dispatch configuration for the event.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">PluginModule</span>
<span class="dox_type">object</span>
<span>Plugin publishing the event.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
<span>True if the event was successfully published.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">publishEventForPlugin</span>(<span class="hljs-params">dispatchConfig, pluginModule, eventName</span>) </span>{
      <span class="hljs-keyword">if</span> (!!eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EventPluginRegistry: More than one plugin attempted to publish the same event name, `"</span> + eventName + <span class="hljs-string">"`."</span>);
        }
      }

      eventNameDispatchConfigs[eventName] = dispatchConfig;
      <span class="hljs-keyword">var</span> phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      <span class="hljs-keyword">if</span> (phasedRegistrationNames) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> phaseName <span class="hljs-keyword">in</span> phasedRegistrationNames) {
          <span class="hljs-keyword">if</span> (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            <span class="hljs-keyword">var</span> phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-179" id="section-179"></a>
</div>
<div class="dox">
<div class="summary">
<p>Publishes a registration name that is used to identify dispatched events.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">registrationName</span>
<span class="dox_type">string</span>
<span>Registration name to add.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">PluginModule</span>
<span class="dox_type">object</span>
<span>Plugin publishing the event.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">publishRegistrationName</span>(<span class="hljs-params">registrationName, pluginModule, eventName</span>) </span>{
      <span class="hljs-keyword">if</span> (!!registrationNameModules[registrationName]) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EventPluginRegistry: More than one plugin attempted to publish the same registration name, `"</span> + registrationName + <span class="hljs-string">"`."</span>);
        }
      }

      registrationNameModules[registrationName] = pluginModule;
      registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
      {
        <span class="hljs-keyword">var</span> lowerCasedName = registrationName.toLowerCase();
        possibleRegistrationNames[lowerCasedName] = registrationName;

        <span class="hljs-keyword">if</span> (registrationName === <span class="hljs-string">'onDoubleClick'</span>) {
          possibleRegistrationNames.ondblclick = registrationName;
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-180" id="section-180"></a>
</div>
<div class="dox">
<div class="summary">
<p>Registers plugins so that they can extract and dispatch events.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-181" id="section-181"></a>
</div>
<div class="dox">
<div class="summary">
<p>Ordered list of injected plugins.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> plugins = [];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-182" id="section-182"></a>
</div>
<div class="dox">
<div class="summary">
<p>Mapping from event name to dispatch config</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> eventNameDispatchConfigs = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-183" id="section-183"></a>
</div>
<div class="dox">
<div class="summary">
<p>Mapping from registration name to plugin module</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> registrationNameModules = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-184" id="section-184"></a>
</div>
<div class="dox">
<div class="summary">
<p>Mapping from registration name to event name</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> registrationNameDependencies = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-185" id="section-185"></a>
</div>
<div class="dox">
<div class="summary">
<p>Mapping from lowercase registration names to the properly cased version,
used to warn in the case of missing event handlers. Available
only in true.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Type</div>
<div class="dox_tag_detail">
<span class="dox_type">Object</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> possibleRegistrationNames = {}; <span class="hljs-comment">// Trust the developer to only use possibleRegistrationNames in true</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-186" id="section-186"></a>
</div>
<div class="dox">
<div class="summary">
<p>Injects an ordering of plugins (by plugin name). This allows the ordering
to be decoupled from injection of the actual plugins so that ordering is
always deterministic regardless of packaging, on-the-fly injection, etc.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">InjectedEventPluginOrder</span>
<span class="dox_type">array</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">injectEventPluginOrder</span>(<span class="hljs-params">injectedEventPluginOrder</span>) </span>{
      <span class="hljs-keyword">if</span> (!!eventPluginOrder) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React."</span>);
        }
      } <span class="hljs-comment">// Clone the ordering so it cannot be dynamically mutated.</span>


      eventPluginOrder = <span class="hljs-built_in">Array</span>.prototype.slice.call(injectedEventPluginOrder);
      recomputePluginOrdering();
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-187" id="section-187"></a>
</div>
<div class="dox">
<div class="summary">
<p>Injects plugins to be used by plugin event system. The plugin names must be
in the ordering injected by <code>injectEventPluginOrder</code>.</p>
</div>
<div class="body">
<p>Plugins can be injected as part of page initialization or on-the-fly.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">injectedNamesToPlugins</span>
<span class="dox_type">object</span>
<span>Map from names to plugin modules.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">injectEventPluginsByName</span>(<span class="hljs-params">injectedNamesToPlugins</span>) </span>{
      <span class="hljs-keyword">var</span> isOrderingDirty = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pluginName <span class="hljs-keyword">in</span> injectedNamesToPlugins) {
        <span class="hljs-keyword">if</span> (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> pluginModule = injectedNamesToPlugins[pluginName];

        <span class="hljs-keyword">if</span> (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
          <span class="hljs-keyword">if</span> (!!namesToPlugins[pluginName]) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"EventPluginRegistry: Cannot inject two different event plugins using the same name, `"</span> + pluginName + <span class="hljs-string">"`."</span>);
            }
          }

          namesToPlugins[pluginName] = pluginModule;
          isOrderingDirty = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">if</span> (isOrderingDirty) {
        recomputePluginOrdering();
      }
    }

    <span class="hljs-keyword">var</span> canUseDOM = !!(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.document !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.document.createElement !== <span class="hljs-string">'undefined'</span>);
    <span class="hljs-keyword">var</span> PLUGIN_EVENT_SYSTEM = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> IS_REPLAYED = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>;
    <span class="hljs-keyword">var</span> IS_FIRST_ANCESTOR = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>;
    <span class="hljs-keyword">var</span> restoreImpl = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> restoreTarget = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> restoreQueue = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreStateOfTarget</span>(<span class="hljs-params">target</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-188" id="section-188"></a>
</div>
<p>We perform this translation at the end of the event loop so that we
always receive the correct fiber here</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> internalInstance = getInstanceFromNode(target);

      <span class="hljs-keyword">if</span> (!internalInstance) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-189" id="section-189"></a>
</div>
<p>Unmounted</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> restoreImpl === <span class="hljs-string">'function'</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }

      <span class="hljs-keyword">var</span> stateNode = internalInstance.stateNode; <span class="hljs-comment">// Guard against Fiber being unmounted.</span>

      <span class="hljs-keyword">if</span> (stateNode) {
        <span class="hljs-keyword">var</span> _props = getFiberCurrentPropsFromNode(stateNode);

        restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setRestoreImplementation</span>(<span class="hljs-params">impl</span>) </span>{
      restoreImpl = impl;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueStateRestore</span>(<span class="hljs-params">target</span>) </span>{
      <span class="hljs-keyword">if</span> (restoreTarget) {
        <span class="hljs-keyword">if</span> (restoreQueue) {
          restoreQueue.push(target);
        } <span class="hljs-keyword">else</span> {
          restoreQueue = [target];
        }
      } <span class="hljs-keyword">else</span> {
        restoreTarget = target;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">needsStateRestore</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> restoreTarget !== <span class="hljs-literal">null</span> || restoreQueue !== <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreStateIfNeeded</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!restoreTarget) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> target = restoreTarget;
      <span class="hljs-keyword">var</span> queuedTargets = restoreQueue;
      restoreTarget = <span class="hljs-literal">null</span>;
      restoreQueue = <span class="hljs-literal">null</span>;
      restoreStateOfTarget(target);

      <span class="hljs-keyword">if</span> (queuedTargets) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; queuedTargets.length; i++) {
          restoreStateOfTarget(queuedTargets[i]);
        }
      }
    }

    <span class="hljs-keyword">var</span> enableProfilerTimer = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Trace which interactions trigger each commit.</span>

    <span class="hljs-keyword">var</span> enableDeprecatedFlareAPI = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Experimental Host Component support.</span>

    <span class="hljs-keyword">var</span> enableFundamentalAPI = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Experimental Scope support.</span>

    <span class="hljs-keyword">var</span> warnAboutStringRefs = <span class="hljs-literal">false</span>; <span class="hljs-comment">// the renderer. Such as when we're dispatching events or if third party</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-190" id="section-190"></a>
</div>
<p>libraries need to call batchedUpdates. Eventually, this API will go away when
everything is batched by default. We'll then have a similar API to opt-out of
scheduled work and instead do synchronous work.
Defaults</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> batchedUpdatesImpl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, bookkeeping</span>) </span>{
      <span class="hljs-keyword">return</span> fn(bookkeeping);
    };

    <span class="hljs-keyword">var</span> discreteUpdatesImpl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, a, b, c, d</span>) </span>{
      <span class="hljs-keyword">return</span> fn(a, b, c, d);
    };

    <span class="hljs-keyword">var</span> flushDiscreteUpdatesImpl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

    <span class="hljs-keyword">var</span> batchedEventUpdatesImpl = batchedUpdatesImpl;
    <span class="hljs-keyword">var</span> isInsideEventHandler = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> isBatchingEventUpdates = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishEventHandler</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-191" id="section-191"></a>
</div>
<p>Here we wait until all updates have propagated, which is important
when using controlled components within layers:
https://github.com/facebook/react/issues/1698
Then we restore state of any controlled component.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> controlledComponentsHavePendingUpdates = needsStateRestore();

      <span class="hljs-keyword">if</span> (controlledComponentsHavePendingUpdates) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-192" id="section-192"></a>
</div>
<p>If a controlled event was fired, we may need to restore the state of
the DOM node back to the controlled value. This is necessary when React
bails out of the update without touching the DOM.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        flushDiscreteUpdatesImpl();
        restoreStateIfNeeded();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">batchedUpdates</span>(<span class="hljs-params">fn, bookkeeping</span>) </span>{
      <span class="hljs-keyword">if</span> (isInsideEventHandler) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-193" id="section-193"></a>
</div>
<p>If we are currently inside another batch, we need to wait until it
fully completes before restoring state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> fn(bookkeeping);
      }

      isInsideEventHandler = <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> batchedUpdatesImpl(fn, bookkeeping);
      } <span class="hljs-keyword">finally</span> {
        isInsideEventHandler = <span class="hljs-literal">false</span>;
        finishEventHandler();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">batchedEventUpdates</span>(<span class="hljs-params">fn, a, b</span>) </span>{
      <span class="hljs-keyword">if</span> (isBatchingEventUpdates) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-194" id="section-194"></a>
</div>
<p>If we are currently inside another batch, we need to wait until it
fully completes before restoring state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> fn(a, b);
      }

      isBatchingEventUpdates = <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> batchedEventUpdatesImpl(fn, a, b);
      } <span class="hljs-keyword">finally</span> {
        isBatchingEventUpdates = <span class="hljs-literal">false</span>;
        finishEventHandler();
      }
    } <span class="hljs-comment">// This is for the React Flare event system</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">discreteUpdates</span>(<span class="hljs-params">fn, a, b, c, d</span>) </span>{
      <span class="hljs-keyword">var</span> prevIsInsideEventHandler = isInsideEventHandler;
      isInsideEventHandler = <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> discreteUpdatesImpl(fn, a, b, c, d);
      } <span class="hljs-keyword">finally</span> {
        isInsideEventHandler = prevIsInsideEventHandler;

        <span class="hljs-keyword">if</span> (!isInsideEventHandler) {
          finishEventHandler();
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushDiscreteUpdatesIfNeeded</span>(<span class="hljs-params">timeStamp</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-195" id="section-195"></a>
</div>
<p>event.timeStamp isn't overly reliable due to inconsistencies in
how different browsers have historically provided the time stamp.
Some browsers provide high-resolution time stamps for all events,
some provide low-resolution time stamps for all events. FF &lt; 52
even mixes both time stamps together. Some browsers even report
negative time stamps or time stamps that are 0 (iOS9) in some cases.
Given we are only comparing two time stamps with equality (!==),
we are safe from the resolution differences. If the time stamp is 0
we bail-out of preventing the flush, which can affect semantics,
such as if an earlier flush removes or adds event listeners that
are fired in the subsequent flush. However, this is the same
behaviour as we had before this change, so the risks are low.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (!isInsideEventHandler &amp;&amp; !enableDeprecatedFlareAPI) {
        flushDiscreteUpdatesImpl();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBatchingImplementation</span>(<span class="hljs-params">_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl</span>) </span>{
      batchedUpdatesImpl = _batchedUpdatesImpl;
      discreteUpdatesImpl = _discreteUpdatesImpl;
      flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
      batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
    }

    <span class="hljs-keyword">var</span> DiscreteEvent = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> UserBlockingEvent = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> ContinuousEvent = <span class="hljs-number">2</span>; <span class="hljs-comment">// A reserved attribute.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-196" id="section-196"></a>
</div>
<p>It is handled by React separately and shouldn't be written to the DOM.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> RESERVED = <span class="hljs-number">0</span>; <span class="hljs-comment">// A simple string attribute.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-197" id="section-197"></a>
</div>
<p>Attributes that aren't in the whitelist are presumed to have this type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> STRING = <span class="hljs-number">1</span>; <span class="hljs-comment">// A string attribute that accepts booleans in React. In HTML, these are called</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-198" id="section-198"></a>
</div>
<p>&quot;enumerated&quot; attributes with &quot;true&quot; and &quot;false&quot; as possible values.
When true, it should be set to a &quot;true&quot; string.
When false, it should be set to a &quot;false&quot; string.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> BOOLEANISH_STRING = <span class="hljs-number">2</span>; <span class="hljs-comment">// A real boolean attribute.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-199" id="section-199"></a>
</div>
<p>When true, it should be present (set either to an empty string or its name).
When false, it should be omitted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> BOOLEAN = <span class="hljs-number">3</span>; <span class="hljs-comment">// An attribute that can be used as a flag as well as with a value.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-200" id="section-200"></a>
</div>
<p>When true, it should be present (set either to an empty string or its name).
When false, it should be omitted.
For any other value, should be present with that value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> OVERLOADED_BOOLEAN = <span class="hljs-number">4</span>; <span class="hljs-comment">// An attribute that must be numeric or parse as a numeric.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-201" id="section-201"></a>
</div>
<p>When falsy, it should be removed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> NUMERIC = <span class="hljs-number">5</span>; <span class="hljs-comment">// An attribute that must be positive numeric or parse as a positive numeric.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-202" id="section-202"></a>
</div>
<p>When falsy, it should be removed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> POSITIVE_NUMERIC = <span class="hljs-number">6</span>;
    <span class="hljs-comment">/* eslint-disable max-len */</span>

    <span class="hljs-keyword">var</span> ATTRIBUTE_NAME_START_CHAR = <span class="hljs-string">":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD"</span>;
    <span class="hljs-comment">/* eslint-enable max-len */</span>

    <span class="hljs-keyword">var</span> ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + <span class="hljs-string">"\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040"</span>;
    <span class="hljs-keyword">var</span> ROOT_ATTRIBUTE_NAME = <span class="hljs-string">'data-reactroot'</span>;
    <span class="hljs-keyword">var</span> VALID_ATTRIBUTE_NAME_REGEX = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^['</span> + ATTRIBUTE_NAME_START_CHAR + <span class="hljs-string">']['</span> + ATTRIBUTE_NAME_CHAR + <span class="hljs-string">']*$'</span>);
    <span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
    <span class="hljs-keyword">var</span> illegalAttributeNameCache = {};
    <span class="hljs-keyword">var</span> validatedAttributeNameCache = {};

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAttributeNameSafe</span>(<span class="hljs-params">attributeName</span>) </span>{
      <span class="hljs-keyword">if</span> (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
        validatedAttributeNameCache[attributeName] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      illegalAttributeNameCache[attributeName] = <span class="hljs-literal">true</span>;
      {
        error(<span class="hljs-string">'Invalid attribute name: `%s`'</span>, attributeName);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldIgnoreAttribute</span>(<span class="hljs-params">name, propertyInfo, isCustomComponentTag</span>) </span>{
      <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> propertyInfo.type === RESERVED;
      }

      <span class="hljs-keyword">if</span> (isCustomComponentTag) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (name.length &gt; <span class="hljs-number">2</span> &amp;&amp; (name[<span class="hljs-number">0</span>] === <span class="hljs-string">'o'</span> || name[<span class="hljs-number">0</span>] === <span class="hljs-string">'O'</span>) &amp;&amp; (name[<span class="hljs-number">1</span>] === <span class="hljs-string">'n'</span> || name[<span class="hljs-number">1</span>] === <span class="hljs-string">'N'</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldRemoveAttributeWithWarning</span>(<span class="hljs-params">name, value, propertyInfo, isCustomComponentTag</span>) </span>{
      <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span> &amp;&amp; propertyInfo.type === RESERVED) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> value) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>: <span class="hljs-comment">// $FlowIssue symbol is perfectly valid here</span>

        <span class="hljs-keyword">case</span> <span class="hljs-string">'symbol'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-203" id="section-203"></a>
</div>
<p>eslint-disable-line</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'boolean'</span>:
          {
            <span class="hljs-keyword">if</span> (isCustomComponentTag) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">return</span> !propertyInfo.acceptsBooleans;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> prefix = name.toLowerCase().slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
              <span class="hljs-keyword">return</span> prefix !== <span class="hljs-string">'data-'</span> &amp;&amp; prefix !== <span class="hljs-string">'aria-'</span>;
            }
          }

        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldRemoveAttribute</span>(<span class="hljs-params">name, value, propertyInfo, isCustomComponentTag</span>) </span>{
      <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (isCustomComponentTag) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">switch</span> (propertyInfo.type) {
          <span class="hljs-keyword">case</span> BOOLEAN:
            <span class="hljs-keyword">return</span> !value;

          <span class="hljs-keyword">case</span> OVERLOADED_BOOLEAN:
            <span class="hljs-keyword">return</span> value === <span class="hljs-literal">false</span>;

          <span class="hljs-keyword">case</span> NUMERIC:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(value);

          <span class="hljs-keyword">case</span> POSITIVE_NUMERIC:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(value) || value &lt; <span class="hljs-number">1</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPropertyInfo</span>(<span class="hljs-params">name</span>) </span>{
      <span class="hljs-keyword">return</span> properties.hasOwnProperty(name) ? properties[name] : <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PropertyInfoRecord</span>(<span class="hljs-params">name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL</span>) </span>{
      <span class="hljs-keyword">this</span>.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
      <span class="hljs-keyword">this</span>.attributeName = attributeName;
      <span class="hljs-keyword">this</span>.attributeNamespace = attributeNamespace;
      <span class="hljs-keyword">this</span>.mustUseProperty = mustUseProperty;
      <span class="hljs-keyword">this</span>.propertyName = name;
      <span class="hljs-keyword">this</span>.type = type;
      <span class="hljs-keyword">this</span>.sanitizeURL = sanitizeURL;
    } <span class="hljs-comment">// When adding attributes to this list, be sure to also add them to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-204" id="section-204"></a>
</div>
<p>the <code>possibleStandardNames</code> module to ensure casing and incorrect
name warnings.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> properties = {}; <span class="hljs-comment">// These props are reserved by React. They shouldn't be written to the DOM.</span>

    <span class="hljs-keyword">var</span> reservedProps = [<span class="hljs-string">'children'</span>, <span class="hljs-string">'dangerouslySetInnerHTML'</span>, <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This prevents the assignment of defaultValue to regular</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-205" id="section-205"></a>
</div>
<p>elements (not just inputs). Now that ReactDOMInput assigns to the
defaultValue property -- do we need this?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-string">'defaultValue'</span>, <span class="hljs-string">'defaultChecked'</span>, <span class="hljs-string">'innerHTML'</span>, <span class="hljs-string">'suppressContentEditableWarning'</span>, <span class="hljs-string">'suppressHydrationWarning'</span>, <span class="hljs-string">'style'</span>];
    reservedProps.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, RESERVED, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// A few React string attributes have a different name.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-206" id="section-206"></a>
</div>
<p>This is a mapping from React prop names to the attribute names.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    [[<span class="hljs-string">'acceptCharset'</span>, <span class="hljs-string">'accept-charset'</span>], [<span class="hljs-string">'className'</span>, <span class="hljs-string">'class'</span>], [<span class="hljs-string">'htmlFor'</span>, <span class="hljs-string">'for'</span>], [<span class="hljs-string">'httpEquiv'</span>, <span class="hljs-string">'http-equiv'</span>]].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
      <span class="hljs-keyword">var</span> name = _ref[<span class="hljs-number">0</span>],
          attributeName = _ref[<span class="hljs-number">1</span>];
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are "enumerated" HTML attributes that accept "true" and "false".</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-207" id="section-207"></a>
</div>
<p>In React, we let users pass <code>true</code> and <code>false</code> even though technically
these aren't boolean attributes (they are coerced to strings).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    [<span class="hljs-string">'contentEditable'</span>, <span class="hljs-string">'draggable'</span>, <span class="hljs-string">'spellCheck'</span>, <span class="hljs-string">'value'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, BOOLEANISH_STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name.toLowerCase(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are "enumerated" SVG attributes that accept "true" and "false".</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-208" id="section-208"></a>
</div>
<p>In React, we let users pass <code>true</code> and <code>false</code> even though technically
these aren't boolean attributes (they are coerced to strings).
Since these are SVG attributes, their attribute names are case-sensitive.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    [<span class="hljs-string">'autoReverse'</span>, <span class="hljs-string">'externalResourcesRequired'</span>, <span class="hljs-string">'focusable'</span>, <span class="hljs-string">'preserveAlpha'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, BOOLEANISH_STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are HTML boolean attributes.</span>

    [<span class="hljs-string">'allowFullScreen'</span>, <span class="hljs-string">'async'</span>, <span class="hljs-comment">// Note: there is a special case that prevents it from being written to the DOM</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-209" id="section-209"></a>
</div>
<p>on the client side because the browsers are inconsistent. Instead we call focus().</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-string">'autoFocus'</span>, <span class="hljs-string">'autoPlay'</span>, <span class="hljs-string">'controls'</span>, <span class="hljs-string">'default'</span>, <span class="hljs-string">'defer'</span>, <span class="hljs-string">'disabled'</span>, <span class="hljs-string">'disablePictureInPicture'</span>, <span class="hljs-string">'formNoValidate'</span>, <span class="hljs-string">'hidden'</span>, <span class="hljs-string">'loop'</span>, <span class="hljs-string">'noModule'</span>, <span class="hljs-string">'noValidate'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'playsInline'</span>, <span class="hljs-string">'readOnly'</span>, <span class="hljs-string">'required'</span>, <span class="hljs-string">'reversed'</span>, <span class="hljs-string">'scoped'</span>, <span class="hljs-string">'seamless'</span>, <span class="hljs-comment">// Microdata</span>
    <span class="hljs-string">'itemScope'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, BOOLEAN, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name.toLowerCase(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are the few React props that we set as DOM properties</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-210" id="section-210"></a>
</div>
<p>rather than attributes. These are all booleans.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    [<span class="hljs-string">'checked'</span>, <span class="hljs-comment">// Note: `option.selected` is not updated if `select.multiple` is</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-211" id="section-211"></a>
</div>
<p>disabled with <code>removeAttribute</code>. We have special logic for handling this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-string">'multiple'</span>, <span class="hljs-string">'muted'</span>, <span class="hljs-string">'selected'</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-212" id="section-212"></a>
</div>
<p>you'll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    ].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, BOOLEAN, <span class="hljs-literal">true</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are HTML attributes that are "overloaded booleans": they behave like</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-213" id="section-213"></a>
</div>
<p>booleans, but can also accept a string value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    [<span class="hljs-string">'capture'</span>, <span class="hljs-string">'download'</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-214" id="section-214"></a>
</div>
<p>you'll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    ].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, OVERLOADED_BOOLEAN, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are HTML attributes that must be positive numbers.</span>

    [<span class="hljs-string">'cols'</span>, <span class="hljs-string">'rows'</span>, <span class="hljs-string">'size'</span>, <span class="hljs-string">'span'</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-215" id="section-215"></a>
</div>
<p>you'll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    ].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, POSITIVE_NUMERIC, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are HTML attributes that must be numbers.</span>

    [<span class="hljs-string">'rowSpan'</span>, <span class="hljs-string">'start'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, NUMERIC, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name.toLowerCase(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    });
    <span class="hljs-keyword">var</span> CAMELIZE = <span class="hljs-regexp">/[\-\:]([a-z])/g</span>;

    <span class="hljs-keyword">var</span> capitalize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">token</span>) </span>{
      <span class="hljs-keyword">return</span> token[<span class="hljs-number">1</span>].toUpperCase();
    }; <span class="hljs-comment">// This is a list of all SVG attributes that need special casing, namespacing,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-216" id="section-216"></a>
</div>
<p>or boolean value assignment. Regular attributes that just accept strings
and have the same names are omitted, just like in the HTML whitelist.
Some of these attributes can be hard to find. This list was created by
scraping the MDN documentation.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    [<span class="hljs-string">'accent-height'</span>, <span class="hljs-string">'alignment-baseline'</span>, <span class="hljs-string">'arabic-form'</span>, <span class="hljs-string">'baseline-shift'</span>, <span class="hljs-string">'cap-height'</span>, <span class="hljs-string">'clip-path'</span>, <span class="hljs-string">'clip-rule'</span>, <span class="hljs-string">'color-interpolation'</span>, <span class="hljs-string">'color-interpolation-filters'</span>, <span class="hljs-string">'color-profile'</span>, <span class="hljs-string">'color-rendering'</span>, <span class="hljs-string">'dominant-baseline'</span>, <span class="hljs-string">'enable-background'</span>, <span class="hljs-string">'fill-opacity'</span>, <span class="hljs-string">'fill-rule'</span>, <span class="hljs-string">'flood-color'</span>, <span class="hljs-string">'flood-opacity'</span>, <span class="hljs-string">'font-family'</span>, <span class="hljs-string">'font-size'</span>, <span class="hljs-string">'font-size-adjust'</span>, <span class="hljs-string">'font-stretch'</span>, <span class="hljs-string">'font-style'</span>, <span class="hljs-string">'font-variant'</span>, <span class="hljs-string">'font-weight'</span>, <span class="hljs-string">'glyph-name'</span>, <span class="hljs-string">'glyph-orientation-horizontal'</span>, <span class="hljs-string">'glyph-orientation-vertical'</span>, <span class="hljs-string">'horiz-adv-x'</span>, <span class="hljs-string">'horiz-origin-x'</span>, <span class="hljs-string">'image-rendering'</span>, <span class="hljs-string">'letter-spacing'</span>, <span class="hljs-string">'lighting-color'</span>, <span class="hljs-string">'marker-end'</span>, <span class="hljs-string">'marker-mid'</span>, <span class="hljs-string">'marker-start'</span>, <span class="hljs-string">'overline-position'</span>, <span class="hljs-string">'overline-thickness'</span>, <span class="hljs-string">'paint-order'</span>, <span class="hljs-string">'panose-1'</span>, <span class="hljs-string">'pointer-events'</span>, <span class="hljs-string">'rendering-intent'</span>, <span class="hljs-string">'shape-rendering'</span>, <span class="hljs-string">'stop-color'</span>, <span class="hljs-string">'stop-opacity'</span>, <span class="hljs-string">'strikethrough-position'</span>, <span class="hljs-string">'strikethrough-thickness'</span>, <span class="hljs-string">'stroke-dasharray'</span>, <span class="hljs-string">'stroke-dashoffset'</span>, <span class="hljs-string">'stroke-linecap'</span>, <span class="hljs-string">'stroke-linejoin'</span>, <span class="hljs-string">'stroke-miterlimit'</span>, <span class="hljs-string">'stroke-opacity'</span>, <span class="hljs-string">'stroke-width'</span>, <span class="hljs-string">'text-anchor'</span>, <span class="hljs-string">'text-decoration'</span>, <span class="hljs-string">'text-rendering'</span>, <span class="hljs-string">'underline-position'</span>, <span class="hljs-string">'underline-thickness'</span>, <span class="hljs-string">'unicode-bidi'</span>, <span class="hljs-string">'unicode-range'</span>, <span class="hljs-string">'units-per-em'</span>, <span class="hljs-string">'v-alphabetic'</span>, <span class="hljs-string">'v-hanging'</span>, <span class="hljs-string">'v-ideographic'</span>, <span class="hljs-string">'v-mathematical'</span>, <span class="hljs-string">'vector-effect'</span>, <span class="hljs-string">'vert-adv-y'</span>, <span class="hljs-string">'vert-origin-x'</span>, <span class="hljs-string">'vert-origin-y'</span>, <span class="hljs-string">'word-spacing'</span>, <span class="hljs-string">'writing-mode'</span>, <span class="hljs-string">'xmlns:xlink'</span>, <span class="hljs-string">'x-height'</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-217" id="section-217"></a>
</div>
<p>you'll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    ].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) </span>{
      <span class="hljs-keyword">var</span> name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// String SVG attributes with the xlink namespace.</span>

    [<span class="hljs-string">'xlink:actuate'</span>, <span class="hljs-string">'xlink:arcrole'</span>, <span class="hljs-string">'xlink:role'</span>, <span class="hljs-string">'xlink:show'</span>, <span class="hljs-string">'xlink:title'</span>, <span class="hljs-string">'xlink:type'</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-218" id="section-218"></a>
</div>
<p>you'll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    ].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) </span>{
      <span class="hljs-keyword">var</span> name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-string">'http://www.w3.org/1999/xlink'</span>, <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// String SVG attributes with the xml namespace.</span>

    [<span class="hljs-string">'xml:base'</span>, <span class="hljs-string">'xml:lang'</span>, <span class="hljs-string">'xml:space'</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-219" id="section-219"></a>
</div>
<p>you'll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    ].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) </span>{
      <span class="hljs-keyword">var</span> name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = <span class="hljs-keyword">new</span> PropertyInfoRecord(name, STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-string">'http://www.w3.org/XML/1998/namespace'</span>, <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These attribute exists both in HTML and SVG.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-220" id="section-220"></a>
</div>
<p>The attribute name is case-sensitive in SVG so we can't just use
the React name like we do for attributes that exist only in HTML.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    [<span class="hljs-string">'tabIndex'</span>, <span class="hljs-string">'crossOrigin'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) </span>{
      properties[attributeName] = <span class="hljs-keyword">new</span> PropertyInfoRecord(attributeName, STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName.toLowerCase(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These attributes accept URLs. These must not allow javascript: URLS.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-221" id="section-221"></a>
</div>
<p>These will also need to accept Trusted Types object in the future.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> xlinkHref = <span class="hljs-string">'xlinkHref'</span>;
    properties[xlinkHref] = <span class="hljs-keyword">new</span> PropertyInfoRecord(<span class="hljs-string">'xlinkHref'</span>, STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
    <span class="hljs-string">'xlink:href'</span>, <span class="hljs-string">'http://www.w3.org/1999/xlink'</span>, <span class="hljs-literal">true</span>);
    [<span class="hljs-string">'src'</span>, <span class="hljs-string">'href'</span>, <span class="hljs-string">'action'</span>, <span class="hljs-string">'formAction'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) </span>{
      properties[attributeName] = <span class="hljs-keyword">new</span> PropertyInfoRecord(attributeName, STRING, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName.toLowerCase(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">true</span>);
    });
    <span class="hljs-keyword">var</span> ReactDebugCurrentFrame = <span class="hljs-literal">null</span>;
    {
      ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    } <span class="hljs-comment">// A javascript: URL can contain leading C0 control or \u0020 SPACE,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-222" id="section-222"></a>
</div>
<p>and any newline or tab are filtered out as if they're not part of the URL.
https://url.spec.whatwg.org/#url-parsing
Tab or newline are defined as \r\n\t:
https://infra.spec.whatwg.org/#ascii-tab-or-newline
A C0 control is a code point in the range \u0000 NULL to \u001F
INFORMATION SEPARATOR ONE, inclusive:
https://infra.spec.whatwg.org/#c0-control-or-space</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-comment">/* eslint-disable max-len */</span>

    <span class="hljs-keyword">var</span> isJavaScriptProtocol = <span class="hljs-regexp">/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i</span>;
    <span class="hljs-keyword">var</span> didWarn = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sanitizeURL</span>(<span class="hljs-params">url</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!didWarn &amp;&amp; isJavaScriptProtocol.test(url)) {
          didWarn = <span class="hljs-literal">true</span>;
          error(<span class="hljs-string">'A future version of React will block javascript: URLs as a security precaution. '</span> + <span class="hljs-string">'Use event handlers instead if you can. If you need to generate unsafe HTML try '</span> + <span class="hljs-string">'using dangerouslySetInnerHTML instead. React was passed %s.'</span>, <span class="hljs-built_in">JSON</span>.stringify(url));
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-223" id="section-223"></a>
</div>
<div class="dox">
<div class="summary">
<p>Get the value for a property on a node. Only used in DEV for SSR validation.
The &quot;expected&quot; argument is used as a hint of what the expected value is.
Some properties have multiple equivalent values.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValueForProperty</span>(<span class="hljs-params">node, name, expected, propertyInfo</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (propertyInfo.mustUseProperty) {
          <span class="hljs-keyword">var</span> propertyName = propertyInfo.propertyName;
          <span class="hljs-keyword">return</span> node[propertyName];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (propertyInfo.sanitizeURL) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-224" id="section-224"></a>
</div>
<p>If we haven't fully disabled javascript: URLs, and if
the hydration is successful of a javascript: URL, we
still want to warn on the client.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            sanitizeURL(<span class="hljs-string">''</span> + expected);
          }

          <span class="hljs-keyword">var</span> attributeName = propertyInfo.attributeName;
          <span class="hljs-keyword">var</span> stringValue = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">if</span> (propertyInfo.type === OVERLOADED_BOOLEAN) {
            <span class="hljs-keyword">if</span> (node.hasAttribute(attributeName)) {
              <span class="hljs-keyword">var</span> value = node.getAttribute(attributeName);

              <span class="hljs-keyword">if</span> (value === <span class="hljs-string">''</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">if</span> (shouldRemoveAttribute(name, expected, propertyInfo, <span class="hljs-literal">false</span>)) {
                <span class="hljs-keyword">return</span> value;
              }

              <span class="hljs-keyword">if</span> (value === <span class="hljs-string">''</span> + expected) {
                <span class="hljs-keyword">return</span> expected;
              }

              <span class="hljs-keyword">return</span> value;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.hasAttribute(attributeName)) {
            <span class="hljs-keyword">if</span> (shouldRemoveAttribute(name, expected, propertyInfo, <span class="hljs-literal">false</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-225" id="section-225"></a>
</div>
<p>We had an attribute but shouldn't have had one, so read it
for the error message.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">return</span> node.getAttribute(attributeName);
            }

            <span class="hljs-keyword">if</span> (propertyInfo.type === BOOLEAN) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-226" id="section-226"></a>
</div>
<p>If this was a boolean, it doesn't matter what the value is
the fact that we have it is the same as the expected.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">return</span> expected;
            } <span class="hljs-comment">// Even if this property uses a namespace we use getAttribute</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-227" id="section-227"></a>
</div>
<p>because we assume its namespaced name is the same as our config.
To use getAttributeNS we need the local name which we don't have
in our config atm.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            stringValue = node.getAttribute(attributeName);
          }

          <span class="hljs-keyword">if</span> (shouldRemoveAttribute(name, expected, propertyInfo, <span class="hljs-literal">false</span>)) {
            <span class="hljs-keyword">return</span> stringValue === <span class="hljs-literal">null</span> ? expected : stringValue;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stringValue === <span class="hljs-string">''</span> + expected) {
            <span class="hljs-keyword">return</span> expected;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> stringValue;
          }
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-228" id="section-228"></a>
</div>
<div class="dox">
<div class="summary">
<p>Get the value for a attribute on a node. Only used in DEV for SSR validation.
The third argument is used as a hint of what the expected value is. Some
attributes have multiple equivalent values.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValueForAttribute</span>(<span class="hljs-params">node, name, expected</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!isAttributeNameSafe(name)) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!node.hasAttribute(name)) {
          <span class="hljs-keyword">return</span> expected === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> value = node.getAttribute(name);

        <span class="hljs-keyword">if</span> (value === <span class="hljs-string">''</span> + expected) {
          <span class="hljs-keyword">return</span> expected;
        }

        <span class="hljs-keyword">return</span> value;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-229" id="section-229"></a>
</div>
<div class="dox">
<div class="summary">
<p>Sets the value for a property on a node.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">name</span>
<span class="dox_type">string</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">value</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValueForProperty</span>(<span class="hljs-params">node, name, value, isCustomComponentTag</span>) </span>{
      <span class="hljs-keyword">var</span> propertyInfo = getPropertyInfo(name);

      <span class="hljs-keyword">if</span> (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
        value = <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// If the prop isn't in the special list, treat it as a simple attribute.</span>


      <span class="hljs-keyword">if</span> (isCustomComponentTag || propertyInfo === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (isAttributeNameSafe(name)) {
          <span class="hljs-keyword">var</span> _attributeName = name;

          <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
            node.removeAttribute(_attributeName);
          } <span class="hljs-keyword">else</span> {
            node.setAttribute(_attributeName, <span class="hljs-string">''</span> + value);
          }
        }

        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> mustUseProperty = propertyInfo.mustUseProperty;

      <span class="hljs-keyword">if</span> (mustUseProperty) {
        <span class="hljs-keyword">var</span> propertyName = propertyInfo.propertyName;

        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> type = propertyInfo.type;
          node[propertyName] = type === BOOLEAN ? <span class="hljs-literal">false</span> : <span class="hljs-string">''</span>;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-230" id="section-230"></a>
</div>
<p>Contrary to <code>setAttribute</code>, object properties are properly
<code>toString</code>ed by IE8/9.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          node[propertyName] = value;
        }

        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// The rest are treated as attributes with special cases.</span>


      <span class="hljs-keyword">var</span> attributeName = propertyInfo.attributeName,
          attributeNamespace = propertyInfo.attributeNamespace;

      <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
        node.removeAttribute(attributeName);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> _type = propertyInfo.type;
        <span class="hljs-keyword">var</span> attributeValue;

        <span class="hljs-keyword">if</span> (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN &amp;&amp; value === <span class="hljs-literal">true</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-231" id="section-231"></a>
</div>
<p>If attribute type is boolean, we know for sure it won't be an execution sink
and we won't require Trusted Type here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          attributeValue = <span class="hljs-string">''</span>;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-232" id="section-232"></a>
</div>
<p><code>setAttribute</code> with objects becomes only <code>[object]</code> in IE8/9,
('' + value) makes it output the correct toString()-value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          {
            attributeValue = <span class="hljs-string">''</span> + value;
          }

          <span class="hljs-keyword">if</span> (propertyInfo.sanitizeURL) {
            sanitizeURL(attributeValue.toString());
          }
        }

        <span class="hljs-keyword">if</span> (attributeNamespace) {
          node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
        } <span class="hljs-keyword">else</span> {
          node.setAttribute(attributeName, attributeValue);
        }
      }
    }

    <span class="hljs-keyword">var</span> BEFORE_SLASH_RE = <span class="hljs-regexp">/^(.*)[\\\/]/</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">describeComponentFrame</span>(<span class="hljs-params">name, source, ownerName</span>) </span>{
      <span class="hljs-keyword">var</span> sourceInfo = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">if</span> (source) {
        <span class="hljs-keyword">var</span> path = source.fileName;
        <span class="hljs-keyword">var</span> fileName = path.replace(BEFORE_SLASH_RE, <span class="hljs-string">''</span>);
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-233" id="section-233"></a>
</div>
<p>In DEV, include code for a common special case:
prefer &quot;folder/index.js&quot; instead of just &quot;index.js&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^index\./</span>.test(fileName)) {
            <span class="hljs-keyword">var</span> match = path.match(BEFORE_SLASH_RE);

            <span class="hljs-keyword">if</span> (match) {
              <span class="hljs-keyword">var</span> pathBeforeSlash = match[<span class="hljs-number">1</span>];

              <span class="hljs-keyword">if</span> (pathBeforeSlash) {
                <span class="hljs-keyword">var</span> folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, <span class="hljs-string">''</span>);
                fileName = folderName + <span class="hljs-string">'/'</span> + fileName;
              }
            }
          }
        }
        sourceInfo = <span class="hljs-string">' (at '</span> + fileName + <span class="hljs-string">':'</span> + source.lineNumber + <span class="hljs-string">')'</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ownerName) {
        sourceInfo = <span class="hljs-string">' (created by '</span> + ownerName + <span class="hljs-string">')'</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">'\n    in '</span> + (name || <span class="hljs-string">'Unknown'</span>) + sourceInfo;
    } <span class="hljs-comment">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-234" id="section-234"></a>
</div>
<p>nor polyfill, then a plain number is used for performance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> hasSymbol = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.for;
    <span class="hljs-keyword">var</span> REACT_ELEMENT_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.element'</span>) : <span class="hljs-number">0xeac7</span>;
    <span class="hljs-keyword">var</span> REACT_PORTAL_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.portal'</span>) : <span class="hljs-number">0xeaca</span>;
    <span class="hljs-keyword">var</span> REACT_FRAGMENT_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.fragment'</span>) : <span class="hljs-number">0xeacb</span>;
    <span class="hljs-keyword">var</span> REACT_STRICT_MODE_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.strict_mode'</span>) : <span class="hljs-number">0xeacc</span>;
    <span class="hljs-keyword">var</span> REACT_PROFILER_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.profiler'</span>) : <span class="hljs-number">0xead2</span>;
    <span class="hljs-keyword">var</span> REACT_PROVIDER_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.provider'</span>) : <span class="hljs-number">0xeacd</span>;
    <span class="hljs-keyword">var</span> REACT_CONTEXT_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.context'</span>) : <span class="hljs-number">0xeace</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> We don't use AsyncMode or ConcurrentMode anymore. They were temporary</span>

    <span class="hljs-keyword">var</span> REACT_CONCURRENT_MODE_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.concurrent_mode'</span>) : <span class="hljs-number">0xeacf</span>;
    <span class="hljs-keyword">var</span> REACT_FORWARD_REF_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.forward_ref'</span>) : <span class="hljs-number">0xead0</span>;
    <span class="hljs-keyword">var</span> REACT_SUSPENSE_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.suspense'</span>) : <span class="hljs-number">0xead1</span>;
    <span class="hljs-keyword">var</span> REACT_SUSPENSE_LIST_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.suspense_list'</span>) : <span class="hljs-number">0xead8</span>;
    <span class="hljs-keyword">var</span> REACT_MEMO_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.memo'</span>) : <span class="hljs-number">0xead3</span>;
    <span class="hljs-keyword">var</span> REACT_LAZY_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.lazy'</span>) : <span class="hljs-number">0xead4</span>;
    <span class="hljs-keyword">var</span> REACT_BLOCK_TYPE = hasSymbol ? <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'react.block'</span>) : <span class="hljs-number">0xead9</span>;
    <span class="hljs-keyword">var</span> MAYBE_ITERATOR_SYMBOL = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.iterator;
    <span class="hljs-keyword">var</span> FAUX_ITERATOR_SYMBOL = <span class="hljs-string">'@@iterator'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIteratorFn</span>(<span class="hljs-params">maybeIterable</span>) </span>{
      <span class="hljs-keyword">if</span> (maybeIterable === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> maybeIterable !== <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> maybeIterator === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> maybeIterator;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> Uninitialized = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">var</span> Pending = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> Resolved = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> Rejected = <span class="hljs-number">2</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refineResolvedLazyComponent</span>(<span class="hljs-params">lazyComponent</span>) </span>{
      <span class="hljs-keyword">return</span> lazyComponent._status === Resolved ? lazyComponent._result : <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeLazyComponentType</span>(<span class="hljs-params">lazyComponent</span>) </span>{
      <span class="hljs-keyword">if</span> (lazyComponent._status === Uninitialized) {
        lazyComponent._status = Pending;
        <span class="hljs-keyword">var</span> ctor = lazyComponent._ctor;
        <span class="hljs-keyword">var</span> thenable = ctor();
        lazyComponent._result = thenable;
        thenable.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">moduleObject</span>) </span>{
          <span class="hljs-keyword">if</span> (lazyComponent._status === Pending) {
            <span class="hljs-keyword">var</span> defaultExport = moduleObject.default;
            {
              <span class="hljs-keyword">if</span> (defaultExport === <span class="hljs-literal">undefined</span>) {
                error(<span class="hljs-string">'lazy: Expected the result of a dynamic import() call. '</span> + <span class="hljs-string">'Instead received: %s\n\nYour code should look like: \n  '</span> + <span class="hljs-string">"const MyComponent = lazy(() =&gt; import('./MyComponent'))"</span>, moduleObject);
              }
            }
            lazyComponent._status = Resolved;
            lazyComponent._result = defaultExport;
          }
        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
          <span class="hljs-keyword">if</span> (lazyComponent._status === Pending) {
            lazyComponent._status = Rejected;
            lazyComponent._result = error;
          }
        });
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWrappedName</span>(<span class="hljs-params">outerType, innerType, wrapperName</span>) </span>{
      <span class="hljs-keyword">var</span> functionName = innerType.displayName || innerType.name || <span class="hljs-string">''</span>;
      <span class="hljs-keyword">return</span> outerType.displayName || (functionName !== <span class="hljs-string">''</span> ? wrapperName + <span class="hljs-string">"("</span> + functionName + <span class="hljs-string">")"</span> : wrapperName);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getComponentName</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-235" id="section-235"></a>
</div>
<p>Host root, text node or just invalid type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type.tag === <span class="hljs-string">'number'</span>) {
          error(<span class="hljs-string">'Received an unexpected object in getComponentName(). '</span> + <span class="hljs-string">'This is likely a bug in React. Please file an issue.'</span>);
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> type.displayName || type.name || <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'string'</span>) {
        <span class="hljs-keyword">return</span> type;
      }

      <span class="hljs-keyword">switch</span> (type) {
        <span class="hljs-keyword">case</span> REACT_FRAGMENT_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'Fragment'</span>;

        <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'Portal'</span>;

        <span class="hljs-keyword">case</span> REACT_PROFILER_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">"Profiler"</span>;

        <span class="hljs-keyword">case</span> REACT_STRICT_MODE_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'StrictMode'</span>;

        <span class="hljs-keyword">case</span> REACT_SUSPENSE_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'Suspense'</span>;

        <span class="hljs-keyword">case</span> REACT_SUSPENSE_LIST_TYPE:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'SuspenseList'</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">switch</span> (type.$$<span class="hljs-keyword">typeof</span>) {
          <span class="hljs-keyword">case</span> REACT_CONTEXT_TYPE:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'Context.Consumer'</span>;

          <span class="hljs-keyword">case</span> REACT_PROVIDER_TYPE:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'Context.Provider'</span>;

          <span class="hljs-keyword">case</span> REACT_FORWARD_REF_TYPE:
            <span class="hljs-keyword">return</span> getWrappedName(type, type.render, <span class="hljs-string">'ForwardRef'</span>);

          <span class="hljs-keyword">case</span> REACT_MEMO_TYPE:
            <span class="hljs-keyword">return</span> getComponentName(type.type);

          <span class="hljs-keyword">case</span> REACT_BLOCK_TYPE:
            <span class="hljs-keyword">return</span> getComponentName(type.render);

          <span class="hljs-keyword">case</span> REACT_LAZY_TYPE:
            {
              <span class="hljs-keyword">var</span> thenable = type;
              <span class="hljs-keyword">var</span> resolvedThenable = refineResolvedLazyComponent(thenable);

              <span class="hljs-keyword">if</span> (resolvedThenable) {
                <span class="hljs-keyword">return</span> getComponentName(resolvedThenable);
              }

              <span class="hljs-keyword">break</span>;
            }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> ReactDebugCurrentFrame$<span class="hljs-number">1</span> = ReactSharedInternals.ReactDebugCurrentFrame;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">describeFiber</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">switch</span> (fiber.tag) {
        <span class="hljs-keyword">case</span> HostRoot:
        <span class="hljs-keyword">case</span> HostPortal:
        <span class="hljs-keyword">case</span> HostText:
        <span class="hljs-keyword">case</span> Fragment:
        <span class="hljs-keyword">case</span> ContextProvider:
        <span class="hljs-keyword">case</span> ContextConsumer:
          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">var</span> owner = fiber._debugOwner;
          <span class="hljs-keyword">var</span> source = fiber._debugSource;
          <span class="hljs-keyword">var</span> name = getComponentName(fiber.type);
          <span class="hljs-keyword">var</span> ownerName = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">if</span> (owner) {
            ownerName = getComponentName(owner.type);
          }

          <span class="hljs-keyword">return</span> describeComponentFrame(name, source, ownerName);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStackByFiberInDevAndProd</span>(<span class="hljs-params">workInProgress</span>) </span>{
      <span class="hljs-keyword">var</span> info = <span class="hljs-string">''</span>;
      <span class="hljs-keyword">var</span> node = workInProgress;

      <span class="hljs-keyword">do</span> {
        info += describeFiber(node);
        node = node.return;
      } <span class="hljs-keyword">while</span> (node);

      <span class="hljs-keyword">return</span> info;
    }

    <span class="hljs-keyword">var</span> current = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> isRendering = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrentFiberOwnerNameInDevOrNull</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> owner = current._debugOwner;

        <span class="hljs-keyword">if</span> (owner !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> owner !== <span class="hljs-string">'undefined'</span>) {
          <span class="hljs-keyword">return</span> getComponentName(owner.type);
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrentFiberStackInDev</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
        } <span class="hljs-comment">// Safe because if current fiber exists, we are reconciling,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-236" id="section-236"></a>
</div>
<p>and it is guaranteed to be the work-in-progress version.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">return</span> getStackByFiberInDevAndProd(current);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetCurrentFiber</span>(<span class="hljs-params"></span>) </span>{
      {
        ReactDebugCurrentFrame$<span class="hljs-number">1.</span>getCurrentStack = <span class="hljs-literal">null</span>;
        current = <span class="hljs-literal">null</span>;
        isRendering = <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCurrentFiber</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        ReactDebugCurrentFrame$<span class="hljs-number">1.</span>getCurrentStack = getCurrentFiberStackInDev;
        current = fiber;
        isRendering = <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setIsRendering</span>(<span class="hljs-params">rendering</span>) </span>{
      {
        isRendering = rendering;
      }
    } <span class="hljs-comment">// Flow does not allow string concatenation of most non-string types. To work</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-237" id="section-237"></a>
</div>
<p>around this limitation, we use an opaque type that can only be obtained by
passing the value through getToStringValue first.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + value;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getToStringValue</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> value) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'boolean'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'undefined'</span>:
          <span class="hljs-keyword">return</span> value;

        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-238" id="section-238"></a>
</div>
<p>function, symbol are assigned as empty strings</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
    }

    <span class="hljs-keyword">var</span> ReactDebugCurrentFrame$<span class="hljs-number">2</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> ReactControlledValuePropTypes = {
      <span class="hljs-attr">checkPropTypes</span>: <span class="hljs-literal">null</span>
    };
    {
      ReactDebugCurrentFrame$<span class="hljs-number">2</span> = ReactSharedInternals.ReactDebugCurrentFrame;
      <span class="hljs-keyword">var</span> hasReadOnlyValue = {
        <span class="hljs-attr">button</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">checkbox</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">image</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">radio</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">reset</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">submit</span>: <span class="hljs-literal">true</span>
      };
      <span class="hljs-keyword">var</span> propTypes = {
        <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">props, propName, componentName</span>) </span>{
          <span class="hljs-keyword">if</span> (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == <span class="hljs-literal">null</span> || enableDeprecatedFlareAPI) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'You provided a `value` prop to a form field without an '</span> + <span class="hljs-string">'`onChange` handler. This will render a read-only field. If '</span> + <span class="hljs-string">'the field should be mutable use `defaultValue`. Otherwise, '</span> + <span class="hljs-string">'set either `onChange` or `readOnly`.'</span>);
        },
        <span class="hljs-attr">checked</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">props, propName, componentName</span>) </span>{
          <span class="hljs-keyword">if</span> (props.onChange || props.readOnly || props.disabled || props[propName] == <span class="hljs-literal">null</span> || enableDeprecatedFlareAPI) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'You provided a `checked` prop to a form field without an '</span> + <span class="hljs-string">'`onChange` handler. This will render a read-only field. If '</span> + <span class="hljs-string">'the field should be mutable use `defaultChecked`. Otherwise, '</span> + <span class="hljs-string">'set either `onChange` or `readOnly`.'</span>);
        }
      };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-239" id="section-239"></a>
</div>
<div class="dox">
<div class="summary">
<p>Provide a linked <code>value</code> attribute for controlled forms. You should not use
this outside of the ReactDOM controlled form components.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      ReactControlledValuePropTypes.checkPropTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tagName, props</span>) </span>{
        checkPropTypes(propTypes, props, <span class="hljs-string">'prop'</span>, tagName, ReactDebugCurrentFrame$<span class="hljs-number">2.</span>getStackAddendum);
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCheckable</span>(<span class="hljs-params">elem</span>) </span>{
      <span class="hljs-keyword">var</span> type = elem.type;
      <span class="hljs-keyword">var</span> nodeName = elem.nodeName;
      <span class="hljs-keyword">return</span> nodeName &amp;&amp; nodeName.toLowerCase() === <span class="hljs-string">'input'</span> &amp;&amp; (type === <span class="hljs-string">'checkbox'</span> || type === <span class="hljs-string">'radio'</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTracker</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node._valueTracker;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detachTracker</span>(<span class="hljs-params">node</span>) </span>{
      node._valueTracker = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValueFromNode</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> value = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">if</span> (!node) {
        <span class="hljs-keyword">return</span> value;
      }

      <span class="hljs-keyword">if</span> (isCheckable(node)) {
        value = node.checked ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>;
      } <span class="hljs-keyword">else</span> {
        value = node.value;
      }

      <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trackValueOnNode</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> valueField = isCheckable(node) ? <span class="hljs-string">'checked'</span> : <span class="hljs-string">'value'</span>;
      <span class="hljs-keyword">var</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
      <span class="hljs-keyword">var</span> currentValue = <span class="hljs-string">''</span> + node[valueField]; <span class="hljs-comment">// if someone has already defined a value or Safari, then bail</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-240" id="section-240"></a>
</div>
<p>and don't track value will cause over reporting of changes,
but it's better then a hard failure
(needed for certain tests that spyOn input values and Safari)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (node.hasOwnProperty(valueField) || <span class="hljs-keyword">typeof</span> descriptor === <span class="hljs-string">'undefined'</span> || <span class="hljs-keyword">typeof</span> descriptor.get !== <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> descriptor.set !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> <span class="hljs-keyword">get</span> = descriptor.<span class="hljs-keyword">get</span>,
          <span class="hljs-keyword">set</span> = descriptor.<span class="hljs-keyword">set</span>;
      Object.defineProperty(node, valueField, {
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>.call(this);
        },
        <span class="hljs-keyword">set</span>: function (value) {
          currentValue = <span class="hljs-string">''</span> + value;
          <span class="hljs-keyword">set</span>.call(this, value);
        }
      }); // We could've passed this the first time
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-241" id="section-241"></a>
</div>
<p>but it triggers a bug in IE11 and Edge 14/15.
Calling defineProperty() again should be equivalent.
https://github.com/facebook/react/issues/11768</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-built_in">Object</span>.defineProperty(node, valueField, {
        <span class="hljs-attr">enumerable</span>: descriptor.enumerable
      });
      <span class="hljs-keyword">var</span> tracker = {
        <span class="hljs-attr">getValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> currentValue;
        },
        <span class="hljs-attr">setValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
          currentValue = <span class="hljs-string">''</span> + value;
        },
        <span class="hljs-attr">stopTracking</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          detachTracker(node);
          <span class="hljs-keyword">delete</span> node[valueField];
        }
      };
      <span class="hljs-keyword">return</span> tracker;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">track</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (getTracker(node)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Once it's just Fiber we can move this to node._wrapperState</span>


      node._valueTracker = trackValueOnNode(node);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateValueIfChanged</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (!node) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> tracker = getTracker(node); <span class="hljs-comment">// if there is no tracker at this point it's unlikely</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-242" id="section-242"></a>
</div>
<p>that trying again will succeed</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (!tracker) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">var</span> lastValue = tracker.getValue();
      <span class="hljs-keyword">var</span> nextValue = getValueFromNode(node);

      <span class="hljs-keyword">if</span> (nextValue !== lastValue) {
        tracker.setValue(nextValue);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> didWarnValueDefaultValue = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didWarnCheckedDefaultChecked = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didWarnControlledToUncontrolled = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didWarnUncontrolledToControlled = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isControlled</span>(<span class="hljs-params">props</span>) </span>{
      <span class="hljs-keyword">var</span> usesChecked = props.type === <span class="hljs-string">'checkbox'</span> || props.type === <span class="hljs-string">'radio'</span>;
      <span class="hljs-keyword">return</span> usesChecked ? props.checked != <span class="hljs-literal">null</span> : props.value != <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-243" id="section-243"></a>
</div>
<div class="dox">
<div class="summary">
<p>Implements an <input> host component that allows setting these optional
props: <code>checked</code>, <code>value</code>, <code>defaultChecked</code>, and <code>defaultValue</code>.</p>
</div>
<div class="body">
<p>If <code>checked</code> or <code>value</code> are not supplied (or null/undefined), user actions
that affect the checked state or value will trigger updates to the element.</p>
<p>If they are supplied (and not null/undefined), the rendered element will not
trigger updates to the element. Instead, the props must change in order for
the rendered element to be updated.</p>
<p>The rendered element will be initialized as unchecked (or <code>defaultChecked</code>)
with an empty value (or <code>defaultValue</code>).</p>
<p>See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHostProps</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      <span class="hljs-keyword">var</span> checked = props.checked;

      <span class="hljs-keyword">var</span> hostProps = _assign({}, props, {
        <span class="hljs-attr">defaultChecked</span>: <span class="hljs-literal">undefined</span>,
        <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">undefined</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,
        <span class="hljs-attr">checked</span>: checked != <span class="hljs-literal">null</span> ? checked : node._wrapperState.initialChecked
      });

      <span class="hljs-keyword">return</span> hostProps;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initWrapperState</span>(<span class="hljs-params">element, props</span>) </span>{
      {
        ReactControlledValuePropTypes.checkPropTypes(<span class="hljs-string">'input'</span>, props);

        <span class="hljs-keyword">if</span> (props.checked !== <span class="hljs-literal">undefined</span> &amp;&amp; props.defaultChecked !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnCheckedDefaultChecked) {
          error(<span class="hljs-string">'%s contains an input of type %s with both checked and defaultChecked props. '</span> + <span class="hljs-string">'Input elements must be either controlled or uncontrolled '</span> + <span class="hljs-string">'(specify either the checked prop, or the defaultChecked prop, but not '</span> + <span class="hljs-string">'both). Decide between using a controlled or uncontrolled input '</span> + <span class="hljs-string">'element and remove one of these props. More info: '</span> + <span class="hljs-string">'https://fb.me/react-controlled-components'</span>, getCurrentFiberOwnerNameInDevOrNull() || <span class="hljs-string">'A component'</span>, props.type);
          didWarnCheckedDefaultChecked = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (props.value !== <span class="hljs-literal">undefined</span> &amp;&amp; props.defaultValue !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnValueDefaultValue) {
          error(<span class="hljs-string">'%s contains an input of type %s with both value and defaultValue props. '</span> + <span class="hljs-string">'Input elements must be either controlled or uncontrolled '</span> + <span class="hljs-string">'(specify either the value prop, or the defaultValue prop, but not '</span> + <span class="hljs-string">'both). Decide between using a controlled or uncontrolled input '</span> + <span class="hljs-string">'element and remove one of these props. More info: '</span> + <span class="hljs-string">'https://fb.me/react-controlled-components'</span>, getCurrentFiberOwnerNameInDevOrNull() || <span class="hljs-string">'A component'</span>, props.type);
          didWarnValueDefaultValue = <span class="hljs-literal">true</span>;
        }
      }
      <span class="hljs-keyword">var</span> node = element;
      <span class="hljs-keyword">var</span> defaultValue = props.defaultValue == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : props.defaultValue;
      node._wrapperState = {
        <span class="hljs-attr">initialChecked</span>: props.checked != <span class="hljs-literal">null</span> ? props.checked : props.defaultChecked,
        <span class="hljs-attr">initialValue</span>: getToStringValue(props.value != <span class="hljs-literal">null</span> ? props.value : defaultValue),
        <span class="hljs-attr">controlled</span>: isControlled(props)
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateChecked</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      <span class="hljs-keyword">var</span> checked = props.checked;

      <span class="hljs-keyword">if</span> (checked != <span class="hljs-literal">null</span>) {
        setValueForProperty(node, <span class="hljs-string">'checked'</span>, checked, <span class="hljs-literal">false</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateWrapper</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      {
        <span class="hljs-keyword">var</span> controlled = isControlled(props);

        <span class="hljs-keyword">if</span> (!node._wrapperState.controlled &amp;&amp; controlled &amp;&amp; !didWarnUncontrolledToControlled) {
          error(<span class="hljs-string">'A component is changing an uncontrolled input of type %s to be controlled. '</span> + <span class="hljs-string">'Input elements should not switch from uncontrolled to controlled (or vice versa). '</span> + <span class="hljs-string">'Decide between using a controlled or uncontrolled input '</span> + <span class="hljs-string">'element for the lifetime of the component. More info: https://fb.me/react-controlled-components'</span>, props.type);
          didWarnUncontrolledToControlled = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (node._wrapperState.controlled &amp;&amp; !controlled &amp;&amp; !didWarnControlledToUncontrolled) {
          error(<span class="hljs-string">'A component is changing a controlled input of type %s to be uncontrolled. '</span> + <span class="hljs-string">'Input elements should not switch from controlled to uncontrolled (or vice versa). '</span> + <span class="hljs-string">'Decide between using a controlled or uncontrolled input '</span> + <span class="hljs-string">'element for the lifetime of the component. More info: https://fb.me/react-controlled-components'</span>, props.type);
          didWarnControlledToUncontrolled = <span class="hljs-literal">true</span>;
        }
      }
      updateChecked(element, props);
      <span class="hljs-keyword">var</span> value = getToStringValue(props.value);
      <span class="hljs-keyword">var</span> type = props.type;

      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'number'</span>) {
          <span class="hljs-keyword">if</span> (value === <span class="hljs-number">0</span> &amp;&amp; node.value === <span class="hljs-string">''</span> || <span class="hljs-comment">// We explicitly want to coerce to number here if possible.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-244" id="section-244"></a>
</div>
<p>eslint-disable-next-line</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          node.value != value) {
            node.value = toString(value);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.value !== toString(value)) {
          node.value = toString(value);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'submit'</span> || type === <span class="hljs-string">'reset'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-245" id="section-245"></a>
</div>
<p>Submit/reset inputs need the attribute removed completely to avoid
blank-text buttons.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        node.removeAttribute(<span class="hljs-string">'value'</span>);
        <span class="hljs-keyword">return</span>;
      }

      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-246" id="section-246"></a>
</div>
<p>When syncing the value attribute, the value comes from a cascade of
properties:</p>
<ol>
<li>The value React property</li>
<li>The defaultValue React property</li>
<li>Otherwise there should be no change</li>
</ol>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (props.hasOwnProperty(<span class="hljs-string">'value'</span>)) {
          setDefaultValue(node, props.type, value);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (props.hasOwnProperty(<span class="hljs-string">'defaultValue'</span>)) {
          setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
        }
      }
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-247" id="section-247"></a>
</div>
<p>When syncing the checked attribute, it only changes when it needs
to be removed, such as transitioning from a checkbox into a text input</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (props.checked == <span class="hljs-literal">null</span> &amp;&amp; props.defaultChecked != <span class="hljs-literal">null</span>) {
          node.defaultChecked = !!props.defaultChecked;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postMountWrapper</span>(<span class="hljs-params">element, props, isHydrating</span>) </span>{
      <span class="hljs-keyword">var</span> node = element; <span class="hljs-comment">// Do not assign value if it is already set. This prevents user text input</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-248" id="section-248"></a>
</div>
<p>from being lost during SSR hydration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (props.hasOwnProperty(<span class="hljs-string">'value'</span>) || props.hasOwnProperty(<span class="hljs-string">'defaultValue'</span>)) {
        <span class="hljs-keyword">var</span> type = props.type;
        <span class="hljs-keyword">var</span> isButton = type === <span class="hljs-string">'submit'</span> || type === <span class="hljs-string">'reset'</span>; <span class="hljs-comment">// Avoid setting value attribute on submit/reset inputs as it overrides the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-249" id="section-249"></a>
</div>
<p>default value provided by the browser. See: #12872</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (isButton &amp;&amp; (props.value === <span class="hljs-literal">undefined</span> || props.value === <span class="hljs-literal">null</span>)) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> initialValue = toString(node._wrapperState.initialValue); <span class="hljs-comment">// Do not assign value if it is already set. This prevents user text input</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-250" id="section-250"></a>
</div>
<p>from being lost during SSR hydration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (!isHydrating) {
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-251" id="section-251"></a>
</div>
<p>When syncing the value attribute, the value property should use
the wrapperState._initialValue property. This uses:</p>
<ol>
<li>The value React property when present</li>
<li>The defaultValue React property when present</li>
<li>An empty string</li>
</ol>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (initialValue !== node.value) {
              node.value = initialValue;
            }
          }
        }

        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-252" id="section-252"></a>
</div>
<p>Otherwise, the value attribute is synchronized to the property,
so we assign defaultValue to the same thing as the value property
assignment step above.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          node.defaultValue = initialValue;
        }
      } <span class="hljs-comment">// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-253" id="section-253"></a>
</div>
<p>this is needed to work around a chrome bug where setting defaultChecked
will sometimes influence the value of checked (even after detachment).
Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
We need to temporarily unset name to avoid disrupting radio button groups.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> name = node.name;

      <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">''</span>) {
        node.name = <span class="hljs-string">''</span>;
      }

      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-254" id="section-254"></a>
</div>
<p>When syncing the checked attribute, both the checked property and
attribute are assigned at the same time using defaultChecked. This uses:</p>
<ol>
<li>The checked React property when present</li>
<li>The defaultChecked React property when present</li>
<li>Otherwise, false</li>
</ol>

        </td>
        <td class="code highlight">
          <pre class="javascript">        node.defaultChecked = !node.defaultChecked;
        node.defaultChecked = !!node._wrapperState.initialChecked;
      }

      <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">''</span>) {
        node.name = name;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreControlledState</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      updateWrapper(node, props);
      updateNamedCousins(node, props);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateNamedCousins</span>(<span class="hljs-params">rootNode, props</span>) </span>{
      <span class="hljs-keyword">var</span> name = props.name;

      <span class="hljs-keyword">if</span> (props.type === <span class="hljs-string">'radio'</span> &amp;&amp; name != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> queryRoot = rootNode;

        <span class="hljs-keyword">while</span> (queryRoot.parentNode) {
          queryRoot = queryRoot.parentNode;
        } <span class="hljs-comment">// If `rootNode.form` was non-null, then we could try `form.elements`,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-255" id="section-255"></a>
</div>
<p>but that sometimes behaves strangely in IE8. We could also try using
<code>form.getElementsByName</code>, but that will only return direct children
and won't include inputs that use the HTML5 <code>form=</code> attribute. Since
the input might not even be in a form. It might not even be in the
document. Let's just use the local <code>querySelectorAll</code> to ensure we don't
miss anything.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">var</span> group = queryRoot.querySelectorAll(<span class="hljs-string">'input[name='</span> + <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">''</span> + name) + <span class="hljs-string">'][type="radio"]'</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; group.length; i++) {
          <span class="hljs-keyword">var</span> otherNode = group[i];

          <span class="hljs-keyword">if</span> (otherNode === rootNode || otherNode.form !== rootNode.form) {
            <span class="hljs-keyword">continue</span>;
          } <span class="hljs-comment">// This will throw if radio buttons rendered by different copies of React</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-256" id="section-256"></a>
</div>
<p>and the same name are rendered into the same form (same as #1939).
That's probably okay; we don't support it just as we don't support
mixing React radio buttons with non-React ones.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          <span class="hljs-keyword">var</span> otherProps = getFiberCurrentPropsFromNode$<span class="hljs-number">1</span>(otherNode);

          <span class="hljs-keyword">if</span> (!otherProps) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."</span>);
            }
          } <span class="hljs-comment">// We need update the tracked value on the named cousin since the value</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-257" id="section-257"></a>
</div>
<p>was changed but the input saw no event or value set</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          updateValueIfChanged(otherNode); <span class="hljs-comment">// If this is a controlled radio button group, forcing the input that</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-258" id="section-258"></a>
</div>
<p>was previously checked to update will cause it to be come re-checked
as appropriate.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          updateWrapper(otherNode, otherProps);
        }
      }
    } <span class="hljs-comment">// In Chrome, assigning defaultValue to certain input types triggers input validation.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-259" id="section-259"></a>
</div>
<p>For number inputs, the display value loses trailing decimal points. For email inputs,
Chrome raises &quot;The specified value <x> is not a valid email address&quot;.</p>
<p>Here we check to see if the defaultValue has actually changed, avoiding these problems
when the user is inputting text</p>
<p>https://github.com/facebook/react/issues/7253</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDefaultValue</span>(<span class="hljs-params">node, type, value</span>) </span>{
      <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Focused number inputs synchronize on blur. See ChangeEventPlugin.js</span>
      type !== <span class="hljs-string">'number'</span> || node.ownerDocument.activeElement !== node) {
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
          node.defaultValue = toString(node._wrapperState.initialValue);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.defaultValue !== toString(value)) {
          node.defaultValue = toString(value);
        }
      }
    }

    <span class="hljs-keyword">var</span> didWarnSelectedSetOnOption = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didWarnInvalidChild = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenChildren</span>(<span class="hljs-params">children</span>) </span>{
      <span class="hljs-keyword">var</span> content = <span class="hljs-string">''</span>; <span class="hljs-comment">// Flatten children. We'll warn if they are invalid</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-260" id="section-260"></a>
</div>
<p>during validateProps() which runs for hydration too.
Note that this would throw on non-element objects.
Elements are stringified (which is normally irrelevant
but matters for <fbt>).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      React.Children.forEach(children, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
        <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span>;
        }

        content += child; <span class="hljs-comment">// Note: we don't warn about invalid children here.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-261" id="section-261"></a>
</div>
<p>Instead, this is done separately below so that
it happens during the hydration codepath too.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      });
      <span class="hljs-keyword">return</span> content;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-262" id="section-262"></a>
</div>
<div class="dox">
<div class="summary">
<p>Implements an <option> host component that warns when <code>selected</code> is set.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateProps</span>(<span class="hljs-params">element, props</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-263" id="section-263"></a>
</div>
<p>This mirrors the codepath above, but runs for hydration too.
Warn about invalid children here so that client and hydration are consistent.
TODO: this seems like it could cause a DEV-only throw for hydration
if children contains a non-element object. We should try to avoid that.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">'object'</span> &amp;&amp; props.children !== <span class="hljs-literal">null</span>) {
          React.Children.forEach(props.children, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
            <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> child === <span class="hljs-string">'number'</span>) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child.type !== <span class="hljs-string">'string'</span>) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (!didWarnInvalidChild) {
              didWarnInvalidChild = <span class="hljs-literal">true</span>;
              error(<span class="hljs-string">'Only strings and numbers are supported as &lt;option&gt; children.'</span>);
            }
          });
        } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove support for `selected` in &lt;option&gt;.</span>


        <span class="hljs-keyword">if</span> (props.selected != <span class="hljs-literal">null</span> &amp;&amp; !didWarnSelectedSetOnOption) {
          error(<span class="hljs-string">'Use the `defaultValue` or `value` props on &lt;select&gt; instead of '</span> + <span class="hljs-string">'setting `selected` on &lt;option&gt;.'</span>);
          didWarnSelectedSetOnOption = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postMountWrapper$1</span>(<span class="hljs-params">element, props</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-264" id="section-264"></a>
</div>
<p>value=&quot;&quot; should make a value attribute (#6219)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (props.value != <span class="hljs-literal">null</span>) {
        element.setAttribute(<span class="hljs-string">'value'</span>, toString(getToStringValue(props.value)));
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHostProps$1</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> hostProps = _assign({
        <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>
      }, props);

      <span class="hljs-keyword">var</span> content = flattenChildren(props.children);

      <span class="hljs-keyword">if</span> (content) {
        hostProps.children = content;
      }

      <span class="hljs-keyword">return</span> hostProps;
    }

    <span class="hljs-keyword">var</span> didWarnValueDefaultValue$<span class="hljs-number">1</span>;
    {
      didWarnValueDefaultValue$<span class="hljs-number">1</span> = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDeclarationErrorAddendum</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> ownerName = getCurrentFiberOwnerNameInDevOrNull();

      <span class="hljs-keyword">if</span> (ownerName) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'\n\nCheck the render method of `'</span> + ownerName + <span class="hljs-string">'`.'</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }

    <span class="hljs-keyword">var</span> valuePropNames = [<span class="hljs-string">'value'</span>, <span class="hljs-string">'defaultValue'</span>];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-265" id="section-265"></a>
</div>
<div class="dox">
<div class="summary">
<p>Validation function for <code>value</code> and <code>defaultValue</code>.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSelectPropTypes</span>(<span class="hljs-params">props</span>) </span>{
      {
        ReactControlledValuePropTypes.checkPropTypes(<span class="hljs-string">'select'</span>, props);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; valuePropNames.length; i++) {
          <span class="hljs-keyword">var</span> propName = valuePropNames[i];

          <span class="hljs-keyword">if</span> (props[propName] == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray(props[propName]);

          <span class="hljs-keyword">if</span> (props.multiple &amp;&amp; !isArray) {
            error(<span class="hljs-string">'The `%s` prop supplied to &lt;select&gt; must be an array if '</span> + <span class="hljs-string">'`multiple` is true.%s'</span>, propName, getDeclarationErrorAddendum());
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!props.multiple &amp;&amp; isArray) {
            error(<span class="hljs-string">'The `%s` prop supplied to &lt;select&gt; must be a scalar '</span> + <span class="hljs-string">'value if `multiple` is false.%s'</span>, propName, getDeclarationErrorAddendum());
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateOptions</span>(<span class="hljs-params">node, multiple, propValue, setDefaultSelected</span>) </span>{
      <span class="hljs-keyword">var</span> options = node.options;

      <span class="hljs-keyword">if</span> (multiple) {
        <span class="hljs-keyword">var</span> selectedValues = propValue;
        <span class="hljs-keyword">var</span> selectedValue = {};

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; selectedValues.length; i++) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-266" id="section-266"></a>
</div>
<p>Prefix to avoid chaos with special keys.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          selectedValue[<span class="hljs-string">'$'</span> + selectedValues[i]] = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; options.length; _i++) {
          <span class="hljs-keyword">var</span> selected = selectedValue.hasOwnProperty(<span class="hljs-string">'$'</span> + options[_i].value);

          <span class="hljs-keyword">if</span> (options[_i].selected !== selected) {
            options[_i].selected = selected;
          }

          <span class="hljs-keyword">if</span> (selected &amp;&amp; setDefaultSelected) {
            options[_i].defaultSelected = <span class="hljs-literal">true</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-267" id="section-267"></a>
</div>
<p>Do not set <code>select.value</code> as exact behavior isn't consistent across all
browsers for all cases.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> _selectedValue = toString(getToStringValue(propValue));

        <span class="hljs-keyword">var</span> defaultSelected = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i2 = <span class="hljs-number">0</span>; _i2 &lt; options.length; _i2++) {
          <span class="hljs-keyword">if</span> (options[_i2].value === _selectedValue) {
            options[_i2].selected = <span class="hljs-literal">true</span>;

            <span class="hljs-keyword">if</span> (setDefaultSelected) {
              options[_i2].defaultSelected = <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (defaultSelected === <span class="hljs-literal">null</span> &amp;&amp; !options[_i2].disabled) {
            defaultSelected = options[_i2];
          }
        }

        <span class="hljs-keyword">if</span> (defaultSelected !== <span class="hljs-literal">null</span>) {
          defaultSelected.selected = <span class="hljs-literal">true</span>;
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-268" id="section-268"></a>
</div>
<div class="dox">
<div class="summary">
<p>Implements a <select> host component that allows optionally setting the
props <code>value</code> and <code>defaultValue</code>. If <code>multiple</code> is false, the prop must be a
stringable. If <code>multiple</code> is true, the prop must be an array of stringables.</p>
</div>
<div class="body">
<p>If <code>value</code> is not supplied (or null/undefined), user actions that change the
selected option will trigger updates to the rendered options.</p>
<p>If it is supplied (and not null/undefined), the rendered options will not
update in response to user actions. Instead, the <code>value</code> prop must change in
order for the rendered options to update.</p>
<p>If <code>defaultValue</code> is provided, any options with the supplied values will be
selected.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHostProps$2</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">return</span> _assign({}, props, {
        <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initWrapperState$1</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      {
        checkSelectPropTypes(props);
      }
      node._wrapperState = {
        <span class="hljs-attr">wasMultiple</span>: !!props.multiple
      };
      {
        <span class="hljs-keyword">if</span> (props.value !== <span class="hljs-literal">undefined</span> &amp;&amp; props.defaultValue !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnValueDefaultValue$<span class="hljs-number">1</span>) {
          error(<span class="hljs-string">'Select elements must be either controlled or uncontrolled '</span> + <span class="hljs-string">'(specify either the value prop, or the defaultValue prop, but not '</span> + <span class="hljs-string">'both). Decide between using a controlled or uncontrolled select '</span> + <span class="hljs-string">'element and remove one of these props. More info: '</span> + <span class="hljs-string">'https://fb.me/react-controlled-components'</span>);
          didWarnValueDefaultValue$<span class="hljs-number">1</span> = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postMountWrapper$2</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      node.multiple = !!props.multiple;
      <span class="hljs-keyword">var</span> value = props.value;

      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
        updateOptions(node, !!props.multiple, value, <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (props.defaultValue != <span class="hljs-literal">null</span>) {
        updateOptions(node, !!props.multiple, props.defaultValue, <span class="hljs-literal">true</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postUpdateWrapper</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      <span class="hljs-keyword">var</span> wasMultiple = node._wrapperState.wasMultiple;
      node._wrapperState.wasMultiple = !!props.multiple;
      <span class="hljs-keyword">var</span> value = props.value;

      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
        updateOptions(node, !!props.multiple, value, <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wasMultiple !== !!props.multiple) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-269" id="section-269"></a>
</div>
<p>For simplicity, reapply <code>defaultValue</code> if <code>multiple</code> is toggled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (props.defaultValue != <span class="hljs-literal">null</span>) {
          updateOptions(node, !!props.multiple, props.defaultValue, <span class="hljs-literal">true</span>);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-270" id="section-270"></a>
</div>
<p>Revert the select back to its default unselected state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          updateOptions(node, !!props.multiple, props.multiple ? [] : <span class="hljs-string">''</span>, <span class="hljs-literal">false</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreControlledState$1</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      <span class="hljs-keyword">var</span> value = props.value;

      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
        updateOptions(node, !!props.multiple, value, <span class="hljs-literal">false</span>);
      }
    }

    <span class="hljs-keyword">var</span> didWarnValDefaultVal = <span class="hljs-literal">false</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-271" id="section-271"></a>
</div>
<div class="dox">
<div class="summary">
<p>Implements a <textarea> host component that allows setting <code>value</code>, and
<code>defaultValue</code>. This differs from the traditional DOM API because value is
usually set as PCDATA children.</p>
</div>
<div class="body">
<p>If <code>value</code> is not supplied (or null/undefined), user actions that affect the
value will trigger updates to the element.</p>
<p>If <code>value</code> is supplied (and not null/undefined), the rendered element will
not trigger updates to the element. Instead, the <code>value</code> prop must change in
order for the rendered element to be updated.</p>
<p>The rendered element will be initialized with an empty value, the prop
<code>defaultValue</code> if specified, or the children content (deprecated).</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHostProps$3</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;

      <span class="hljs-keyword">if</span> (!(props.dangerouslySetInnerHTML == <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"`dangerouslySetInnerHTML` does not make sense on &lt;textarea&gt;."</span>);
        }
      } <span class="hljs-comment">// Always set children to the same thing. In IE9, the selection range will</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-272" id="section-272"></a>
</div>
<p>get reset if <code>textContent</code> is mutated.  We could add a check in setTextContent
to only set the value if/when the value differs from the node value (which would
completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
solution. The value can be a boolean or object so that's why it's forced
to be a string.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> hostProps = _assign({}, props, {
        <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,
        <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">undefined</span>,
        <span class="hljs-attr">children</span>: toString(node._wrapperState.initialValue)
      });

      <span class="hljs-keyword">return</span> hostProps;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initWrapperState$2</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      {
        ReactControlledValuePropTypes.checkPropTypes(<span class="hljs-string">'textarea'</span>, props);

        <span class="hljs-keyword">if</span> (props.value !== <span class="hljs-literal">undefined</span> &amp;&amp; props.defaultValue !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnValDefaultVal) {
          error(<span class="hljs-string">'%s contains a textarea with both value and defaultValue props. '</span> + <span class="hljs-string">'Textarea elements must be either controlled or uncontrolled '</span> + <span class="hljs-string">'(specify either the value prop, or the defaultValue prop, but not '</span> + <span class="hljs-string">'both). Decide between using a controlled or uncontrolled textarea '</span> + <span class="hljs-string">'and remove one of these props. More info: '</span> + <span class="hljs-string">'https://fb.me/react-controlled-components'</span>, getCurrentFiberOwnerNameInDevOrNull() || <span class="hljs-string">'A component'</span>);
          didWarnValDefaultVal = <span class="hljs-literal">true</span>;
        }
      }
      <span class="hljs-keyword">var</span> initialValue = props.value; <span class="hljs-comment">// Only bother fetching default value if we're going to use it</span>

      <span class="hljs-keyword">if</span> (initialValue == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> children = props.children,
            defaultValue = props.defaultValue;

        <span class="hljs-keyword">if</span> (children != <span class="hljs-literal">null</span>) {
          {
            error(<span class="hljs-string">'Use the `defaultValue` or `value` props instead of setting '</span> + <span class="hljs-string">'children on &lt;textarea&gt;.'</span>);
          }
          {
            <span class="hljs-keyword">if</span> (!(defaultValue == <span class="hljs-literal">null</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"If you supply `defaultValue` on a &lt;textarea&gt;, do not pass children."</span>);
              }
            }

            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(children)) {
              <span class="hljs-keyword">if</span> (!(children.length &lt;= <span class="hljs-number">1</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"&lt;textarea&gt; can only have at most one child."</span>);
                }
              }

              children = children[<span class="hljs-number">0</span>];
            }

            defaultValue = children;
          }
        }

        <span class="hljs-keyword">if</span> (defaultValue == <span class="hljs-literal">null</span>) {
          defaultValue = <span class="hljs-string">''</span>;
        }

        initialValue = defaultValue;
      }

      node._wrapperState = {
        <span class="hljs-attr">initialValue</span>: getToStringValue(initialValue)
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateWrapper$1</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element;
      <span class="hljs-keyword">var</span> value = getToStringValue(props.value);
      <span class="hljs-keyword">var</span> defaultValue = getToStringValue(props.defaultValue);

      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-273" id="section-273"></a>
</div>
<p>Cast <code>value</code> to a string to ensure the value is set correctly. While
browsers typically do this as necessary, jsdom doesn't.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> newValue = toString(value); <span class="hljs-comment">// To avoid side effects (such as losing text selection), only set value if changed</span>

        <span class="hljs-keyword">if</span> (newValue !== node.value) {
          node.value = newValue;
        }

        <span class="hljs-keyword">if</span> (props.defaultValue == <span class="hljs-literal">null</span> &amp;&amp; node.defaultValue !== newValue) {
          node.defaultValue = newValue;
        }
      }

      <span class="hljs-keyword">if</span> (defaultValue != <span class="hljs-literal">null</span>) {
        node.defaultValue = toString(defaultValue);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postMountWrapper$3</span>(<span class="hljs-params">element, props</span>) </span>{
      <span class="hljs-keyword">var</span> node = element; <span class="hljs-comment">// This is in postMount because we need access to the DOM node, which is not</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-274" id="section-274"></a>
</div>
<p>available until after the component has mounted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> textContent = node.textContent; <span class="hljs-comment">// Only set node.value if textContent is equal to the expected</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-275" id="section-275"></a>
</div>
<p>initial value. In IE10/IE11 there is a bug where the placeholder attribute
will populate textContent as well.
https://developer.microsoft.com/microsoft-edge/platform/issues/101525/</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (textContent === node._wrapperState.initialValue) {
        <span class="hljs-keyword">if</span> (textContent !== <span class="hljs-string">''</span> &amp;&amp; textContent !== <span class="hljs-literal">null</span>) {
          node.value = textContent;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreControlledState$2</span>(<span class="hljs-params">element, props</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-276" id="section-276"></a>
</div>
<p>DOM component is still mounted; update</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      updateWrapper$<span class="hljs-number">1</span>(element, props);
    }

    <span class="hljs-keyword">var</span> HTML_NAMESPACE = <span class="hljs-string">'http://www.w3.org/1999/xhtml'</span>;
    <span class="hljs-keyword">var</span> MATH_NAMESPACE = <span class="hljs-string">'http://www.w3.org/1998/Math/MathML'</span>;
    <span class="hljs-keyword">var</span> SVG_NAMESPACE = <span class="hljs-string">'http://www.w3.org/2000/svg'</span>;
    <span class="hljs-keyword">var</span> Namespaces = {
      <span class="hljs-attr">html</span>: HTML_NAMESPACE,
      <span class="hljs-attr">mathml</span>: MATH_NAMESPACE,
      <span class="hljs-attr">svg</span>: SVG_NAMESPACE
    }; <span class="hljs-comment">// Assumes there is no parent namespace.</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIntrinsicNamespace</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">switch</span> (type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'svg'</span>:
          <span class="hljs-keyword">return</span> SVG_NAMESPACE;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'math'</span>:
          <span class="hljs-keyword">return</span> MATH_NAMESPACE;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> HTML_NAMESPACE;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildNamespace</span>(<span class="hljs-params">parentNamespace, type</span>) </span>{
      <span class="hljs-keyword">if</span> (parentNamespace == <span class="hljs-literal">null</span> || parentNamespace === HTML_NAMESPACE) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-277" id="section-277"></a>
</div>
<p>No (or default) parent namespace: potential entry point.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> getIntrinsicNamespace(type);
      }

      <span class="hljs-keyword">if</span> (parentNamespace === SVG_NAMESPACE &amp;&amp; type === <span class="hljs-string">'foreignObject'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-278" id="section-278"></a>
</div>
<p>We're leaving SVG.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> HTML_NAMESPACE;
      } <span class="hljs-comment">// By default, pass namespace below.</span>


      <span class="hljs-keyword">return</span> parentNamespace;
    }
    <span class="hljs-comment">/* globals MSApp */</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-279" id="section-279"></a>
</div>
<div class="dox">
<div class="summary">
<p>Create a function which has 'unsafe' privileges (required by windows8 apps)</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> createMicrosoftUnsafeLocalFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> MSApp !== <span class="hljs-string">'undefined'</span> &amp;&amp; MSApp.execUnsafeLocalFunction) {
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg0, arg1, arg2, arg3</span>) </span>{
          MSApp.execUnsafeLocalFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> func(arg0, arg1, arg2, arg3);
          });
        };
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> func;
      }
    };

    <span class="hljs-keyword">var</span> reusableSVGContainer;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-280" id="section-280"></a>
</div>
<div class="dox">
<div class="summary">
<p>Set the innerHTML property of a node</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">html</span>
<span class="dox_type">string</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> setInnerHTML = createMicrosoftUnsafeLocalFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, html</span>) </span>{
      <span class="hljs-keyword">if</span> (node.namespaceURI === Namespaces.svg) {
        <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'innerHTML'</span> <span class="hljs-keyword">in</span> node)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-281" id="section-281"></a>
</div>
<p>IE does not have innerHTML for SVG nodes, so instead we inject the
new markup in a temp node and then move the child nodes across into
the target node</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          reusableSVGContainer = reusableSVGContainer || <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
          reusableSVGContainer.innerHTML = <span class="hljs-string">'&lt;svg&gt;'</span> + html.valueOf().toString() + <span class="hljs-string">'&lt;/svg&gt;'</span>;
          <span class="hljs-keyword">var</span> svgNode = reusableSVGContainer.firstChild;

          <span class="hljs-keyword">while</span> (node.firstChild) {
            node.removeChild(node.firstChild);
          }

          <span class="hljs-keyword">while</span> (svgNode.firstChild) {
            node.appendChild(svgNode.firstChild);
          }

          <span class="hljs-keyword">return</span>;
        }
      }

      node.innerHTML = html;
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-282" id="section-282"></a>
</div>
<div class="dox">
<div class="summary">
<p>HTML nodeType values that represent the type of the node</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> ELEMENT_NODE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> TEXT_NODE = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> COMMENT_NODE = <span class="hljs-number">8</span>;
    <span class="hljs-keyword">var</span> DOCUMENT_NODE = <span class="hljs-number">9</span>;
    <span class="hljs-keyword">var</span> DOCUMENT_FRAGMENT_NODE = <span class="hljs-number">11</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-283" id="section-283"></a>
</div>
<div class="dox">
<div class="summary">
<p>Set the textContent property of a node. For text updates, it's faster
to set the <code>nodeValue</code> of the Text node directly instead of using
<code>.textContent</code> which will remove the existing node and create a new one.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">text</span>
<span class="dox_type">string</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> setTextContent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, text</span>) </span>{
      <span class="hljs-keyword">if</span> (text) {
        <span class="hljs-keyword">var</span> firstChild = node.firstChild;

        <span class="hljs-keyword">if</span> (firstChild &amp;&amp; firstChild === node.lastChild &amp;&amp; firstChild.nodeType === TEXT_NODE) {
          firstChild.nodeValue = text;
          <span class="hljs-keyword">return</span>;
        }
      }

      node.textContent = text;
    }; <span class="hljs-comment">// Do not use the below two methods directly!</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-284" id="section-284"></a>
</div>
<p>Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.
(It is the only module that is allowed to access these methods.)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unsafeCastStringToDOMTopLevelType</span>(<span class="hljs-params">topLevelType</span>) </span>{
      <span class="hljs-keyword">return</span> topLevelType;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unsafeCastDOMTopLevelTypeToString</span>(<span class="hljs-params">topLevelType</span>) </span>{
      <span class="hljs-keyword">return</span> topLevelType;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-285" id="section-285"></a>
</div>
<div class="dox">
<div class="summary">
<p>Generate a mapping of standard vendor prefixes using the defined style property and event name.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">styleProp</span>
<span class="dox_type">string</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">eventName</span>
<span class="dox_type">string</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePrefixMap</span>(<span class="hljs-params">styleProp, eventName</span>) </span>{
      <span class="hljs-keyword">var</span> prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes[<span class="hljs-string">'Webkit'</span> + styleProp] = <span class="hljs-string">'webkit'</span> + eventName;
      prefixes[<span class="hljs-string">'Moz'</span> + styleProp] = <span class="hljs-string">'moz'</span> + eventName;
      <span class="hljs-keyword">return</span> prefixes;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-286" id="section-286"></a>
</div>
<div class="dox">
<div class="summary">
<p>A list of event names to a configurable list of vendor prefixes.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> vendorPrefixes = {
      <span class="hljs-attr">animationend</span>: makePrefixMap(<span class="hljs-string">'Animation'</span>, <span class="hljs-string">'AnimationEnd'</span>),
      <span class="hljs-attr">animationiteration</span>: makePrefixMap(<span class="hljs-string">'Animation'</span>, <span class="hljs-string">'AnimationIteration'</span>),
      <span class="hljs-attr">animationstart</span>: makePrefixMap(<span class="hljs-string">'Animation'</span>, <span class="hljs-string">'AnimationStart'</span>),
      <span class="hljs-attr">transitionend</span>: makePrefixMap(<span class="hljs-string">'Transition'</span>, <span class="hljs-string">'TransitionEnd'</span>)
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-287" id="section-287"></a>
</div>
<div class="dox">
<div class="summary">
<p>Event names that have already been detected and prefixed (if applicable).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> prefixedEventNames = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-288" id="section-288"></a>
</div>
<div class="dox">
<div class="summary">
<p>Element to check for prefixes on.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> style = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-289" id="section-289"></a>
</div>
<div class="dox">
<div class="summary">
<p>Bootstrap if a DOM exists.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">if</span> (canUseDOM) {
      style = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>).style; <span class="hljs-comment">// On some platforms, in particular some releases of Android 4.x,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-290" id="section-290"></a>
</div>
<p>the un-prefixed &quot;animation&quot; and &quot;transition&quot; properties are defined on the
style object but the events that fire will still be prefixed, so we need
to check if the un-prefixed events are usable, and if not remove them from the map.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'AnimationEvent'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)) {
        <span class="hljs-keyword">delete</span> vendorPrefixes.animationend.animation;
        <span class="hljs-keyword">delete</span> vendorPrefixes.animationiteration.animation;
        <span class="hljs-keyword">delete</span> vendorPrefixes.animationstart.animation;
      } <span class="hljs-comment">// Same as above</span>


      <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'TransitionEvent'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)) {
        <span class="hljs-keyword">delete</span> vendorPrefixes.transitionend.transition;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-291" id="section-291"></a>
</div>
<div class="dox">
<div class="summary">
<p>Attempts to determine the correct vendor prefixed event name.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">eventName</span>
<span class="dox_type">string</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVendorPrefixedEventName</span>(<span class="hljs-params">eventName</span>) </span>{
      <span class="hljs-keyword">if</span> (prefixedEventNames[eventName]) {
        <span class="hljs-keyword">return</span> prefixedEventNames[eventName];
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vendorPrefixes[eventName]) {
        <span class="hljs-keyword">return</span> eventName;
      }

      <span class="hljs-keyword">var</span> prefixMap = vendorPrefixes[eventName];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> styleProp <span class="hljs-keyword">in</span> prefixMap) {
        <span class="hljs-keyword">if</span> (prefixMap.hasOwnProperty(styleProp) &amp;&amp; styleProp <span class="hljs-keyword">in</span> style) {
          <span class="hljs-keyword">return</span> prefixedEventNames[eventName] = prefixMap[styleProp];
        }
      }

      <span class="hljs-keyword">return</span> eventName;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-292" id="section-292"></a>
</div>
<div class="dox">
<div class="summary">
<p>To identify top level events in ReactDOM, we use constants defined by this
module. This is the only module that uses the unsafe* methods to express
that the constants actually correspond to the browser event names. This lets
us save some bundle size by avoiding a top level type -&gt; event name map.
The rest of ReactDOM code should import top level types from this file.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> TOP_ABORT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'abort'</span>);
    <span class="hljs-keyword">var</span> TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(<span class="hljs-string">'animationend'</span>));
    <span class="hljs-keyword">var</span> TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(<span class="hljs-string">'animationiteration'</span>));
    <span class="hljs-keyword">var</span> TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(<span class="hljs-string">'animationstart'</span>));
    <span class="hljs-keyword">var</span> TOP_BLUR = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'blur'</span>);
    <span class="hljs-keyword">var</span> TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'canplay'</span>);
    <span class="hljs-keyword">var</span> TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'canplaythrough'</span>);
    <span class="hljs-keyword">var</span> TOP_CANCEL = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'cancel'</span>);
    <span class="hljs-keyword">var</span> TOP_CHANGE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'change'</span>);
    <span class="hljs-keyword">var</span> TOP_CLICK = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'click'</span>);
    <span class="hljs-keyword">var</span> TOP_CLOSE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'close'</span>);
    <span class="hljs-keyword">var</span> TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'compositionend'</span>);
    <span class="hljs-keyword">var</span> TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'compositionstart'</span>);
    <span class="hljs-keyword">var</span> TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'compositionupdate'</span>);
    <span class="hljs-keyword">var</span> TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'contextmenu'</span>);
    <span class="hljs-keyword">var</span> TOP_COPY = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'copy'</span>);
    <span class="hljs-keyword">var</span> TOP_CUT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'cut'</span>);
    <span class="hljs-keyword">var</span> TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'dblclick'</span>);
    <span class="hljs-keyword">var</span> TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'auxclick'</span>);
    <span class="hljs-keyword">var</span> TOP_DRAG = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'drag'</span>);
    <span class="hljs-keyword">var</span> TOP_DRAG_END = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'dragend'</span>);
    <span class="hljs-keyword">var</span> TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'dragenter'</span>);
    <span class="hljs-keyword">var</span> TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'dragexit'</span>);
    <span class="hljs-keyword">var</span> TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'dragleave'</span>);
    <span class="hljs-keyword">var</span> TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'dragover'</span>);
    <span class="hljs-keyword">var</span> TOP_DRAG_START = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'dragstart'</span>);
    <span class="hljs-keyword">var</span> TOP_DROP = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'drop'</span>);
    <span class="hljs-keyword">var</span> TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'durationchange'</span>);
    <span class="hljs-keyword">var</span> TOP_EMPTIED = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'emptied'</span>);
    <span class="hljs-keyword">var</span> TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'encrypted'</span>);
    <span class="hljs-keyword">var</span> TOP_ENDED = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'ended'</span>);
    <span class="hljs-keyword">var</span> TOP_ERROR = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'error'</span>);
    <span class="hljs-keyword">var</span> TOP_FOCUS = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'focus'</span>);
    <span class="hljs-keyword">var</span> TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'gotpointercapture'</span>);
    <span class="hljs-keyword">var</span> TOP_INPUT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'input'</span>);
    <span class="hljs-keyword">var</span> TOP_INVALID = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'invalid'</span>);
    <span class="hljs-keyword">var</span> TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'keydown'</span>);
    <span class="hljs-keyword">var</span> TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'keypress'</span>);
    <span class="hljs-keyword">var</span> TOP_KEY_UP = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'keyup'</span>);
    <span class="hljs-keyword">var</span> TOP_LOAD = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'load'</span>);
    <span class="hljs-keyword">var</span> TOP_LOAD_START = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'loadstart'</span>);
    <span class="hljs-keyword">var</span> TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'loadeddata'</span>);
    <span class="hljs-keyword">var</span> TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'loadedmetadata'</span>);
    <span class="hljs-keyword">var</span> TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'lostpointercapture'</span>);
    <span class="hljs-keyword">var</span> TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'mousedown'</span>);
    <span class="hljs-keyword">var</span> TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'mousemove'</span>);
    <span class="hljs-keyword">var</span> TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'mouseout'</span>);
    <span class="hljs-keyword">var</span> TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'mouseover'</span>);
    <span class="hljs-keyword">var</span> TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'mouseup'</span>);
    <span class="hljs-keyword">var</span> TOP_PASTE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'paste'</span>);
    <span class="hljs-keyword">var</span> TOP_PAUSE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'pause'</span>);
    <span class="hljs-keyword">var</span> TOP_PLAY = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'play'</span>);
    <span class="hljs-keyword">var</span> TOP_PLAYING = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'playing'</span>);
    <span class="hljs-keyword">var</span> TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'pointercancel'</span>);
    <span class="hljs-keyword">var</span> TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'pointerdown'</span>);
    <span class="hljs-keyword">var</span> TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'pointermove'</span>);
    <span class="hljs-keyword">var</span> TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'pointerout'</span>);
    <span class="hljs-keyword">var</span> TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'pointerover'</span>);
    <span class="hljs-keyword">var</span> TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'pointerup'</span>);
    <span class="hljs-keyword">var</span> TOP_PROGRESS = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'progress'</span>);
    <span class="hljs-keyword">var</span> TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'ratechange'</span>);
    <span class="hljs-keyword">var</span> TOP_RESET = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'reset'</span>);
    <span class="hljs-keyword">var</span> TOP_SCROLL = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'scroll'</span>);
    <span class="hljs-keyword">var</span> TOP_SEEKED = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'seeked'</span>);
    <span class="hljs-keyword">var</span> TOP_SEEKING = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'seeking'</span>);
    <span class="hljs-keyword">var</span> TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'selectionchange'</span>);
    <span class="hljs-keyword">var</span> TOP_STALLED = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'stalled'</span>);
    <span class="hljs-keyword">var</span> TOP_SUBMIT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'submit'</span>);
    <span class="hljs-keyword">var</span> TOP_SUSPEND = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'suspend'</span>);
    <span class="hljs-keyword">var</span> TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'textInput'</span>);
    <span class="hljs-keyword">var</span> TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'timeupdate'</span>);
    <span class="hljs-keyword">var</span> TOP_TOGGLE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'toggle'</span>);
    <span class="hljs-keyword">var</span> TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'touchcancel'</span>);
    <span class="hljs-keyword">var</span> TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'touchend'</span>);
    <span class="hljs-keyword">var</span> TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'touchmove'</span>);
    <span class="hljs-keyword">var</span> TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'touchstart'</span>);
    <span class="hljs-keyword">var</span> TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(<span class="hljs-string">'transitionend'</span>));
    <span class="hljs-keyword">var</span> TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'volumechange'</span>);
    <span class="hljs-keyword">var</span> TOP_WAITING = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'waiting'</span>);
    <span class="hljs-keyword">var</span> TOP_WHEEL = unsafeCastStringToDOMTopLevelType(<span class="hljs-string">'wheel'</span>); <span class="hljs-comment">// List of events that need to be individually attached to media elements.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-293" id="section-293"></a>
</div>
<p>Note that events in this list will <em>not</em> be listened to at the top level
unless they're explicitly whitelisted in <code>ReactBrowserEventEmitter.listenTo</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRawEventName</span>(<span class="hljs-params">topLevelType</span>) </span>{
      <span class="hljs-keyword">return</span> unsafeCastDOMTopLevelTypeToString(topLevelType);
    }

    <span class="hljs-keyword">var</span> PossiblyWeakMap = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">WeakMap</span> === <span class="hljs-string">'function'</span> ? <span class="hljs-built_in">WeakMap</span> : <span class="hljs-built_in">Map</span>; <span class="hljs-comment">// prettier-ignore</span>

    <span class="hljs-keyword">var</span> elementListenerMap = <span class="hljs-keyword">new</span> PossiblyWeakMap();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListenerMapForElement</span>(<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">var</span> listenerMap = elementListenerMap.get(element);

      <span class="hljs-keyword">if</span> (listenerMap === <span class="hljs-literal">undefined</span>) {
        listenerMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
        elementListenerMap.set(element, listenerMap);
      }

      <span class="hljs-keyword">return</span> listenerMap;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-294" id="section-294"></a>
</div>
<div class="dox">
<div class="summary">
<p><code>ReactInstanceMap</code> maintains a mapping from a public facing stateful
instance (key) and the internal representation (value). This allows public
methods to accept the user facing instance as an argument and map them back
to internal methods.</p>
</div>
<div class="body">
<p>Note that this module is currently shared and assumed to be stateless.
If this becomes an actual Map, that will break.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">return</span> key._reactInternalFiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">return</span> key._reactInternalFiber !== <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params">key, value</span>) </span>{
      key._reactInternalFiber = value;
    } <span class="hljs-comment">// Don't change these two values. They're used by React Dev Tools.</span>


    <span class="hljs-keyword">var</span> NoEffect =
    <span class="hljs-comment">/*              */</span>
    <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> PerformedWork =
    <span class="hljs-comment">/*         */</span>
    <span class="hljs-number">1</span>; <span class="hljs-comment">// You can change the rest (and add more).</span>

    <span class="hljs-keyword">var</span> Placement =
    <span class="hljs-comment">/*             */</span>
    <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> Update =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> PlacementAndUpdate =
    <span class="hljs-comment">/*    */</span>
    <span class="hljs-number">6</span>;
    <span class="hljs-keyword">var</span> Deletion =
    <span class="hljs-comment">/*              */</span>
    <span class="hljs-number">8</span>;
    <span class="hljs-keyword">var</span> ContentReset =
    <span class="hljs-comment">/*          */</span>
    <span class="hljs-number">16</span>;
    <span class="hljs-keyword">var</span> Callback =
    <span class="hljs-comment">/*              */</span>
    <span class="hljs-number">32</span>;
    <span class="hljs-keyword">var</span> DidCapture =
    <span class="hljs-comment">/*            */</span>
    <span class="hljs-number">64</span>;
    <span class="hljs-keyword">var</span> Ref =
    <span class="hljs-comment">/*                   */</span>
    <span class="hljs-number">128</span>;
    <span class="hljs-keyword">var</span> Snapshot =
    <span class="hljs-comment">/*              */</span>
    <span class="hljs-number">256</span>;
    <span class="hljs-keyword">var</span> Passive =
    <span class="hljs-comment">/*               */</span>
    <span class="hljs-number">512</span>;
    <span class="hljs-keyword">var</span> Hydrating =
    <span class="hljs-comment">/*             */</span>
    <span class="hljs-number">1024</span>;
    <span class="hljs-keyword">var</span> HydratingAndUpdate =
    <span class="hljs-comment">/*    */</span>
    <span class="hljs-number">1028</span>; <span class="hljs-comment">// Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot</span>

    <span class="hljs-keyword">var</span> LifecycleEffectMask =
    <span class="hljs-comment">/*   */</span>
    <span class="hljs-number">932</span>; <span class="hljs-comment">// Union of all host effects</span>

    <span class="hljs-keyword">var</span> HostEffectMask =
    <span class="hljs-comment">/*        */</span>
    <span class="hljs-number">2047</span>;
    <span class="hljs-keyword">var</span> Incomplete =
    <span class="hljs-comment">/*            */</span>
    <span class="hljs-number">2048</span>;
    <span class="hljs-keyword">var</span> ShouldCapture =
    <span class="hljs-comment">/*         */</span>
    <span class="hljs-number">4096</span>;
    <span class="hljs-keyword">var</span> ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNearestMountedFiber</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> node = fiber;
      <span class="hljs-keyword">var</span> nearestMounted = fiber;

      <span class="hljs-keyword">if</span> (!fiber.alternate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-295" id="section-295"></a>
</div>
<p>If there is no alternate, this might be a new tree that isn't inserted
yet. If it is, then it will have a pending insertion effect on it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> nextNode = node;

        <span class="hljs-keyword">do</span> {
          node = nextNode;

          <span class="hljs-keyword">if</span> ((node.effectTag &amp; (Placement | Hydrating)) !== NoEffect) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-296" id="section-296"></a>
</div>
<p>This is an insertion or in-progress hydration. The nearest possible
mounted fiber is the parent but we need to continue to figure out
if that one is still mounted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            nearestMounted = node.return;
          }

          nextNode = node.return;
        } <span class="hljs-keyword">while</span> (nextNode);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">while</span> (node.return) {
          node = node.return;
        }
      }

      <span class="hljs-keyword">if</span> (node.tag === HostRoot) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-297" id="section-297"></a>
</div>
<p>TODO: Check if this was a nested HostRoot when used with
renderContainerIntoSubtree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> nearestMounted;
      } <span class="hljs-comment">// If we didn't hit the root, that means that we're in an disconnected tree</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-298" id="section-298"></a>
</div>
<p>that has been unmounted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSuspenseInstanceFromFiber</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (fiber.tag === SuspenseComponent) {
        <span class="hljs-keyword">var</span> suspenseState = fiber.memoizedState;

        <span class="hljs-keyword">if</span> (suspenseState === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> current = fiber.alternate;

          <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
            suspenseState = current.memoizedState;
          }
        }

        <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> suspenseState.dehydrated;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContainerFromFiber</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">return</span> fiber.tag === HostRoot ? fiber.stateNode.containerInfo : <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFiberMounted</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">return</span> getNearestMountedFiber(fiber) === fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isMounted</span>(<span class="hljs-params">component</span>) </span>{
      {
        <span class="hljs-keyword">var</span> owner = ReactCurrentOwner.current;

        <span class="hljs-keyword">if</span> (owner !== <span class="hljs-literal">null</span> &amp;&amp; owner.tag === ClassComponent) {
          <span class="hljs-keyword">var</span> ownerFiber = owner;
          <span class="hljs-keyword">var</span> instance = ownerFiber.stateNode;

          <span class="hljs-keyword">if</span> (!instance._warnedAboutRefsInRender) {
            error(<span class="hljs-string">'%s is accessing isMounted inside its render() function. '</span> + <span class="hljs-string">'render() should be a pure function of props and state. It should '</span> + <span class="hljs-string">'never access something that requires stale data from the previous '</span> + <span class="hljs-string">'render, such as refs. Move this logic to componentDidMount and '</span> + <span class="hljs-string">'componentDidUpdate instead.'</span>, getComponentName(ownerFiber.type) || <span class="hljs-string">'A component'</span>);
          }

          instance._warnedAboutRefsInRender = <span class="hljs-literal">true</span>;
        }
      }
      <span class="hljs-keyword">var</span> fiber = <span class="hljs-keyword">get</span>(component);

      if (!fiber) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> getNearestMountedFiber(fiber) === fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertIsMounted</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (!(getNearestMountedFiber(fiber) === fiber)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unable to find node on an unmounted component."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findCurrentFiberUsingSlowPath</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> alternate = fiber.alternate;

      <span class="hljs-keyword">if</span> (!alternate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-299" id="section-299"></a>
</div>
<p>If there is no alternate, then we only need to check if it is mounted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> nearestMounted = getNearestMountedFiber(fiber);

        <span class="hljs-keyword">if</span> (!(nearestMounted !== <span class="hljs-literal">null</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unable to find node on an unmounted component."</span>);
          }
        }

        <span class="hljs-keyword">if</span> (nearestMounted !== fiber) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> fiber;
      } <span class="hljs-comment">// If we have two possible branches, we'll walk backwards up to the root</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-300" id="section-300"></a>
</div>
<p>to see what path the root points to. On the way we may hit one of the
special cases and we'll deal with them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> a = fiber;
      <span class="hljs-keyword">var</span> b = alternate;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> parentA = a.return;

        <span class="hljs-keyword">if</span> (parentA === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-301" id="section-301"></a>
</div>
<p>We're at the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> parentB = parentA.alternate;

        <span class="hljs-keyword">if</span> (parentB === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-302" id="section-302"></a>
</div>
<p>There is no alternate. This is an unusual case. Currently, it only
happens when a Suspense component is hidden. An extra fragment fiber
is inserted in between the Suspense fiber and its children. Skip
over this extra fragment fiber and proceed to the next parent.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> nextParent = parentA.return;

          <span class="hljs-keyword">if</span> (nextParent !== <span class="hljs-literal">null</span>) {
            a = b = nextParent;
            <span class="hljs-keyword">continue</span>;
          } <span class="hljs-comment">// If there's no parent, we're at the root.</span>


          <span class="hljs-keyword">break</span>;
        } <span class="hljs-comment">// If both copies of the parent fiber point to the same child, we can</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-303" id="section-303"></a>
</div>
<p>assume that the child is current. This happens when we bailout on low
priority: the bailed out fiber's child reuses the current child.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (parentA.child === parentB.child) {
          <span class="hljs-keyword">var</span> child = parentA.child;

          <span class="hljs-keyword">while</span> (child) {
            <span class="hljs-keyword">if</span> (child === a) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-304" id="section-304"></a>
</div>
<p>We've determined that A is the current branch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              assertIsMounted(parentA);
              <span class="hljs-keyword">return</span> fiber;
            }

            <span class="hljs-keyword">if</span> (child === b) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-305" id="section-305"></a>
</div>
<p>We've determined that B is the current branch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              assertIsMounted(parentA);
              <span class="hljs-keyword">return</span> alternate;
            }

            child = child.sibling;
          } <span class="hljs-comment">// We should never have an alternate for any mounting node. So the only</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-306" id="section-306"></a>
</div>
<p>way this could possibly happen is if this was unmounted, if at all.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unable to find node on an unmounted component."</span>);
            }
          }
        }

        <span class="hljs-keyword">if</span> (a.return !== b.return) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-307" id="section-307"></a>
</div>
<p>The return pointer of A and the return pointer of B point to different
fibers. We assume that return pointers never criss-cross, so A must
belong to the child set of A.return, and B must belong to the child
set of B.return.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          a = parentA;
          b = parentB;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-308" id="section-308"></a>
</div>
<p>The return pointers point to the same fiber. We'll have to use the
default, slow path: scan the child sets of each parent alternate to see
which child belongs to which set.</p>
<p>Search parent A's child set</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> didFindChild = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">var</span> _child = parentA.child;

          <span class="hljs-keyword">while</span> (_child) {
            <span class="hljs-keyword">if</span> (_child === a) {
              didFindChild = <span class="hljs-literal">true</span>;
              a = parentA;
              b = parentB;
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">if</span> (_child === b) {
              didFindChild = <span class="hljs-literal">true</span>;
              b = parentA;
              a = parentB;
              <span class="hljs-keyword">break</span>;
            }

            _child = _child.sibling;
          }

          <span class="hljs-keyword">if</span> (!didFindChild) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-309" id="section-309"></a>
</div>
<p>Search parent B's child set</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            _child = parentB.child;

            <span class="hljs-keyword">while</span> (_child) {
              <span class="hljs-keyword">if</span> (_child === a) {
                didFindChild = <span class="hljs-literal">true</span>;
                a = parentB;
                b = parentA;
                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">if</span> (_child === b) {
                didFindChild = <span class="hljs-literal">true</span>;
                b = parentB;
                a = parentA;
                <span class="hljs-keyword">break</span>;
              }

              _child = _child.sibling;
            }

            <span class="hljs-keyword">if</span> (!didFindChild) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."</span>);
              }
            }
          }
        }

        <span class="hljs-keyword">if</span> (!(a.alternate === b)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }
      } <span class="hljs-comment">// If the root is not a host container, we're in a disconnected tree. I.e.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-310" id="section-310"></a>
</div>
<p>unmounted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (!(a.tag === HostRoot)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unable to find node on an unmounted component."</span>);
        }
      }

      <span class="hljs-keyword">if</span> (a.stateNode.current === a) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-311" id="section-311"></a>
</div>
<p>We've determined that A is the current branch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> fiber;
      } <span class="hljs-comment">// Otherwise B has to be current branch.</span>


      <span class="hljs-keyword">return</span> alternate;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findCurrentHostFiber</span>(<span class="hljs-params">parent</span>) </span>{
      <span class="hljs-keyword">var</span> currentParent = findCurrentFiberUsingSlowPath(parent);

      <span class="hljs-keyword">if</span> (!currentParent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// Next we'll drill down this component to find the first HostComponent/Text.</span>


      <span class="hljs-keyword">var</span> node = currentParent;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText) {
          <span class="hljs-keyword">return</span> node;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child) {
          node.child.return = node;
          node = node.child;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === currentParent) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">while</span> (!node.sibling) {
          <span class="hljs-keyword">if</span> (!node.return || node.return === currentParent) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;
      } <span class="hljs-comment">// Flow needs the return null here, but ESLint complains about it.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-312" id="section-312"></a>
</div>
<p>eslint-disable-next-line no-unreachable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findCurrentHostFiberWithNoPortals</span>(<span class="hljs-params">parent</span>) </span>{
      <span class="hljs-keyword">var</span> currentParent = findCurrentFiberUsingSlowPath(parent);

      <span class="hljs-keyword">if</span> (!currentParent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// Next we'll drill down this component to find the first HostComponent/Text.</span>


      <span class="hljs-keyword">var</span> node = currentParent;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) {
          <span class="hljs-keyword">return</span> node;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child &amp;&amp; node.tag !== HostPortal) {
          node.child.return = node;
          node = node.child;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === currentParent) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">while</span> (!node.sibling) {
          <span class="hljs-keyword">if</span> (!node.return || node.return === currentParent) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;
      } <span class="hljs-comment">// Flow needs the return null here, but ESLint complains about it.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-313" id="section-313"></a>
</div>
<p>eslint-disable-next-line no-unreachable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-314" id="section-314"></a>
</div>
<div class="dox">
<div class="summary">
<p>Accumulates items that must not be null or undefined into the first one. This
is used to conserve memory by avoiding array allocations, and thus sacrifices
API cleanness. Since <code>current</code> can be null before being passed in and not
null after this function, make sure to assign it back to <code>current</code>:</p>
</div>
<div class="body">
<p><code>a = accumulateInto(a, b);</code></p>
<p>This API should be sparingly used. Try <code>accumulate</code> for something cleaner.</p>
</div>
<div class="details">
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">array.&lt;*&gt;</span>
<span>An accumulation of items.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateInto</span>(<span class="hljs-params">current, next</span>) </span>{
      <span class="hljs-keyword">if</span> (!(next != <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"accumulateInto(...): Accumulated items must not be null or undefined."</span>);
        }
      }

      <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> next;
      } <span class="hljs-comment">// Both are not empty. Warning: Never call x.concat(y) when you are not</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-315" id="section-315"></a>
</div>
<p>certain that x is an Array (x could be a string with concat method).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(current)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(next)) {
          current.push.apply(current, next);
          <span class="hljs-keyword">return</span> current;
        }

        current.push(next);
        <span class="hljs-keyword">return</span> current;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(next)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-316" id="section-316"></a>
</div>
<p>A bit too dangerous to mutate <code>next</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> [current].concat(next);
      }

      <span class="hljs-keyword">return</span> [current, next];
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-317" id="section-317"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">arr</span>
<span class="dox_type">array</span>
<span>an &quot;accumulation&quot; of items which is either an Array or a single item. Useful when paired with the <code>accumulate</code> module. This is a
simple utility that allows us to reason about a collection of items, but
handling the case when there is exactly one item (and we do not need to
allocate an array).
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">cb</span>
<span class="dox_type">function</span>
<span>Callback invoked with each element or a collection.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">[scope]</span>
<span>Scope used as <code>this</code> in a callback.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachAccumulated</span>(<span class="hljs-params">arr, cb, scope</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr)) {
        arr.forEach(cb, scope);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr) {
        cb.call(scope, arr);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-318" id="section-318"></a>
</div>
<div class="dox">
<div class="summary">
<p>Internal queue of events that have accumulated their dispatches and are
waiting to have their dispatches executed.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> eventQueue = <span class="hljs-literal">null</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-319" id="section-319"></a>
</div>
<div class="dox">
<div class="summary">
<p>Dispatches an event and releases it back into the pool, unless persistent.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">event</span>
<span class="dox_type">object</span>
<span>Synthetic event to be dispatched.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> executeDispatchesAndRelease = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">if</span> (event) {
        executeDispatchesInOrder(event);

        <span class="hljs-keyword">if</span> (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };

    <span class="hljs-keyword">var</span> executeDispatchesAndReleaseTopLevel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">return</span> executeDispatchesAndRelease(e);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runEventsInBatch</span>(<span class="hljs-params">events</span>) </span>{
      <span class="hljs-keyword">if</span> (events !== <span class="hljs-literal">null</span>) {
        eventQueue = accumulateInto(eventQueue, events);
      } <span class="hljs-comment">// Set `eventQueue` to null before processing it so that we can tell if more</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-320" id="section-320"></a>
</div>
<p>events get enqueued while processing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> processingEventQueue = eventQueue;
      eventQueue = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (!processingEventQueue) {
        <span class="hljs-keyword">return</span>;
      }

      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);

      <span class="hljs-keyword">if</span> (!!eventQueue) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."</span>);
        }
      } <span class="hljs-comment">// This would be a good time to rethrow if any of the event handlers threw.</span>


      rethrowCaughtError();
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-321" id="section-321"></a>
</div>
<div class="dox">
<div class="summary">
<p>Gets the target node from a native browser event by accounting for
inconsistencies in browser DOM APIs.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
<span>Native browser event.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">DOMEventTarget</span>
<span>Target node.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventTarget</span>(<span class="hljs-params">nativeEvent</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-322" id="section-322"></a>
</div>
<p>Fallback to nativeEvent.srcElement for IE9
https://github.com/facebook/react/issues/12506</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> target = nativeEvent.target || nativeEvent.srcElement || <span class="hljs-built_in">window</span>; <span class="hljs-comment">// Normalize SVG &lt;use&gt; element events #4963</span>

      <span class="hljs-keyword">if</span> (target.correspondingUseElement) {
        target = target.correspondingUseElement;
      } <span class="hljs-comment">// Safari may fire events on text nodes (Node.TEXT_NODE is 3).</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-323" id="section-323"></a>
</div>
<p>@see http://www.quirksmode.org/js/events_properties.html</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">return</span> target.nodeType === TEXT_NODE ? target.parentNode : target;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-324" id="section-324"></a>
</div>
<div class="dox">
<div class="summary">
<p>Checks if an event is supported in the current execution environment.</p>
</div>
<div class="body">
<p>NOTE: This will not work correctly for non-generic events such as <code>change</code>,
<code>reset</code>, <code>load</code>, <code>error</code>, and <code>select</code>.</p>
<p>Borrows from Modernizr.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">eventNameSuffix</span>
<span class="dox_type">string</span>
<span>Event name, e.g. &quot;click&quot;.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
<span>True if the event is supported.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEventSupported</span>(<span class="hljs-params">eventNameSuffix</span>) </span>{
      <span class="hljs-keyword">if</span> (!canUseDOM) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> eventName = <span class="hljs-string">'on'</span> + eventNameSuffix;
      <span class="hljs-keyword">var</span> isSupported = (eventName <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>);

      <span class="hljs-keyword">if</span> (!isSupported) {
        <span class="hljs-keyword">var</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
        element.setAttribute(eventName, <span class="hljs-string">'return;'</span>);
        isSupported = <span class="hljs-keyword">typeof</span> element[eventName] === <span class="hljs-string">'function'</span>;
      }

      <span class="hljs-keyword">return</span> isSupported;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-325" id="section-325"></a>
</div>
<div class="dox">
<div class="summary">
<p>Summary of <code>DOMEventPluginSystem</code> event handling:</p>
</div>
<div class="body">
<ul>
<li>
<p>Top-level delegation is used to trap most native browser events. This
may only occur in the main thread and is the responsibility of
ReactDOMEventListener, which is injected and can therefore support
pluggable event sources. This is the only work that occurs in the main
thread.</p>
</li>
<li>
<p>We normalize and de-duplicate events to account for browser quirks. This
may be done in the worker thread.</p>
</li>
<li>
<p>Forward these native events (with the associated top-level type used to
trap it) to <code>EventPluginRegistry</code>, which in turn will ask plugins if they want
to extract any synthetic events.</p>
</li>
<li>
<p>The <code>EventPluginRegistry</code> will then process each event by annotating them with
&quot;dispatches&quot;, a sequence of listeners and IDs that care about that event.</p>
</li>
<li>
<p>The <code>EventPluginRegistry</code> then dispatches the events.</p>
</li>
</ul>
<p>Overview of React and the event system:</p>
<p>+------------+    .
|    DOM     |    .
+------------+    .
|           .
v           .
+------------+    .
| ReactEvent |    .
|  Listener  |    .
+------------+    .                         +-----------+
|           .               +--------+|SimpleEvent|
|           .               |         |Plugin     |
+-----|------+    .               v         +-----------+
|     |      |    .    +--------------+                    +------------+
|     +-----------.---&gt;|PluginRegistry|                    |    Event   |
|            |    .    |              |     +-----------+  | Propagators|
| ReactEvent |    .    |              |     |TapEvent   |  |------------|
|  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|
|            |    .    |              |     +-----------+  |  utilities |
|     +-----------.---&gt;|              |                    +------------+
|     |      |    .    +--------------+
+-----|------+    .                ^        +-----------+
|           .                |        |Enter/Leave|
+           .                +-------+|Plugin     |
+-------------+   .                         +-----------+
| application |   .
|-------------|   .
|             |   .
|             |   .
+-------------+   .
.
React Core     .  General Purpose Event Plugin System</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> CALLBACK_BOOKKEEPING_POOL_SIZE = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">var</span> callbackBookkeepingPool = [];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">releaseTopLevelCallbackBookKeeping</span>(<span class="hljs-params">instance</span>) </span>{
      instance.topLevelType = <span class="hljs-literal">null</span>;
      instance.nativeEvent = <span class="hljs-literal">null</span>;
      instance.targetInst = <span class="hljs-literal">null</span>;
      instance.ancestors.length = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (callbackBookkeepingPool.length &lt; CALLBACK_BOOKKEEPING_POOL_SIZE) {
        callbackBookkeepingPool.push(instance);
      }
    } <span class="hljs-comment">// Used to store ancestor hierarchy in top level callback</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTopLevelCallbackBookKeeping</span>(<span class="hljs-params">topLevelType, nativeEvent, targetInst, eventSystemFlags</span>) </span>{
      <span class="hljs-keyword">if</span> (callbackBookkeepingPool.length) {
        <span class="hljs-keyword">var</span> instance = callbackBookkeepingPool.pop();
        instance.topLevelType = topLevelType;
        instance.eventSystemFlags = eventSystemFlags;
        instance.nativeEvent = nativeEvent;
        instance.targetInst = targetInst;
        <span class="hljs-keyword">return</span> instance;
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">topLevelType</span>: topLevelType,
        <span class="hljs-attr">eventSystemFlags</span>: eventSystemFlags,
        <span class="hljs-attr">nativeEvent</span>: nativeEvent,
        <span class="hljs-attr">targetInst</span>: targetInst,
        <span class="hljs-attr">ancestors</span>: []
      };
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-326" id="section-326"></a>
</div>
<div class="dox">
<div class="summary">
<p>Find the deepest React component completely containing the root of the
passed-in instance (for use when entire React trees are nested within each
other). If React trees are not nested, returns null.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findRootContainerNode</span>(<span class="hljs-params">inst</span>) </span>{
      <span class="hljs-keyword">if</span> (inst.tag === HostRoot) {
        <span class="hljs-keyword">return</span> inst.stateNode.containerInfo;
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> It may be a good idea to cache this to prevent unnecessary DOM</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-327" id="section-327"></a>
</div>
<p>traversal, but caching is difficult to do correctly without using a
mutation observer to listen for all DOM changes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">while</span> (inst.return) {
        inst = inst.return;
      }

      <span class="hljs-keyword">if</span> (inst.tag !== HostRoot) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-328" id="section-328"></a>
</div>
<p>This can happen if we're in a detached tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> inst.stateNode.containerInfo;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-329" id="section-329"></a>
</div>
<div class="dox">
<div class="summary">
<p>Allows registered plugins an opportunity to extract events from top-level
native browser events.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span>An accumulation of synthetic events.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractPluginEvents</span>(<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags</span>) </span>{
      <span class="hljs-keyword">var</span> events = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; plugins.length; i++) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-330" id="section-330"></a>
</div>
<p>Not every plugin in the ordering may be loaded at runtime.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> possiblePlugin = plugins[i];

        <span class="hljs-keyword">if</span> (possiblePlugin) {
          <span class="hljs-keyword">var</span> extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);

          <span class="hljs-keyword">if</span> (extractedEvents) {
            events = accumulateInto(events, extractedEvents);
          }
        }
      }

      <span class="hljs-keyword">return</span> events;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runExtractedPluginEventsInBatch</span>(<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags</span>) </span>{
      <span class="hljs-keyword">var</span> events = extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
      runEventsInBatch(events);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleTopLevel</span>(<span class="hljs-params">bookKeeping</span>) </span>{
      <span class="hljs-keyword">var</span> targetInst = bookKeeping.targetInst; <span class="hljs-comment">// Loop through the hierarchy, in case there's any nested components.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-331" id="section-331"></a>
</div>
<p>It's important that we build the array of ancestors before calling any
event handlers, because event handlers can modify the DOM, leading to
inconsistencies with ReactMount's node cache. See #1105.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> ancestor = targetInst;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (!ancestor) {
          <span class="hljs-keyword">var</span> ancestors = bookKeeping.ancestors;
          ancestors.push(ancestor);
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> root = findRootContainerNode(ancestor);

        <span class="hljs-keyword">if</span> (!root) {
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> tag = ancestor.tag;

        <span class="hljs-keyword">if</span> (tag === HostComponent || tag === HostText) {
          bookKeeping.ancestors.push(ancestor);
        }

        ancestor = getClosestInstanceFromNode(root);
      } <span class="hljs-keyword">while</span> (ancestor);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; bookKeeping.ancestors.length; i++) {
        targetInst = bookKeeping.ancestors[i];
        <span class="hljs-keyword">var</span> eventTarget = getEventTarget(bookKeeping.nativeEvent);
        <span class="hljs-keyword">var</span> topLevelType = bookKeeping.topLevelType;
        <span class="hljs-keyword">var</span> nativeEvent = bookKeeping.nativeEvent;
        <span class="hljs-keyword">var</span> eventSystemFlags = bookKeeping.eventSystemFlags; <span class="hljs-comment">// If this is the first ancestor, we mark it on the system flags</span>

        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
          eventSystemFlags |= IS_FIRST_ANCESTOR;
        }

        runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget, eventSystemFlags);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEventForLegacyPluginEventSystem</span>(<span class="hljs-params">topLevelType, eventSystemFlags, nativeEvent, targetInst</span>) </span>{
      <span class="hljs-keyword">var</span> bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags);

      <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-332" id="section-332"></a>
</div>
<p>Event queue being processed in the same cycle allows
<code>preventDefault</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        batchedEventUpdates(handleTopLevel, bookKeeping);
      } <span class="hljs-keyword">finally</span> {
        releaseTopLevelCallbackBookKeeping(bookKeeping);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-333" id="section-333"></a>
</div>
<div class="dox">
<div class="summary">
<p>We listen for bubbled touch events on the document object.</p>
</div>
<div class="body">
<p>Firefox v8.01 (and possibly others) exhibited strange behavior when
mounting <code>onmousemove</code> events at some node that was not the document
element. The symptoms were that if your mouse is not moving over something
contained within that mount point (for example on the background) the
top-level listeners for <code>onmousemove</code> won't be called. However, if you
register the <code>mousemove</code> on the document object, then it will of course
catch all <code>mousemove</code>s. This along with iOS quirks, justifies restricting
top-level listeners to the document object only, at least for these
movement types of events and possibly all events.</p>
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="
Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
they bubble to document.">http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html</a>
</div>
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">registrationName</span>
<span class="dox_type">string</span>
<span>Name of listener (e.g. <code>onClick</code>).
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">mountAt</span>
<span class="dox_type">object</span>
<span>Container where to mount the listener
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">legacyListenToEvent</span>(<span class="hljs-params">registrationName, mountAt</span>) </span>{
      <span class="hljs-keyword">var</span> listenerMap = getListenerMapForElement(mountAt);
      <span class="hljs-keyword">var</span> dependencies = registrationNameDependencies[registrationName];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dependencies.length; i++) {
        <span class="hljs-keyword">var</span> dependency = dependencies[i];
        legacyListenToTopLevelEvent(dependency, mountAt, listenerMap);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">legacyListenToTopLevelEvent</span>(<span class="hljs-params">topLevelType, mountAt, listenerMap</span>) </span>{
      <span class="hljs-keyword">if</span> (!listenerMap.has(topLevelType)) {
        <span class="hljs-keyword">switch</span> (topLevelType) {
          <span class="hljs-keyword">case</span> TOP_SCROLL:
            trapCapturedEvent(TOP_SCROLL, mountAt);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_FOCUS:
          <span class="hljs-keyword">case</span> TOP_BLUR:
            trapCapturedEvent(TOP_FOCUS, mountAt);
            trapCapturedEvent(TOP_BLUR, mountAt); <span class="hljs-comment">// We set the flag for a single dependency later in this function,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-334" id="section-334"></a>
</div>
<p>but this ensures we mark both as attached rather than just one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            listenerMap.set(TOP_BLUR, <span class="hljs-literal">null</span>);
            listenerMap.set(TOP_FOCUS, <span class="hljs-literal">null</span>);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_CANCEL:
          <span class="hljs-keyword">case</span> TOP_CLOSE:
            <span class="hljs-keyword">if</span> (isEventSupported(getRawEventName(topLevelType))) {
              trapCapturedEvent(topLevelType, mountAt);
            }

            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_INVALID:
          <span class="hljs-keyword">case</span> TOP_SUBMIT:
          <span class="hljs-keyword">case</span> TOP_RESET:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-335" id="section-335"></a>
</div>
<p>We listen to them on the target DOM elements.
Some of them bubble so we don't want them to fire twice.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-336" id="section-336"></a>
</div>
<p>By default, listen on the top level to all non-media events.
Media events don't bubble so adding the listener wouldn't do anything.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== <span class="hljs-number">-1</span>;

            <span class="hljs-keyword">if</span> (!isMediaEvent) {
              trapBubbledEvent(topLevelType, mountAt);
            }

            <span class="hljs-keyword">break</span>;
        }

        listenerMap.set(topLevelType, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isListeningToAllDependencies</span>(<span class="hljs-params">registrationName, mountAt</span>) </span>{
      <span class="hljs-keyword">var</span> listenerMap = getListenerMapForElement(mountAt);
      <span class="hljs-keyword">var</span> dependencies = registrationNameDependencies[registrationName];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dependencies.length; i++) {
        <span class="hljs-keyword">var</span> dependency = dependencies[i];

        <span class="hljs-keyword">if</span> (!listenerMap.has(dependency)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">var</span> attemptUserBlockingHydration;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAttemptUserBlockingHydration</span>(<span class="hljs-params">fn</span>) </span>{
      attemptUserBlockingHydration = fn;
    }

    <span class="hljs-keyword">var</span> attemptContinuousHydration;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAttemptContinuousHydration</span>(<span class="hljs-params">fn</span>) </span>{
      attemptContinuousHydration = fn;
    }

    <span class="hljs-keyword">var</span> attemptHydrationAtCurrentPriority;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAttemptHydrationAtCurrentPriority</span>(<span class="hljs-params">fn</span>) </span>{
      attemptHydrationAtCurrentPriority = fn;
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Upgrade this definition once we're on a newer version of Flow that</span>


    <span class="hljs-keyword">var</span> hasScheduledReplayAttempt = <span class="hljs-literal">false</span>; <span class="hljs-comment">// The queue of discrete events to be replayed.</span>

    <span class="hljs-keyword">var</span> queuedDiscreteEvents = []; <span class="hljs-comment">// Indicates if any continuous event targets are non-null for early bailout.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-337" id="section-337"></a>
</div>
<p>if the last target was dehydrated.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> queuedFocus = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> queuedDrag = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> queuedMouse = <span class="hljs-literal">null</span>; <span class="hljs-comment">// For pointer events there can be one latest event per pointerId.</span>

    <span class="hljs-keyword">var</span> queuedPointers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">var</span> queuedPointerCaptures = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// We could consider replaying selectionchange and touchmoves too.</span>

    <span class="hljs-keyword">var</span> queuedExplicitHydrationTargets = [];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasQueuedDiscreteEvents</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> queuedDiscreteEvents.length &gt; <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">var</span> discreteReplayableEvents = [TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_TOUCH_START, TOP_AUX_CLICK, TOP_DOUBLE_CLICK, TOP_POINTER_CANCEL, TOP_POINTER_DOWN, TOP_POINTER_UP, TOP_DRAG_END, TOP_DRAG_START, TOP_DROP, TOP_COMPOSITION_END, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_INPUT, TOP_TEXT_INPUT, TOP_CLOSE, TOP_CANCEL, TOP_COPY, TOP_CUT, TOP_PASTE, TOP_CLICK, TOP_CHANGE, TOP_CONTEXT_MENU, TOP_RESET, TOP_SUBMIT];
    <span class="hljs-keyword">var</span> continuousReplayableEvents = [TOP_FOCUS, TOP_BLUR, TOP_DRAG_ENTER, TOP_DRAG_LEAVE, TOP_MOUSE_OVER, TOP_MOUSE_OUT, TOP_POINTER_OVER, TOP_POINTER_OUT, TOP_GOT_POINTER_CAPTURE, TOP_LOST_POINTER_CAPTURE];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isReplayableDiscreteEvent</span>(<span class="hljs-params">eventType</span>) </span>{
      <span class="hljs-keyword">return</span> discreteReplayableEvents.indexOf(eventType) &gt; <span class="hljs-number">-1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trapReplayableEventForDocument</span>(<span class="hljs-params">topLevelType, document, listenerMap</span>) </span>{
      legacyListenToTopLevelEvent(topLevelType, <span class="hljs-built_in">document</span>, listenerMap);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eagerlyTrapReplayableEvents</span>(<span class="hljs-params">container, document</span>) </span>{
      <span class="hljs-keyword">var</span> listenerMapForDoc = getListenerMapForElement(<span class="hljs-built_in">document</span>); <span class="hljs-comment">// Discrete</span>

      discreteReplayableEvents.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topLevelType</span>) </span>{
        trapReplayableEventForDocument(topLevelType, <span class="hljs-built_in">document</span>, listenerMapForDoc);
      }); <span class="hljs-comment">// Continuous</span>

      continuousReplayableEvents.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topLevelType</span>) </span>{
        trapReplayableEventForDocument(topLevelType, <span class="hljs-built_in">document</span>, listenerMapForDoc);
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createQueuedReplayableEvent</span>(<span class="hljs-params">blockedOn, topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">blockedOn</span>: blockedOn,
        <span class="hljs-attr">topLevelType</span>: topLevelType,
        <span class="hljs-attr">eventSystemFlags</span>: eventSystemFlags | IS_REPLAYED,
        <span class="hljs-attr">nativeEvent</span>: nativeEvent,
        <span class="hljs-attr">container</span>: container
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueDiscreteEvent</span>(<span class="hljs-params">blockedOn, topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
      <span class="hljs-keyword">var</span> queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);
      queuedDiscreteEvents.push(queuedEvent);
    } <span class="hljs-comment">// Resets the replaying for this type of continuous event to no event.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearIfContinuousEvent</span>(<span class="hljs-params">topLevelType, nativeEvent</span>) </span>{
      <span class="hljs-keyword">switch</span> (topLevelType) {
        <span class="hljs-keyword">case</span> TOP_FOCUS:
        <span class="hljs-keyword">case</span> TOP_BLUR:
          queuedFocus = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> TOP_DRAG_ENTER:
        <span class="hljs-keyword">case</span> TOP_DRAG_LEAVE:
          queuedDrag = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> TOP_MOUSE_OVER:
        <span class="hljs-keyword">case</span> TOP_MOUSE_OUT:
          queuedMouse = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> TOP_POINTER_OVER:
        <span class="hljs-keyword">case</span> TOP_POINTER_OUT:
          {
            <span class="hljs-keyword">var</span> pointerId = nativeEvent.pointerId;
            queuedPointers.delete(pointerId);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> TOP_GOT_POINTER_CAPTURE:
        <span class="hljs-keyword">case</span> TOP_LOST_POINTER_CAPTURE:
          {
            <span class="hljs-keyword">var</span> _pointerId = nativeEvent.pointerId;
            queuedPointerCaptures.delete(_pointerId);
            <span class="hljs-keyword">break</span>;
          }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateOrCreateContinuousQueuedReplayableEvent</span>(<span class="hljs-params">existingQueuedEvent, blockedOn, topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
      <span class="hljs-keyword">if</span> (existingQueuedEvent === <span class="hljs-literal">null</span> || existingQueuedEvent.nativeEvent !== nativeEvent) {
        <span class="hljs-keyword">var</span> queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);

        <span class="hljs-keyword">if</span> (blockedOn !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> _fiber2 = getInstanceFromNode$<span class="hljs-number">1</span>(blockedOn);

          <span class="hljs-keyword">if</span> (_fiber2 !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-338" id="section-338"></a>
</div>
<p>Attempt to increase the priority of this target.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            attemptContinuousHydration(_fiber2);
          }
        }

        <span class="hljs-keyword">return</span> queuedEvent;
      } <span class="hljs-comment">// If we have already queued this exact event, then it's because</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-339" id="section-339"></a>
</div>
<p>the different event systems have different DOM event listeners.
We can accumulate the flags and store a single event to be
replayed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      <span class="hljs-keyword">return</span> existingQueuedEvent;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueIfContinuousEvent</span>(<span class="hljs-params">blockedOn, topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-340" id="section-340"></a>
</div>
<p>These set relatedTarget to null because the replayed event will be treated as if we
moved from outside the window (no target) onto the target once it hydrates.
Instead of mutating we could clone the event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">switch</span> (topLevelType) {
        <span class="hljs-keyword">case</span> TOP_FOCUS:
          {
            <span class="hljs-keyword">var</span> focusEvent = nativeEvent;
            queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, topLevelType, eventSystemFlags, container, focusEvent);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

        <span class="hljs-keyword">case</span> TOP_DRAG_ENTER:
          {
            <span class="hljs-keyword">var</span> dragEvent = nativeEvent;
            queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, topLevelType, eventSystemFlags, container, dragEvent);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

        <span class="hljs-keyword">case</span> TOP_MOUSE_OVER:
          {
            <span class="hljs-keyword">var</span> mouseEvent = nativeEvent;
            queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, topLevelType, eventSystemFlags, container, mouseEvent);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

        <span class="hljs-keyword">case</span> TOP_POINTER_OVER:
          {
            <span class="hljs-keyword">var</span> pointerEvent = nativeEvent;
            <span class="hljs-keyword">var</span> pointerId = pointerEvent.pointerId;
            queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || <span class="hljs-literal">null</span>, blockedOn, topLevelType, eventSystemFlags, container, pointerEvent));
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

        <span class="hljs-keyword">case</span> TOP_GOT_POINTER_CAPTURE:
          {
            <span class="hljs-keyword">var</span> _pointerEvent = nativeEvent;
            <span class="hljs-keyword">var</span> _pointerId2 = _pointerEvent.pointerId;
            queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || <span class="hljs-literal">null</span>, blockedOn, topLevelType, eventSystemFlags, container, _pointerEvent));
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// Check if this target is unblocked. Returns true if it's unblocked.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemptExplicitHydrationTarget</span>(<span class="hljs-params">queuedTarget</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-341" id="section-341"></a>
</div>
<p>TODO: This function shares a lot of logic with attemptToDispatchEvent.
Try to unify them. It's a bit tricky since it would require two return
values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> targetInst = getClosestInstanceFromNode(queuedTarget.target);

      <span class="hljs-keyword">if</span> (targetInst !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> nearestMounted = getNearestMountedFiber(targetInst);

        <span class="hljs-keyword">if</span> (nearestMounted !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> tag = nearestMounted.tag;

          <span class="hljs-keyword">if</span> (tag === SuspenseComponent) {
            <span class="hljs-keyword">var</span> instance = getSuspenseInstanceFromFiber(nearestMounted);

            <span class="hljs-keyword">if</span> (instance !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-342" id="section-342"></a>
</div>
<p>We're blocked on hydrating this boundary.
Increase its priority.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              queuedTarget.blockedOn = instance;
              Scheduler.unstable_runWithPriority(queuedTarget.priority, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              <span class="hljs-keyword">return</span>;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === HostRoot) {
            <span class="hljs-keyword">var</span> root = nearestMounted.stateNode;

            <span class="hljs-keyword">if</span> (root.hydrate) {
              queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); <span class="hljs-comment">// We don't currently have a way to increase the priority of</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-343" id="section-343"></a>
</div>
<p>a root other than sync.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              <span class="hljs-keyword">return</span>;
            }
          }
        }
      }

      queuedTarget.blockedOn = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemptReplayContinuousQueuedEvent</span>(<span class="hljs-params">queuedEvent</span>) </span>{
      <span class="hljs-keyword">if</span> (queuedEvent.blockedOn !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> nextBlockedOn = attemptToDispatchEvent(queuedEvent.topLevelType, queuedEvent.eventSystemFlags, queuedEvent.container, queuedEvent.nativeEvent);

      <span class="hljs-keyword">if</span> (nextBlockedOn !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-344" id="section-344"></a>
</div>
<p>We're still blocked. Try again later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> _fiber3 = getInstanceFromNode$<span class="hljs-number">1</span>(nextBlockedOn);

        <span class="hljs-keyword">if</span> (_fiber3 !== <span class="hljs-literal">null</span>) {
          attemptContinuousHydration(_fiber3);
        }

        queuedEvent.blockedOn = nextBlockedOn;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemptReplayContinuousQueuedEventInMap</span>(<span class="hljs-params">queuedEvent, key, map</span>) </span>{
      <span class="hljs-keyword">if</span> (attemptReplayContinuousQueuedEvent(queuedEvent)) {
        map.delete(key);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replayUnblockedEvents</span>(<span class="hljs-params"></span>) </span>{
      hasScheduledReplayAttempt = <span class="hljs-literal">false</span>; <span class="hljs-comment">// First replay discrete events.</span>

      <span class="hljs-keyword">while</span> (queuedDiscreteEvents.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> nextDiscreteEvent = queuedDiscreteEvents[<span class="hljs-number">0</span>];

        <span class="hljs-keyword">if</span> (nextDiscreteEvent.blockedOn !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-345" id="section-345"></a>
</div>
<p>We're still blocked.
Increase the priority of this boundary to unblock
the next discrete event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> _fiber4 = getInstanceFromNode$<span class="hljs-number">1</span>(nextDiscreteEvent.blockedOn);

          <span class="hljs-keyword">if</span> (_fiber4 !== <span class="hljs-literal">null</span>) {
            attemptUserBlockingHydration(_fiber4);
          }

          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.topLevelType, nextDiscreteEvent.eventSystemFlags, nextDiscreteEvent.container, nextDiscreteEvent.nativeEvent);

        <span class="hljs-keyword">if</span> (nextBlockedOn !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-346" id="section-346"></a>
</div>
<p>We're still blocked. Try again later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          nextDiscreteEvent.blockedOn = nextBlockedOn;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-347" id="section-347"></a>
</div>
<p>We've successfully replayed the first event. Let's try the next one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          queuedDiscreteEvents.shift();
        }
      } <span class="hljs-comment">// Next replay any continuous events.</span>


      <span class="hljs-keyword">if</span> (queuedFocus !== <span class="hljs-literal">null</span> &amp;&amp; attemptReplayContinuousQueuedEvent(queuedFocus)) {
        queuedFocus = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (queuedDrag !== <span class="hljs-literal">null</span> &amp;&amp; attemptReplayContinuousQueuedEvent(queuedDrag)) {
        queuedDrag = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (queuedMouse !== <span class="hljs-literal">null</span> &amp;&amp; attemptReplayContinuousQueuedEvent(queuedMouse)) {
        queuedMouse = <span class="hljs-literal">null</span>;
      }

      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleCallbackIfUnblocked</span>(<span class="hljs-params">queuedEvent, unblocked</span>) </span>{
      <span class="hljs-keyword">if</span> (queuedEvent.blockedOn === unblocked) {
        queuedEvent.blockedOn = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (!hasScheduledReplayAttempt) {
          hasScheduledReplayAttempt = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Schedule a callback to attempt replaying as many events as are</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-348" id="section-348"></a>
</div>
<p>now unblocked. This first might not actually be unblocked yet.
We could check it early to avoid scheduling an unnecessary callback.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retryIfBlockedOn</span>(<span class="hljs-params">unblocked</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-349" id="section-349"></a>
</div>
<p>Mark anything that was blocked on this as no longer blocked
and eligible for a replay.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (queuedDiscreteEvents.length &gt; <span class="hljs-number">0</span>) {
        scheduleCallbackIfUnblocked(queuedDiscreteEvents[<span class="hljs-number">0</span>], unblocked); <span class="hljs-comment">// This is a exponential search for each boundary that commits. I think it's</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-350" id="section-350"></a>
</div>
<p>worth it because we expect very few discrete events to queue up and once
we are actually fully unblocked it will be fast to replay them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; queuedDiscreteEvents.length; i++) {
          <span class="hljs-keyword">var</span> queuedEvent = queuedDiscreteEvents[i];

          <span class="hljs-keyword">if</span> (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = <span class="hljs-literal">null</span>;
          }
        }
      }

      <span class="hljs-keyword">if</span> (queuedFocus !== <span class="hljs-literal">null</span>) {
        scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      }

      <span class="hljs-keyword">if</span> (queuedDrag !== <span class="hljs-literal">null</span>) {
        scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      }

      <span class="hljs-keyword">if</span> (queuedMouse !== <span class="hljs-literal">null</span>) {
        scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      }

      <span class="hljs-keyword">var</span> unblock = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">queuedEvent</span>) </span>{
        <span class="hljs-keyword">return</span> scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      };

      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; queuedExplicitHydrationTargets.length; _i++) {
        <span class="hljs-keyword">var</span> queuedTarget = queuedExplicitHydrationTargets[_i];

        <span class="hljs-keyword">if</span> (queuedTarget.blockedOn === unblocked) {
          queuedTarget.blockedOn = <span class="hljs-literal">null</span>;
        }
      }

      <span class="hljs-keyword">while</span> (queuedExplicitHydrationTargets.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> nextExplicitTarget = queuedExplicitHydrationTargets[<span class="hljs-number">0</span>];

        <span class="hljs-keyword">if</span> (nextExplicitTarget.blockedOn !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-351" id="section-351"></a>
</div>
<p>We're still blocked.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> {
          attemptExplicitHydrationTarget(nextExplicitTarget);

          <span class="hljs-keyword">if</span> (nextExplicitTarget.blockedOn === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-352" id="section-352"></a>
</div>
<p>We're unblocked.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            queuedExplicitHydrationTargets.shift();
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventBubbleListener</span>(<span class="hljs-params">element, eventType, listener</span>) </span>{
      element.addEventListener(eventType, listener, <span class="hljs-literal">false</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventCaptureListener</span>(<span class="hljs-params">element, eventType, listener</span>) </span>{
      element.addEventListener(eventType, listener, <span class="hljs-literal">true</span>);
    } <span class="hljs-comment">// do it in two places, which duplicates logic</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-353" id="section-353"></a>
</div>
<p>and increases the bundle size, we do it all
here once. If we remove or refactor the
SimpleEventPlugin, we should also remove or
update the below line.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> simpleEventPluginEventTypes = {};
    <span class="hljs-keyword">var</span> topLevelEventsToDispatchConfig = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">var</span> eventPriorities = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// We store most of the events in this module in pairs of two strings so we can re-use</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-354" id="section-354"></a>
</div>
<p>the code required to apply the same logic for event prioritization and that of the
SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
duplication (for which there would be quite a bit). For the events that are not needed
for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
array of top level events.
Lastly, we ignore prettier so we can keep the formatting sane.
prettier-ignore</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> discreteEventPairsForSimpleEventPlugin = [TOP_BLUR, <span class="hljs-string">'blur'</span>, TOP_CANCEL, <span class="hljs-string">'cancel'</span>, TOP_CLICK, <span class="hljs-string">'click'</span>, TOP_CLOSE, <span class="hljs-string">'close'</span>, TOP_CONTEXT_MENU, <span class="hljs-string">'contextMenu'</span>, TOP_COPY, <span class="hljs-string">'copy'</span>, TOP_CUT, <span class="hljs-string">'cut'</span>, TOP_AUX_CLICK, <span class="hljs-string">'auxClick'</span>, TOP_DOUBLE_CLICK, <span class="hljs-string">'doubleClick'</span>, TOP_DRAG_END, <span class="hljs-string">'dragEnd'</span>, TOP_DRAG_START, <span class="hljs-string">'dragStart'</span>, TOP_DROP, <span class="hljs-string">'drop'</span>, TOP_FOCUS, <span class="hljs-string">'focus'</span>, TOP_INPUT, <span class="hljs-string">'input'</span>, TOP_INVALID, <span class="hljs-string">'invalid'</span>, TOP_KEY_DOWN, <span class="hljs-string">'keyDown'</span>, TOP_KEY_PRESS, <span class="hljs-string">'keyPress'</span>, TOP_KEY_UP, <span class="hljs-string">'keyUp'</span>, TOP_MOUSE_DOWN, <span class="hljs-string">'mouseDown'</span>, TOP_MOUSE_UP, <span class="hljs-string">'mouseUp'</span>, TOP_PASTE, <span class="hljs-string">'paste'</span>, TOP_PAUSE, <span class="hljs-string">'pause'</span>, TOP_PLAY, <span class="hljs-string">'play'</span>, TOP_POINTER_CANCEL, <span class="hljs-string">'pointerCancel'</span>, TOP_POINTER_DOWN, <span class="hljs-string">'pointerDown'</span>, TOP_POINTER_UP, <span class="hljs-string">'pointerUp'</span>, TOP_RATE_CHANGE, <span class="hljs-string">'rateChange'</span>, TOP_RESET, <span class="hljs-string">'reset'</span>, TOP_SEEKED, <span class="hljs-string">'seeked'</span>, TOP_SUBMIT, <span class="hljs-string">'submit'</span>, TOP_TOUCH_CANCEL, <span class="hljs-string">'touchCancel'</span>, TOP_TOUCH_END, <span class="hljs-string">'touchEnd'</span>, TOP_TOUCH_START, <span class="hljs-string">'touchStart'</span>, TOP_VOLUME_CHANGE, <span class="hljs-string">'volumeChange'</span>];
    <span class="hljs-keyword">var</span> otherDiscreteEvents = [TOP_CHANGE, TOP_SELECTION_CHANGE, TOP_TEXT_INPUT, TOP_COMPOSITION_START, TOP_COMPOSITION_END, TOP_COMPOSITION_UPDATE]; <span class="hljs-comment">// prettier-ignore</span>

    <span class="hljs-keyword">var</span> userBlockingPairsForSimpleEventPlugin = [TOP_DRAG, <span class="hljs-string">'drag'</span>, TOP_DRAG_ENTER, <span class="hljs-string">'dragEnter'</span>, TOP_DRAG_EXIT, <span class="hljs-string">'dragExit'</span>, TOP_DRAG_LEAVE, <span class="hljs-string">'dragLeave'</span>, TOP_DRAG_OVER, <span class="hljs-string">'dragOver'</span>, TOP_MOUSE_MOVE, <span class="hljs-string">'mouseMove'</span>, TOP_MOUSE_OUT, <span class="hljs-string">'mouseOut'</span>, TOP_MOUSE_OVER, <span class="hljs-string">'mouseOver'</span>, TOP_POINTER_MOVE, <span class="hljs-string">'pointerMove'</span>, TOP_POINTER_OUT, <span class="hljs-string">'pointerOut'</span>, TOP_POINTER_OVER, <span class="hljs-string">'pointerOver'</span>, TOP_SCROLL, <span class="hljs-string">'scroll'</span>, TOP_TOGGLE, <span class="hljs-string">'toggle'</span>, TOP_TOUCH_MOVE, <span class="hljs-string">'touchMove'</span>, TOP_WHEEL, <span class="hljs-string">'wheel'</span>]; <span class="hljs-comment">// prettier-ignore</span>

    <span class="hljs-keyword">var</span> continuousPairsForSimpleEventPlugin = [TOP_ABORT, <span class="hljs-string">'abort'</span>, TOP_ANIMATION_END, <span class="hljs-string">'animationEnd'</span>, TOP_ANIMATION_ITERATION, <span class="hljs-string">'animationIteration'</span>, TOP_ANIMATION_START, <span class="hljs-string">'animationStart'</span>, TOP_CAN_PLAY, <span class="hljs-string">'canPlay'</span>, TOP_CAN_PLAY_THROUGH, <span class="hljs-string">'canPlayThrough'</span>, TOP_DURATION_CHANGE, <span class="hljs-string">'durationChange'</span>, TOP_EMPTIED, <span class="hljs-string">'emptied'</span>, TOP_ENCRYPTED, <span class="hljs-string">'encrypted'</span>, TOP_ENDED, <span class="hljs-string">'ended'</span>, TOP_ERROR, <span class="hljs-string">'error'</span>, TOP_GOT_POINTER_CAPTURE, <span class="hljs-string">'gotPointerCapture'</span>, TOP_LOAD, <span class="hljs-string">'load'</span>, TOP_LOADED_DATA, <span class="hljs-string">'loadedData'</span>, TOP_LOADED_METADATA, <span class="hljs-string">'loadedMetadata'</span>, TOP_LOAD_START, <span class="hljs-string">'loadStart'</span>, TOP_LOST_POINTER_CAPTURE, <span class="hljs-string">'lostPointerCapture'</span>, TOP_PLAYING, <span class="hljs-string">'playing'</span>, TOP_PROGRESS, <span class="hljs-string">'progress'</span>, TOP_SEEKING, <span class="hljs-string">'seeking'</span>, TOP_STALLED, <span class="hljs-string">'stalled'</span>, TOP_SUSPEND, <span class="hljs-string">'suspend'</span>, TOP_TIME_UPDATE, <span class="hljs-string">'timeUpdate'</span>, TOP_TRANSITION_END, <span class="hljs-string">'transitionEnd'</span>, TOP_WAITING, <span class="hljs-string">'waiting'</span>];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-355" id="section-355"></a>
</div>
<div class="dox">
<div class="summary">
<p>Turns
['abort', ...]
into
eventTypes = {
'abort': {
phasedRegistrationNames: {
bubbled: 'onAbort',
captured: 'onAbortCapture',
},
dependencies: [TOP_ABORT],
},
...
};
topLevelEventsToDispatchConfig = new Map([
[TOP_ABORT, { sameConfig }],
]);</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processSimpleEventPluginPairsByPriority</span>(<span class="hljs-params">eventTypes, priority</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-356" id="section-356"></a>
</div>
<p>As the event types are in pairs of two, we need to iterate
through in twos. The events are in pairs of two to save code
and improve init perf of processing this array, as it will
result in far fewer object allocations and property accesses
if we only use three arrays to process all the categories of
instead of tuples.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; eventTypes.length; i += <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">var</span> topEvent = eventTypes[i];
        <span class="hljs-keyword">var</span> event = eventTypes[i + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">var</span> capitalizedEvent = event[<span class="hljs-number">0</span>].toUpperCase() + event.slice(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">var</span> onEvent = <span class="hljs-string">'on'</span> + capitalizedEvent;
        <span class="hljs-keyword">var</span> config = {
          <span class="hljs-attr">phasedRegistrationNames</span>: {
            <span class="hljs-attr">bubbled</span>: onEvent,
            <span class="hljs-attr">captured</span>: onEvent + <span class="hljs-string">'Capture'</span>
          },
          <span class="hljs-attr">dependencies</span>: [topEvent],
          <span class="hljs-attr">eventPriority</span>: priority
        };
        eventPriorities.set(topEvent, priority);
        topLevelEventsToDispatchConfig.set(topEvent, config);
        simpleEventPluginEventTypes[event] = config;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processTopEventPairsByPriority</span>(<span class="hljs-params">eventTypes, priority</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; eventTypes.length; i++) {
        eventPriorities.set(eventTypes[i], priority);
      }
    } <span class="hljs-comment">// SimpleEventPlugin</span>


    processSimpleEventPluginPairsByPriority(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
    processSimpleEventPluginPairsByPriority(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
    processSimpleEventPluginPairsByPriority(continuousPairsForSimpleEventPlugin, ContinuousEvent); <span class="hljs-comment">// Not used by SimpleEventPlugin</span>

    processTopEventPairsByPriority(otherDiscreteEvents, DiscreteEvent);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventPriorityForPluginSystem</span>(<span class="hljs-params">topLevelType</span>) </span>{
      <span class="hljs-keyword">var</span> priority = eventPriorities.get(topLevelType); <span class="hljs-comment">// Default to a ContinuousEvent. Note: we might</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-357" id="section-357"></a>
</div>
<p>want to warn if we can't detect the priority
for the event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">return</span> priority === <span class="hljs-literal">undefined</span> ? ContinuousEvent : priority;
    } <span class="hljs-comment">// Intentionally not named imports because Rollup would use dynamic dispatch for</span>


    <span class="hljs-keyword">var</span> UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
        runWithPriority = Scheduler.unstable_runWithPriority; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> can we stop exporting these?</span>

    <span class="hljs-keyword">var</span> _enabled = <span class="hljs-literal">true</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setEnabled</span>(<span class="hljs-params">enabled</span>) </span>{
      _enabled = !!enabled;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEnabled</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _enabled;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trapBubbledEvent</span>(<span class="hljs-params">topLevelType, element</span>) </span>{
      trapEventForPluginEventSystem(element, topLevelType, <span class="hljs-literal">false</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trapCapturedEvent</span>(<span class="hljs-params">topLevelType, element</span>) </span>{
      trapEventForPluginEventSystem(element, topLevelType, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trapEventForPluginEventSystem</span>(<span class="hljs-params">container, topLevelType, capture</span>) </span>{
      <span class="hljs-keyword">var</span> listener;

      <span class="hljs-keyword">switch</span> (getEventPriorityForPluginSystem(topLevelType)) {
        <span class="hljs-keyword">case</span> DiscreteEvent:
          listener = dispatchDiscreteEvent.bind(<span class="hljs-literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM, container);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> UserBlockingEvent:
          listener = dispatchUserBlockingUpdate.bind(<span class="hljs-literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM, container);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> ContinuousEvent:
        <span class="hljs-keyword">default</span>:
          listener = dispatchEvent.bind(<span class="hljs-literal">null</span>, topLevelType, PLUGIN_EVENT_SYSTEM, container);
          <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">var</span> rawEventName = getRawEventName(topLevelType);

      <span class="hljs-keyword">if</span> (capture) {
        addEventCaptureListener(container, rawEventName, listener);
      } <span class="hljs-keyword">else</span> {
        addEventBubbleListener(container, rawEventName, listener);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchDiscreteEvent</span>(<span class="hljs-params">topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
      flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
      discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, container, nativeEvent);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchUserBlockingUpdate</span>(<span class="hljs-params">topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
      runWithPriority(UserBlockingPriority, dispatchEvent.bind(<span class="hljs-literal">null</span>, topLevelType, eventSystemFlags, container, nativeEvent));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEvent</span>(<span class="hljs-params">topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
      <span class="hljs-keyword">if</span> (!_enabled) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (hasQueuedDiscreteEvents() &amp;&amp; isReplayableDiscreteEvent(topLevelType)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-358" id="section-358"></a>
</div>
<p>If we already have a queue of discrete events, and this is another discrete
event, then we can't dispatch it regardless of its target, since they
need to dispatch in order.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        queueDiscreteEvent(<span class="hljs-literal">null</span>, <span class="hljs-comment">// Flags that we're not actually blocked on anything as far as we know.</span>
        topLevelType, eventSystemFlags, container, nativeEvent);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> blockedOn = attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent);

      <span class="hljs-keyword">if</span> (blockedOn === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-359" id="section-359"></a>
</div>
<p>We successfully dispatched this event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        clearIfContinuousEvent(topLevelType, nativeEvent);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (isReplayableDiscreteEvent(topLevelType)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-360" id="section-360"></a>
</div>
<p>This this to be replayed later once the target is available.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// We need to clear only if we didn't queue because</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-361" id="section-361"></a>
</div>
<p>queueing is accummulative.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      clearIfContinuousEvent(topLevelType, nativeEvent); <span class="hljs-comment">// This is not replayable so we'll invoke it but without a target,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-362" id="section-362"></a>
</div>
<p>in case the event system needs to trace it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      {
        dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, <span class="hljs-literal">null</span>);
      }
    } <span class="hljs-comment">// Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemptToDispatchEvent</span>(<span class="hljs-params">topLevelType, eventSystemFlags, container, nativeEvent</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-363" id="section-363"></a>
</div>
<p>TODO: Warn if _enabled is false.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> nativeEventTarget = getEventTarget(nativeEvent);
      <span class="hljs-keyword">var</span> targetInst = getClosestInstanceFromNode(nativeEventTarget);

      <span class="hljs-keyword">if</span> (targetInst !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> nearestMounted = getNearestMountedFiber(targetInst);

        <span class="hljs-keyword">if</span> (nearestMounted === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-364" id="section-364"></a>
</div>
<p>This tree has been unmounted already. Dispatch without a target.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          targetInst = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> tag = nearestMounted.tag;

          <span class="hljs-keyword">if</span> (tag === SuspenseComponent) {
            <span class="hljs-keyword">var</span> instance = getSuspenseInstanceFromFiber(nearestMounted);

            <span class="hljs-keyword">if</span> (instance !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-365" id="section-365"></a>
</div>
<p>Queue the event to be replayed later. Abort dispatching since we
don't want this event dispatched twice through the event system.
TODO: If this is the first discrete event in the queue. Schedule an increased
priority for this boundary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">return</span> instance;
            } <span class="hljs-comment">// This shouldn't happen, something went wrong but to avoid blocking</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-366" id="section-366"></a>
</div>
<p>the whole system, dispatch the event without a target.
TODO: Warn.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            targetInst = <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === HostRoot) {
            <span class="hljs-keyword">var</span> root = nearestMounted.stateNode;

            <span class="hljs-keyword">if</span> (root.hydrate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-367" id="section-367"></a>
</div>
<p>If this happens during a replay something went wrong and it might block
the whole system.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">return</span> getContainerFromFiber(nearestMounted);
            }

            targetInst = <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nearestMounted !== targetInst) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-368" id="section-368"></a>
</div>
<p>If we get an event (ex: img onload) before committing that
component's mount, ignore it for now (that is, treat it as if it was an
event on a non-React tree). We might also consider queueing events and
dispatching them after the mount.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            targetInst = <span class="hljs-literal">null</span>;
          }
        }
      }

      {
        dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);
      } <span class="hljs-comment">// We're not blocked on anything.</span>

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// List derived from Gecko source code:</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-369" id="section-369"></a>
</div>
<p>https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> shorthandToLonghand = {
      <span class="hljs-attr">animation</span>: [<span class="hljs-string">'animationDelay'</span>, <span class="hljs-string">'animationDirection'</span>, <span class="hljs-string">'animationDuration'</span>, <span class="hljs-string">'animationFillMode'</span>, <span class="hljs-string">'animationIterationCount'</span>, <span class="hljs-string">'animationName'</span>, <span class="hljs-string">'animationPlayState'</span>, <span class="hljs-string">'animationTimingFunction'</span>],
      <span class="hljs-attr">background</span>: [<span class="hljs-string">'backgroundAttachment'</span>, <span class="hljs-string">'backgroundClip'</span>, <span class="hljs-string">'backgroundColor'</span>, <span class="hljs-string">'backgroundImage'</span>, <span class="hljs-string">'backgroundOrigin'</span>, <span class="hljs-string">'backgroundPositionX'</span>, <span class="hljs-string">'backgroundPositionY'</span>, <span class="hljs-string">'backgroundRepeat'</span>, <span class="hljs-string">'backgroundSize'</span>],
      <span class="hljs-attr">backgroundPosition</span>: [<span class="hljs-string">'backgroundPositionX'</span>, <span class="hljs-string">'backgroundPositionY'</span>],
      <span class="hljs-attr">border</span>: [<span class="hljs-string">'borderBottomColor'</span>, <span class="hljs-string">'borderBottomStyle'</span>, <span class="hljs-string">'borderBottomWidth'</span>, <span class="hljs-string">'borderImageOutset'</span>, <span class="hljs-string">'borderImageRepeat'</span>, <span class="hljs-string">'borderImageSlice'</span>, <span class="hljs-string">'borderImageSource'</span>, <span class="hljs-string">'borderImageWidth'</span>, <span class="hljs-string">'borderLeftColor'</span>, <span class="hljs-string">'borderLeftStyle'</span>, <span class="hljs-string">'borderLeftWidth'</span>, <span class="hljs-string">'borderRightColor'</span>, <span class="hljs-string">'borderRightStyle'</span>, <span class="hljs-string">'borderRightWidth'</span>, <span class="hljs-string">'borderTopColor'</span>, <span class="hljs-string">'borderTopStyle'</span>, <span class="hljs-string">'borderTopWidth'</span>],
      <span class="hljs-attr">borderBlockEnd</span>: [<span class="hljs-string">'borderBlockEndColor'</span>, <span class="hljs-string">'borderBlockEndStyle'</span>, <span class="hljs-string">'borderBlockEndWidth'</span>],
      <span class="hljs-attr">borderBlockStart</span>: [<span class="hljs-string">'borderBlockStartColor'</span>, <span class="hljs-string">'borderBlockStartStyle'</span>, <span class="hljs-string">'borderBlockStartWidth'</span>],
      <span class="hljs-attr">borderBottom</span>: [<span class="hljs-string">'borderBottomColor'</span>, <span class="hljs-string">'borderBottomStyle'</span>, <span class="hljs-string">'borderBottomWidth'</span>],
      <span class="hljs-attr">borderColor</span>: [<span class="hljs-string">'borderBottomColor'</span>, <span class="hljs-string">'borderLeftColor'</span>, <span class="hljs-string">'borderRightColor'</span>, <span class="hljs-string">'borderTopColor'</span>],
      <span class="hljs-attr">borderImage</span>: [<span class="hljs-string">'borderImageOutset'</span>, <span class="hljs-string">'borderImageRepeat'</span>, <span class="hljs-string">'borderImageSlice'</span>, <span class="hljs-string">'borderImageSource'</span>, <span class="hljs-string">'borderImageWidth'</span>],
      <span class="hljs-attr">borderInlineEnd</span>: [<span class="hljs-string">'borderInlineEndColor'</span>, <span class="hljs-string">'borderInlineEndStyle'</span>, <span class="hljs-string">'borderInlineEndWidth'</span>],
      <span class="hljs-attr">borderInlineStart</span>: [<span class="hljs-string">'borderInlineStartColor'</span>, <span class="hljs-string">'borderInlineStartStyle'</span>, <span class="hljs-string">'borderInlineStartWidth'</span>],
      <span class="hljs-attr">borderLeft</span>: [<span class="hljs-string">'borderLeftColor'</span>, <span class="hljs-string">'borderLeftStyle'</span>, <span class="hljs-string">'borderLeftWidth'</span>],
      <span class="hljs-attr">borderRadius</span>: [<span class="hljs-string">'borderBottomLeftRadius'</span>, <span class="hljs-string">'borderBottomRightRadius'</span>, <span class="hljs-string">'borderTopLeftRadius'</span>, <span class="hljs-string">'borderTopRightRadius'</span>],
      <span class="hljs-attr">borderRight</span>: [<span class="hljs-string">'borderRightColor'</span>, <span class="hljs-string">'borderRightStyle'</span>, <span class="hljs-string">'borderRightWidth'</span>],
      <span class="hljs-attr">borderStyle</span>: [<span class="hljs-string">'borderBottomStyle'</span>, <span class="hljs-string">'borderLeftStyle'</span>, <span class="hljs-string">'borderRightStyle'</span>, <span class="hljs-string">'borderTopStyle'</span>],
      <span class="hljs-attr">borderTop</span>: [<span class="hljs-string">'borderTopColor'</span>, <span class="hljs-string">'borderTopStyle'</span>, <span class="hljs-string">'borderTopWidth'</span>],
      <span class="hljs-attr">borderWidth</span>: [<span class="hljs-string">'borderBottomWidth'</span>, <span class="hljs-string">'borderLeftWidth'</span>, <span class="hljs-string">'borderRightWidth'</span>, <span class="hljs-string">'borderTopWidth'</span>],
      <span class="hljs-attr">columnRule</span>: [<span class="hljs-string">'columnRuleColor'</span>, <span class="hljs-string">'columnRuleStyle'</span>, <span class="hljs-string">'columnRuleWidth'</span>],
      <span class="hljs-attr">columns</span>: [<span class="hljs-string">'columnCount'</span>, <span class="hljs-string">'columnWidth'</span>],
      <span class="hljs-attr">flex</span>: [<span class="hljs-string">'flexBasis'</span>, <span class="hljs-string">'flexGrow'</span>, <span class="hljs-string">'flexShrink'</span>],
      <span class="hljs-attr">flexFlow</span>: [<span class="hljs-string">'flexDirection'</span>, <span class="hljs-string">'flexWrap'</span>],
      <span class="hljs-attr">font</span>: [<span class="hljs-string">'fontFamily'</span>, <span class="hljs-string">'fontFeatureSettings'</span>, <span class="hljs-string">'fontKerning'</span>, <span class="hljs-string">'fontLanguageOverride'</span>, <span class="hljs-string">'fontSize'</span>, <span class="hljs-string">'fontSizeAdjust'</span>, <span class="hljs-string">'fontStretch'</span>, <span class="hljs-string">'fontStyle'</span>, <span class="hljs-string">'fontVariant'</span>, <span class="hljs-string">'fontVariantAlternates'</span>, <span class="hljs-string">'fontVariantCaps'</span>, <span class="hljs-string">'fontVariantEastAsian'</span>, <span class="hljs-string">'fontVariantLigatures'</span>, <span class="hljs-string">'fontVariantNumeric'</span>, <span class="hljs-string">'fontVariantPosition'</span>, <span class="hljs-string">'fontWeight'</span>, <span class="hljs-string">'lineHeight'</span>],
      <span class="hljs-attr">fontVariant</span>: [<span class="hljs-string">'fontVariantAlternates'</span>, <span class="hljs-string">'fontVariantCaps'</span>, <span class="hljs-string">'fontVariantEastAsian'</span>, <span class="hljs-string">'fontVariantLigatures'</span>, <span class="hljs-string">'fontVariantNumeric'</span>, <span class="hljs-string">'fontVariantPosition'</span>],
      <span class="hljs-attr">gap</span>: [<span class="hljs-string">'columnGap'</span>, <span class="hljs-string">'rowGap'</span>],
      <span class="hljs-attr">grid</span>: [<span class="hljs-string">'gridAutoColumns'</span>, <span class="hljs-string">'gridAutoFlow'</span>, <span class="hljs-string">'gridAutoRows'</span>, <span class="hljs-string">'gridTemplateAreas'</span>, <span class="hljs-string">'gridTemplateColumns'</span>, <span class="hljs-string">'gridTemplateRows'</span>],
      <span class="hljs-attr">gridArea</span>: [<span class="hljs-string">'gridColumnEnd'</span>, <span class="hljs-string">'gridColumnStart'</span>, <span class="hljs-string">'gridRowEnd'</span>, <span class="hljs-string">'gridRowStart'</span>],
      <span class="hljs-attr">gridColumn</span>: [<span class="hljs-string">'gridColumnEnd'</span>, <span class="hljs-string">'gridColumnStart'</span>],
      <span class="hljs-attr">gridColumnGap</span>: [<span class="hljs-string">'columnGap'</span>],
      <span class="hljs-attr">gridGap</span>: [<span class="hljs-string">'columnGap'</span>, <span class="hljs-string">'rowGap'</span>],
      <span class="hljs-attr">gridRow</span>: [<span class="hljs-string">'gridRowEnd'</span>, <span class="hljs-string">'gridRowStart'</span>],
      <span class="hljs-attr">gridRowGap</span>: [<span class="hljs-string">'rowGap'</span>],
      <span class="hljs-attr">gridTemplate</span>: [<span class="hljs-string">'gridTemplateAreas'</span>, <span class="hljs-string">'gridTemplateColumns'</span>, <span class="hljs-string">'gridTemplateRows'</span>],
      <span class="hljs-attr">listStyle</span>: [<span class="hljs-string">'listStyleImage'</span>, <span class="hljs-string">'listStylePosition'</span>, <span class="hljs-string">'listStyleType'</span>],
      <span class="hljs-attr">margin</span>: [<span class="hljs-string">'marginBottom'</span>, <span class="hljs-string">'marginLeft'</span>, <span class="hljs-string">'marginRight'</span>, <span class="hljs-string">'marginTop'</span>],
      <span class="hljs-attr">marker</span>: [<span class="hljs-string">'markerEnd'</span>, <span class="hljs-string">'markerMid'</span>, <span class="hljs-string">'markerStart'</span>],
      <span class="hljs-attr">mask</span>: [<span class="hljs-string">'maskClip'</span>, <span class="hljs-string">'maskComposite'</span>, <span class="hljs-string">'maskImage'</span>, <span class="hljs-string">'maskMode'</span>, <span class="hljs-string">'maskOrigin'</span>, <span class="hljs-string">'maskPositionX'</span>, <span class="hljs-string">'maskPositionY'</span>, <span class="hljs-string">'maskRepeat'</span>, <span class="hljs-string">'maskSize'</span>],
      <span class="hljs-attr">maskPosition</span>: [<span class="hljs-string">'maskPositionX'</span>, <span class="hljs-string">'maskPositionY'</span>],
      <span class="hljs-attr">outline</span>: [<span class="hljs-string">'outlineColor'</span>, <span class="hljs-string">'outlineStyle'</span>, <span class="hljs-string">'outlineWidth'</span>],
      <span class="hljs-attr">overflow</span>: [<span class="hljs-string">'overflowX'</span>, <span class="hljs-string">'overflowY'</span>],
      <span class="hljs-attr">padding</span>: [<span class="hljs-string">'paddingBottom'</span>, <span class="hljs-string">'paddingLeft'</span>, <span class="hljs-string">'paddingRight'</span>, <span class="hljs-string">'paddingTop'</span>],
      <span class="hljs-attr">placeContent</span>: [<span class="hljs-string">'alignContent'</span>, <span class="hljs-string">'justifyContent'</span>],
      <span class="hljs-attr">placeItems</span>: [<span class="hljs-string">'alignItems'</span>, <span class="hljs-string">'justifyItems'</span>],
      <span class="hljs-attr">placeSelf</span>: [<span class="hljs-string">'alignSelf'</span>, <span class="hljs-string">'justifySelf'</span>],
      <span class="hljs-attr">textDecoration</span>: [<span class="hljs-string">'textDecorationColor'</span>, <span class="hljs-string">'textDecorationLine'</span>, <span class="hljs-string">'textDecorationStyle'</span>],
      <span class="hljs-attr">textEmphasis</span>: [<span class="hljs-string">'textEmphasisColor'</span>, <span class="hljs-string">'textEmphasisStyle'</span>],
      <span class="hljs-attr">transition</span>: [<span class="hljs-string">'transitionDelay'</span>, <span class="hljs-string">'transitionDuration'</span>, <span class="hljs-string">'transitionProperty'</span>, <span class="hljs-string">'transitionTimingFunction'</span>],
      <span class="hljs-attr">wordWrap</span>: [<span class="hljs-string">'overflowWrap'</span>]
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-370" id="section-370"></a>
</div>
<div class="dox">
<div class="summary">
<p>CSS properties which accept numbers but are not in units of &quot;px&quot;.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> isUnitlessNumber = {
      <span class="hljs-attr">animationIterationCount</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">borderImageOutset</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">borderImageSlice</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">borderImageWidth</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">boxFlex</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">boxFlexGroup</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">boxOrdinalGroup</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">columnCount</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">columns</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">flex</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">flexGrow</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">flexPositive</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">flexShrink</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">flexNegative</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">flexOrder</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridArea</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridRow</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridRowEnd</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridRowSpan</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridRowStart</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridColumn</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridColumnEnd</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridColumnSpan</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">gridColumnStart</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">fontWeight</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">lineClamp</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">lineHeight</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">opacity</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">order</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">orphans</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">tabSize</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">widows</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">zIndex</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">zoom</span>: <span class="hljs-literal">true</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-371" id="section-371"></a>
</div>
<p>SVG-related properties</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      fillOpacity: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">floodOpacity</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">stopOpacity</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">strokeDasharray</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">strokeDashoffset</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">strokeMiterlimit</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">strokeOpacity</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">strokeWidth</span>: <span class="hljs-literal">true</span>
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-372" id="section-372"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">prefix</span>
<span class="dox_type">string</span>
<span>vendor-specific prefix, eg: Webkit
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">key</span>
<span class="dox_type">string</span>
<span>style name, eg: transitionDuration
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
<span>style name prefixed with <code>prefix</code>, properly camelCased, eg: WebkitTransitionDuration
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prefixKey</span>(<span class="hljs-params">prefix, key</span>) </span>{
      <span class="hljs-keyword">return</span> prefix + key.charAt(<span class="hljs-number">0</span>).toUpperCase() + key.substring(<span class="hljs-number">1</span>);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-373" id="section-373"></a>
</div>
<div class="dox">
<div class="summary">
<p>Support style names that may come passed in prefixed by adding permutations
of vendor prefixes.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> prefixes = [<span class="hljs-string">'Webkit'</span>, <span class="hljs-string">'ms'</span>, <span class="hljs-string">'Moz'</span>, <span class="hljs-string">'O'</span>]; <span class="hljs-comment">// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-374" id="section-374"></a>
</div>
<p>infinite loop, because it iterates over the newly added props too.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-built_in">Object</span>.keys(isUnitlessNumber).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
      prefixes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>{
        isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
      });
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-375" id="section-375"></a>
</div>
<div class="dox">
<div class="summary">
<p>Convert a value into the proper css writable value. The style name <code>name</code>
should be logical (no hyphens), as specified
in <code>CSSProperty.isUnitlessNumber</code>.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">name</span>
<span class="dox_type">string</span>
<span>CSS property name such as <code>topMargin</code>.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">value</span>
<span>CSS property value such as <code>10px</code>.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
<span>Normalized style value with dimensions applied.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dangerousStyleValue</span>(<span class="hljs-params">name, value, isCustomProperty</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-376" id="section-376"></a>
</div>
<p>Note that we've removed escapeTextForBrowser() calls here since the
whole string will be escaped when the attribute is injected into
the markup. If you provide unsafe user data here they can inject
arbitrary CSS which may be problematic (I couldn't repro this):
https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
This is not an XSS hole but instead a potential CSS injection issue
which has lead to a greater discussion about how we're going to
trust URLs moving forward. See #2115901</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> isEmpty = value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'boolean'</span> || value === <span class="hljs-string">''</span>;

      <span class="hljs-keyword">if</span> (isEmpty) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }

      <span class="hljs-keyword">if</span> (!isCustomProperty &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span> &amp;&amp; value !== <span class="hljs-number">0</span> &amp;&amp; !(isUnitlessNumber.hasOwnProperty(name) &amp;&amp; isUnitlessNumber[name])) {
        <span class="hljs-keyword">return</span> value + <span class="hljs-string">'px'</span>; <span class="hljs-comment">// Presumes implicit 'px' suffix for unitless numbers</span>
      }

      <span class="hljs-keyword">return</span> (<span class="hljs-string">''</span> + value).trim();
    }

    <span class="hljs-keyword">var</span> uppercasePattern = <span class="hljs-regexp">/([A-Z])/g</span>;
    <span class="hljs-keyword">var</span> msPattern = <span class="hljs-regexp">/^ms-/</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-377" id="section-377"></a>
</div>
<div class="dox">
<div class="summary">
<p>Hyphenates a camelcased CSS property name, for example:</p>
</div>
<div class="body">
<blockquote>
<p>hyphenateStyleName('backgroundColor')
&lt; &quot;background-color&quot;
hyphenateStyleName('MozTransition')
&lt; &quot;-moz-transition&quot;
hyphenateStyleName('msTransition')
&lt; &quot;-ms-transition&quot;</p>
</blockquote>
<p>As Modernizr suggests (http://modernizr.com/docs/#prefixed), an <code>ms</code> prefix
is converted to <code>-ms-</code>.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hyphenateStyleName</span>(<span class="hljs-params">name</span>) </span>{
      <span class="hljs-keyword">return</span> name.replace(uppercasePattern, <span class="hljs-string">'-$1'</span>).toLowerCase().replace(msPattern, <span class="hljs-string">'-ms-'</span>);
    }

    <span class="hljs-keyword">var</span> warnValidStyle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

    {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-378" id="section-378"></a>
</div>
<p>'msTransform' is correct, but the other prefixes should be capitalized</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> badVendoredStyleNamePattern = <span class="hljs-regexp">/^(?:webkit|moz|o)[A-Z]/</span>;
      <span class="hljs-keyword">var</span> msPattern$<span class="hljs-number">1</span> = <span class="hljs-regexp">/^-ms-/</span>;
      <span class="hljs-keyword">var</span> hyphenPattern = <span class="hljs-regexp">/-(.)/g</span>; <span class="hljs-comment">// style values shouldn't contain a semicolon</span>

      <span class="hljs-keyword">var</span> badStyleValueWithSemicolonPattern = <span class="hljs-regexp">/;\s*$/</span>;
      <span class="hljs-keyword">var</span> warnedStyleNames = {};
      <span class="hljs-keyword">var</span> warnedStyleValues = {};
      <span class="hljs-keyword">var</span> warnedForNaNValue = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> warnedForInfinityValue = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">var</span> camelize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) </span>{
        <span class="hljs-keyword">return</span> string.replace(hyphenPattern, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, character</span>) </span>{
          <span class="hljs-keyword">return</span> character.toUpperCase();
        });
      };

      <span class="hljs-keyword">var</span> warnHyphenatedStyleName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (warnedStyleNames.hasOwnProperty(name) &amp;&amp; warnedStyleNames[name]) {
          <span class="hljs-keyword">return</span>;
        }

        warnedStyleNames[name] = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Unsupported style property %s. Did you mean %s?'</span>, name, <span class="hljs-comment">// As Andi Smith suggests</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-379" id="section-379"></a>
</div>
<p>(http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an <code>-ms</code> prefix
is converted to lowercase <code>ms</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        camelize(name.replace(msPattern$<span class="hljs-number">1</span>, <span class="hljs-string">'ms-'</span>)));
      };

      <span class="hljs-keyword">var</span> warnBadVendoredStyleName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">if</span> (warnedStyleNames.hasOwnProperty(name) &amp;&amp; warnedStyleNames[name]) {
          <span class="hljs-keyword">return</span>;
        }

        warnedStyleNames[name] = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Unsupported vendor-prefixed style property %s. Did you mean %s?'</span>, name, name.charAt(<span class="hljs-number">0</span>).toUpperCase() + name.slice(<span class="hljs-number">1</span>));
      };

      <span class="hljs-keyword">var</span> warnStyleValueWithSemicolon = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">if</span> (warnedStyleValues.hasOwnProperty(value) &amp;&amp; warnedStyleValues[value]) {
          <span class="hljs-keyword">return</span>;
        }

        warnedStyleValues[value] = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">"Style property values shouldn't contain a semicolon. "</span> + <span class="hljs-string">'Try "%s: %s" instead.'</span>, name, value.replace(badStyleValueWithSemicolonPattern, <span class="hljs-string">''</span>));
      };

      <span class="hljs-keyword">var</span> warnStyleValueIsNaN = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">if</span> (warnedForNaNValue) {
          <span class="hljs-keyword">return</span>;
        }

        warnedForNaNValue = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'`NaN` is an invalid value for the `%s` css style property.'</span>, name);
      };

      <span class="hljs-keyword">var</span> warnStyleValueIsInfinity = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">if</span> (warnedForInfinityValue) {
          <span class="hljs-keyword">return</span>;
        }

        warnedForInfinityValue = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'`Infinity` is an invalid value for the `%s` css style property.'</span>, name);
      };

      warnValidStyle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
        <span class="hljs-keyword">if</span> (name.indexOf(<span class="hljs-string">'-'</span>) &gt; <span class="hljs-number">-1</span>) {
          warnHyphenatedStyleName(name);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (badVendoredStyleNamePattern.test(name)) {
          warnBadVendoredStyleName(name);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (badStyleValueWithSemicolonPattern.test(value)) {
          warnStyleValueWithSemicolon(name, value);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(value)) {
            warnStyleValueIsNaN(name, value);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFinite</span>(value)) {
            warnStyleValueIsInfinity(name, value);
          }
        }
      };
    }
    <span class="hljs-keyword">var</span> warnValidStyle$<span class="hljs-number">1</span> = warnValidStyle;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-380" id="section-380"></a>
</div>
<div class="dox">
<div class="summary">
<p>Operations for dealing with CSS properties.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-381" id="section-381"></a>
</div>
<div class="dox">
<div class="summary">
<p>This creates a string that is expected to be equivalent to the style
attribute generated by server-side rendering. It by-passes warnings and
security checks so it's not safe to use this value for anything other than
comparison. It is only used in DEV for SSR validation.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDangerousStringForStyles</span>(<span class="hljs-params">styles</span>) </span>{
      {
        <span class="hljs-keyword">var</span> serialized = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">var</span> delimiter = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> styleName <span class="hljs-keyword">in</span> styles) {
          <span class="hljs-keyword">if</span> (!styles.hasOwnProperty(styleName)) {
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">var</span> styleValue = styles[styleName];

          <span class="hljs-keyword">if</span> (styleValue != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> isCustomProperty = styleName.indexOf(<span class="hljs-string">'--'</span>) === <span class="hljs-number">0</span>;
            serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + <span class="hljs-string">':'</span>;
            serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
            delimiter = <span class="hljs-string">';'</span>;
          }
        }

        <span class="hljs-keyword">return</span> serialized || <span class="hljs-literal">null</span>;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-382" id="section-382"></a>
</div>
<div class="dox">
<div class="summary">
<p>Sets the value for multiple styles on a node.  If a value is specified as
'' (empty string), the corresponding style property will be unset.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">styles</span>
<span class="dox_type">object</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setValueForStyles</span>(<span class="hljs-params">node, styles</span>) </span>{
      <span class="hljs-keyword">var</span> style = node.style;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> styleName <span class="hljs-keyword">in</span> styles) {
        <span class="hljs-keyword">if</span> (!styles.hasOwnProperty(styleName)) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> isCustomProperty = styleName.indexOf(<span class="hljs-string">'--'</span>) === <span class="hljs-number">0</span>;
        {
          <span class="hljs-keyword">if</span> (!isCustomProperty) {
            warnValidStyle$<span class="hljs-number">1</span>(styleName, styles[styleName]);
          }
        }
        <span class="hljs-keyword">var</span> styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);

        <span class="hljs-keyword">if</span> (styleName === <span class="hljs-string">'float'</span>) {
          styleName = <span class="hljs-string">'cssFloat'</span>;
        }

        <span class="hljs-keyword">if</span> (isCustomProperty) {
          style.setProperty(styleName, styleValue);
        } <span class="hljs-keyword">else</span> {
          style[styleName] = styleValue;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValueEmpty</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'boolean'</span> || value === <span class="hljs-string">''</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-383" id="section-383"></a>
</div>
<div class="dox">
<div class="summary">
<p>Given {color: 'red', overflow: 'hidden'} returns {
color: 'color',
overflowX: 'overflow',
overflowY: 'overflow',
}. This can be read as &quot;the overflowY property was set by the overflow
shorthand&quot;. That is, the values are the property that each was derived from.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expandShorthandMap</span>(<span class="hljs-params">styles</span>) </span>{
      <span class="hljs-keyword">var</span> expanded = {};

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> styles) {
        <span class="hljs-keyword">var</span> longhands = shorthandToLonghand[key] || [key];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; longhands.length; i++) {
          expanded[longhands[i]] = key;
        }
      }

      <span class="hljs-keyword">return</span> expanded;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-384" id="section-384"></a>
</div>
<div class="dox">
<div class="summary">
<p>When mixing shorthand and longhand property names, we warn during updates if
we expect an incorrect result to occur. In particular, we warn for:</p>
</div>
<div class="body">
<p>Updating a shorthand property (longhand gets overwritten):
{font: 'foo', fontVariant: 'bar'} -&gt; {font: 'baz', fontVariant: 'bar'}
becomes .style.font = 'baz'
Removing a shorthand property (longhand gets lost too):
{font: 'foo', fontVariant: 'bar'} -&gt; {fontVariant: 'bar'}
becomes .style.font = ''
Removing a longhand property (should revert to shorthand; doesn't):
{font: 'foo', fontVariant: 'bar'} -&gt; {font: 'foo'}
becomes .style.fontVariant = ''</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateShorthandPropertyCollisionInDev</span>(<span class="hljs-params">styleUpdates, nextStyles</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!nextStyles) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> expandedUpdates = expandShorthandMap(styleUpdates);
        <span class="hljs-keyword">var</span> expandedStyles = expandShorthandMap(nextStyles);
        <span class="hljs-keyword">var</span> warnedAbout = {};

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> expandedUpdates) {
          <span class="hljs-keyword">var</span> originalKey = expandedUpdates[key];
          <span class="hljs-keyword">var</span> correctOriginalKey = expandedStyles[key];

          <span class="hljs-keyword">if</span> (correctOriginalKey &amp;&amp; originalKey !== correctOriginalKey) {
            <span class="hljs-keyword">var</span> warningKey = originalKey + <span class="hljs-string">','</span> + correctOriginalKey;

            <span class="hljs-keyword">if</span> (warnedAbout[warningKey]) {
              <span class="hljs-keyword">continue</span>;
            }

            warnedAbout[warningKey] = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'%s a style property during rerender (%s) when a '</span> + <span class="hljs-string">'conflicting property is set (%s) can lead to styling bugs. To '</span> + <span class="hljs-string">"avoid this, don't mix shorthand and non-shorthand properties "</span> + <span class="hljs-string">'for the same value; instead, replace the shorthand with '</span> + <span class="hljs-string">'separate values.'</span>, isValueEmpty(styleUpdates[originalKey]) ? <span class="hljs-string">'Removing'</span> : <span class="hljs-string">'Updating'</span>, originalKey, correctOriginalKey);
          }
        }
      }
    } <span class="hljs-comment">// For HTML, certain tags should omit their close tag. We keep a whitelist for</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-385" id="section-385"></a>
</div>
<p>those special-case tags.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> omittedCloseTags = {
      <span class="hljs-attr">area</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">base</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">br</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">col</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">embed</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">hr</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">img</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">input</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">keygen</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">link</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">meta</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">param</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">source</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">track</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">wbr</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> menuitem's close tag should be omitted, but that causes problems.</span>

    }; <span class="hljs-comment">// `omittedCloseTags` except that `menuitem` should still have its closing tag.</span>

    <span class="hljs-keyword">var</span> voidElementTags = _assign({
      <span class="hljs-attr">menuitem</span>: <span class="hljs-literal">true</span>
    }, omittedCloseTags);

    <span class="hljs-keyword">var</span> HTML = <span class="hljs-string">'__html'</span>;
    <span class="hljs-keyword">var</span> ReactDebugCurrentFrame$<span class="hljs-number">3</span> = <span class="hljs-literal">null</span>;
    {
      ReactDebugCurrentFrame$<span class="hljs-number">3</span> = ReactSharedInternals.ReactDebugCurrentFrame;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertValidProps</span>(<span class="hljs-params">tag, props</span>) </span>{
      <span class="hljs-keyword">if</span> (!props) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// Note the use of `==` which checks for null or undefined.</span>


      <span class="hljs-keyword">if</span> (voidElementTags[tag]) {
        <span class="hljs-keyword">if</span> (!(props.children == <span class="hljs-literal">null</span> &amp;&amp; props.dangerouslySetInnerHTML == <span class="hljs-literal">null</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(tag + <span class="hljs-string">" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."</span> + ReactDebugCurrentFrame$<span class="hljs-number">3.</span>getStackAddendum());
          }
        }
      }

      <span class="hljs-keyword">if</span> (props.dangerouslySetInnerHTML != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (!(props.children == <span class="hljs-literal">null</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Can only set one of `children` or `props.dangerouslySetInnerHTML`."</span>);
          }
        }

        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> props.dangerouslySetInnerHTML === <span class="hljs-string">'object'</span> &amp;&amp; HTML <span class="hljs-keyword">in</span> props.dangerouslySetInnerHTML)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information."</span>);
          }
        }
      }

      {
        <span class="hljs-keyword">if</span> (!props.suppressContentEditableWarning &amp;&amp; props.contentEditable &amp;&amp; props.children != <span class="hljs-literal">null</span>) {
          error(<span class="hljs-string">'A component is `contentEditable` and contains `children` managed by '</span> + <span class="hljs-string">'React. It is now your responsibility to guarantee that none of '</span> + <span class="hljs-string">'those nodes are unexpectedly modified or duplicated. This is '</span> + <span class="hljs-string">'probably not intentional.'</span>);
        }
      }

      <span class="hljs-keyword">if</span> (!(props.style == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> props.style === <span class="hljs-string">'object'</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."</span> + ReactDebugCurrentFrame$<span class="hljs-number">3.</span>getStackAddendum());
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCustomComponent</span>(<span class="hljs-params">tagName, props</span>) </span>{
      <span class="hljs-keyword">if</span> (tagName.indexOf(<span class="hljs-string">'-'</span>) === <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> props.is === <span class="hljs-string">'string'</span>;
      }

      <span class="hljs-keyword">switch</span> (tagName) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-386" id="section-386"></a>
</div>
<p>These are reserved SVG and MathML elements.
We don't mind this whitelist too much because we expect it to never grow.
The alternative is to track the namespace in a few places which is convoluted.
https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">case</span> <span class="hljs-string">'annotation-xml'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'color-profile'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'font-face'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'font-face-src'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'font-face-uri'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'font-face-format'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'font-face-name'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'missing-glyph'</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    } <span class="hljs-comment">// When adding attributes to the HTML or SVG whitelist, be sure to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-387" id="section-387"></a>
</div>
<p>also add them to this module to ensure casing and incorrect name
warnings.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> possibleStandardNames = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-388" id="section-388"></a>
</div>
<p>HTML</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      accept: <span class="hljs-string">'accept'</span>,
      <span class="hljs-attr">acceptcharset</span>: <span class="hljs-string">'acceptCharset'</span>,
      <span class="hljs-string">'accept-charset'</span>: <span class="hljs-string">'acceptCharset'</span>,
      <span class="hljs-attr">accesskey</span>: <span class="hljs-string">'accessKey'</span>,
      <span class="hljs-attr">action</span>: <span class="hljs-string">'action'</span>,
      <span class="hljs-attr">allowfullscreen</span>: <span class="hljs-string">'allowFullScreen'</span>,
      <span class="hljs-attr">alt</span>: <span class="hljs-string">'alt'</span>,
      <span class="hljs-attr">as</span>: <span class="hljs-string">'as'</span>,
      <span class="hljs-attr">async</span>: <span class="hljs-string">'async'</span>,
      <span class="hljs-attr">autocapitalize</span>: <span class="hljs-string">'autoCapitalize'</span>,
      <span class="hljs-attr">autocomplete</span>: <span class="hljs-string">'autoComplete'</span>,
      <span class="hljs-attr">autocorrect</span>: <span class="hljs-string">'autoCorrect'</span>,
      <span class="hljs-attr">autofocus</span>: <span class="hljs-string">'autoFocus'</span>,
      <span class="hljs-attr">autoplay</span>: <span class="hljs-string">'autoPlay'</span>,
      <span class="hljs-attr">autosave</span>: <span class="hljs-string">'autoSave'</span>,
      <span class="hljs-attr">capture</span>: <span class="hljs-string">'capture'</span>,
      <span class="hljs-attr">cellpadding</span>: <span class="hljs-string">'cellPadding'</span>,
      <span class="hljs-attr">cellspacing</span>: <span class="hljs-string">'cellSpacing'</span>,
      <span class="hljs-attr">challenge</span>: <span class="hljs-string">'challenge'</span>,
      <span class="hljs-attr">charset</span>: <span class="hljs-string">'charSet'</span>,
      <span class="hljs-attr">checked</span>: <span class="hljs-string">'checked'</span>,
      <span class="hljs-attr">children</span>: <span class="hljs-string">'children'</span>,
      <span class="hljs-attr">cite</span>: <span class="hljs-string">'cite'</span>,
      <span class="hljs-attr">class</span>: <span class="hljs-string">'className'</span>,
      <span class="hljs-attr">classid</span>: <span class="hljs-string">'classID'</span>,
      <span class="hljs-attr">classname</span>: <span class="hljs-string">'className'</span>,
      <span class="hljs-attr">cols</span>: <span class="hljs-string">'cols'</span>,
      <span class="hljs-attr">colspan</span>: <span class="hljs-string">'colSpan'</span>,
      <span class="hljs-attr">content</span>: <span class="hljs-string">'content'</span>,
      <span class="hljs-attr">contenteditable</span>: <span class="hljs-string">'contentEditable'</span>,
      <span class="hljs-attr">contextmenu</span>: <span class="hljs-string">'contextMenu'</span>,
      <span class="hljs-attr">controls</span>: <span class="hljs-string">'controls'</span>,
      <span class="hljs-attr">controlslist</span>: <span class="hljs-string">'controlsList'</span>,
      <span class="hljs-attr">coords</span>: <span class="hljs-string">'coords'</span>,
      <span class="hljs-attr">crossorigin</span>: <span class="hljs-string">'crossOrigin'</span>,
      <span class="hljs-attr">dangerouslysetinnerhtml</span>: <span class="hljs-string">'dangerouslySetInnerHTML'</span>,
      <span class="hljs-attr">data</span>: <span class="hljs-string">'data'</span>,
      <span class="hljs-attr">datetime</span>: <span class="hljs-string">'dateTime'</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-string">'default'</span>,
      <span class="hljs-attr">defaultchecked</span>: <span class="hljs-string">'defaultChecked'</span>,
      <span class="hljs-attr">defaultvalue</span>: <span class="hljs-string">'defaultValue'</span>,
      <span class="hljs-attr">defer</span>: <span class="hljs-string">'defer'</span>,
      <span class="hljs-attr">dir</span>: <span class="hljs-string">'dir'</span>,
      <span class="hljs-attr">disabled</span>: <span class="hljs-string">'disabled'</span>,
      <span class="hljs-attr">disablepictureinpicture</span>: <span class="hljs-string">'disablePictureInPicture'</span>,
      <span class="hljs-attr">download</span>: <span class="hljs-string">'download'</span>,
      <span class="hljs-attr">draggable</span>: <span class="hljs-string">'draggable'</span>,
      <span class="hljs-attr">enctype</span>: <span class="hljs-string">'encType'</span>,
      <span class="hljs-attr">for</span>: <span class="hljs-string">'htmlFor'</span>,
      <span class="hljs-attr">form</span>: <span class="hljs-string">'form'</span>,
      <span class="hljs-attr">formmethod</span>: <span class="hljs-string">'formMethod'</span>,
      <span class="hljs-attr">formaction</span>: <span class="hljs-string">'formAction'</span>,
      <span class="hljs-attr">formenctype</span>: <span class="hljs-string">'formEncType'</span>,
      <span class="hljs-attr">formnovalidate</span>: <span class="hljs-string">'formNoValidate'</span>,
      <span class="hljs-attr">formtarget</span>: <span class="hljs-string">'formTarget'</span>,
      <span class="hljs-attr">frameborder</span>: <span class="hljs-string">'frameBorder'</span>,
      <span class="hljs-attr">headers</span>: <span class="hljs-string">'headers'</span>,
      <span class="hljs-attr">height</span>: <span class="hljs-string">'height'</span>,
      <span class="hljs-attr">hidden</span>: <span class="hljs-string">'hidden'</span>,
      <span class="hljs-attr">high</span>: <span class="hljs-string">'high'</span>,
      <span class="hljs-attr">href</span>: <span class="hljs-string">'href'</span>,
      <span class="hljs-attr">hreflang</span>: <span class="hljs-string">'hrefLang'</span>,
      <span class="hljs-attr">htmlfor</span>: <span class="hljs-string">'htmlFor'</span>,
      <span class="hljs-attr">httpequiv</span>: <span class="hljs-string">'httpEquiv'</span>,
      <span class="hljs-string">'http-equiv'</span>: <span class="hljs-string">'httpEquiv'</span>,
      <span class="hljs-attr">icon</span>: <span class="hljs-string">'icon'</span>,
      <span class="hljs-attr">id</span>: <span class="hljs-string">'id'</span>,
      <span class="hljs-attr">innerhtml</span>: <span class="hljs-string">'innerHTML'</span>,
      <span class="hljs-attr">inputmode</span>: <span class="hljs-string">'inputMode'</span>,
      <span class="hljs-attr">integrity</span>: <span class="hljs-string">'integrity'</span>,
      <span class="hljs-attr">is</span>: <span class="hljs-string">'is'</span>,
      <span class="hljs-attr">itemid</span>: <span class="hljs-string">'itemID'</span>,
      <span class="hljs-attr">itemprop</span>: <span class="hljs-string">'itemProp'</span>,
      <span class="hljs-attr">itemref</span>: <span class="hljs-string">'itemRef'</span>,
      <span class="hljs-attr">itemscope</span>: <span class="hljs-string">'itemScope'</span>,
      <span class="hljs-attr">itemtype</span>: <span class="hljs-string">'itemType'</span>,
      <span class="hljs-attr">keyparams</span>: <span class="hljs-string">'keyParams'</span>,
      <span class="hljs-attr">keytype</span>: <span class="hljs-string">'keyType'</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'kind'</span>,
      <span class="hljs-attr">label</span>: <span class="hljs-string">'label'</span>,
      <span class="hljs-attr">lang</span>: <span class="hljs-string">'lang'</span>,
      <span class="hljs-attr">list</span>: <span class="hljs-string">'list'</span>,
      <span class="hljs-attr">loop</span>: <span class="hljs-string">'loop'</span>,
      <span class="hljs-attr">low</span>: <span class="hljs-string">'low'</span>,
      <span class="hljs-attr">manifest</span>: <span class="hljs-string">'manifest'</span>,
      <span class="hljs-attr">marginwidth</span>: <span class="hljs-string">'marginWidth'</span>,
      <span class="hljs-attr">marginheight</span>: <span class="hljs-string">'marginHeight'</span>,
      <span class="hljs-attr">max</span>: <span class="hljs-string">'max'</span>,
      <span class="hljs-attr">maxlength</span>: <span class="hljs-string">'maxLength'</span>,
      <span class="hljs-attr">media</span>: <span class="hljs-string">'media'</span>,
      <span class="hljs-attr">mediagroup</span>: <span class="hljs-string">'mediaGroup'</span>,
      <span class="hljs-attr">method</span>: <span class="hljs-string">'method'</span>,
      <span class="hljs-attr">min</span>: <span class="hljs-string">'min'</span>,
      <span class="hljs-attr">minlength</span>: <span class="hljs-string">'minLength'</span>,
      <span class="hljs-attr">multiple</span>: <span class="hljs-string">'multiple'</span>,
      <span class="hljs-attr">muted</span>: <span class="hljs-string">'muted'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
      <span class="hljs-attr">nomodule</span>: <span class="hljs-string">'noModule'</span>,
      <span class="hljs-attr">nonce</span>: <span class="hljs-string">'nonce'</span>,
      <span class="hljs-attr">novalidate</span>: <span class="hljs-string">'noValidate'</span>,
      <span class="hljs-attr">open</span>: <span class="hljs-string">'open'</span>,
      <span class="hljs-attr">optimum</span>: <span class="hljs-string">'optimum'</span>,
      <span class="hljs-attr">pattern</span>: <span class="hljs-string">'pattern'</span>,
      <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'placeholder'</span>,
      <span class="hljs-attr">playsinline</span>: <span class="hljs-string">'playsInline'</span>,
      <span class="hljs-attr">poster</span>: <span class="hljs-string">'poster'</span>,
      <span class="hljs-attr">preload</span>: <span class="hljs-string">'preload'</span>,
      <span class="hljs-attr">profile</span>: <span class="hljs-string">'profile'</span>,
      <span class="hljs-attr">radiogroup</span>: <span class="hljs-string">'radioGroup'</span>,
      <span class="hljs-attr">readonly</span>: <span class="hljs-string">'readOnly'</span>,
      <span class="hljs-attr">referrerpolicy</span>: <span class="hljs-string">'referrerPolicy'</span>,
      <span class="hljs-attr">rel</span>: <span class="hljs-string">'rel'</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-string">'required'</span>,
      <span class="hljs-attr">reversed</span>: <span class="hljs-string">'reversed'</span>,
      <span class="hljs-attr">role</span>: <span class="hljs-string">'role'</span>,
      <span class="hljs-attr">rows</span>: <span class="hljs-string">'rows'</span>,
      <span class="hljs-attr">rowspan</span>: <span class="hljs-string">'rowSpan'</span>,
      <span class="hljs-attr">sandbox</span>: <span class="hljs-string">'sandbox'</span>,
      <span class="hljs-attr">scope</span>: <span class="hljs-string">'scope'</span>,
      <span class="hljs-attr">scoped</span>: <span class="hljs-string">'scoped'</span>,
      <span class="hljs-attr">scrolling</span>: <span class="hljs-string">'scrolling'</span>,
      <span class="hljs-attr">seamless</span>: <span class="hljs-string">'seamless'</span>,
      <span class="hljs-attr">selected</span>: <span class="hljs-string">'selected'</span>,
      <span class="hljs-attr">shape</span>: <span class="hljs-string">'shape'</span>,
      <span class="hljs-attr">size</span>: <span class="hljs-string">'size'</span>,
      <span class="hljs-attr">sizes</span>: <span class="hljs-string">'sizes'</span>,
      <span class="hljs-attr">span</span>: <span class="hljs-string">'span'</span>,
      <span class="hljs-attr">spellcheck</span>: <span class="hljs-string">'spellCheck'</span>,
      <span class="hljs-attr">src</span>: <span class="hljs-string">'src'</span>,
      <span class="hljs-attr">srcdoc</span>: <span class="hljs-string">'srcDoc'</span>,
      <span class="hljs-attr">srclang</span>: <span class="hljs-string">'srcLang'</span>,
      <span class="hljs-attr">srcset</span>: <span class="hljs-string">'srcSet'</span>,
      <span class="hljs-attr">start</span>: <span class="hljs-string">'start'</span>,
      <span class="hljs-attr">step</span>: <span class="hljs-string">'step'</span>,
      <span class="hljs-attr">style</span>: <span class="hljs-string">'style'</span>,
      <span class="hljs-attr">summary</span>: <span class="hljs-string">'summary'</span>,
      <span class="hljs-attr">tabindex</span>: <span class="hljs-string">'tabIndex'</span>,
      <span class="hljs-attr">target</span>: <span class="hljs-string">'target'</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'title'</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-string">'type'</span>,
      <span class="hljs-attr">usemap</span>: <span class="hljs-string">'useMap'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">'value'</span>,
      <span class="hljs-attr">width</span>: <span class="hljs-string">'width'</span>,
      <span class="hljs-attr">wmode</span>: <span class="hljs-string">'wmode'</span>,
      <span class="hljs-attr">wrap</span>: <span class="hljs-string">'wrap'</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-389" id="section-389"></a>
</div>
<p>SVG</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      about: <span class="hljs-string">'about'</span>,
      <span class="hljs-attr">accentheight</span>: <span class="hljs-string">'accentHeight'</span>,
      <span class="hljs-string">'accent-height'</span>: <span class="hljs-string">'accentHeight'</span>,
      <span class="hljs-attr">accumulate</span>: <span class="hljs-string">'accumulate'</span>,
      <span class="hljs-attr">additive</span>: <span class="hljs-string">'additive'</span>,
      <span class="hljs-attr">alignmentbaseline</span>: <span class="hljs-string">'alignmentBaseline'</span>,
      <span class="hljs-string">'alignment-baseline'</span>: <span class="hljs-string">'alignmentBaseline'</span>,
      <span class="hljs-attr">allowreorder</span>: <span class="hljs-string">'allowReorder'</span>,
      <span class="hljs-attr">alphabetic</span>: <span class="hljs-string">'alphabetic'</span>,
      <span class="hljs-attr">amplitude</span>: <span class="hljs-string">'amplitude'</span>,
      <span class="hljs-attr">arabicform</span>: <span class="hljs-string">'arabicForm'</span>,
      <span class="hljs-string">'arabic-form'</span>: <span class="hljs-string">'arabicForm'</span>,
      <span class="hljs-attr">ascent</span>: <span class="hljs-string">'ascent'</span>,
      <span class="hljs-attr">attributename</span>: <span class="hljs-string">'attributeName'</span>,
      <span class="hljs-attr">attributetype</span>: <span class="hljs-string">'attributeType'</span>,
      <span class="hljs-attr">autoreverse</span>: <span class="hljs-string">'autoReverse'</span>,
      <span class="hljs-attr">azimuth</span>: <span class="hljs-string">'azimuth'</span>,
      <span class="hljs-attr">basefrequency</span>: <span class="hljs-string">'baseFrequency'</span>,
      <span class="hljs-attr">baselineshift</span>: <span class="hljs-string">'baselineShift'</span>,
      <span class="hljs-string">'baseline-shift'</span>: <span class="hljs-string">'baselineShift'</span>,
      <span class="hljs-attr">baseprofile</span>: <span class="hljs-string">'baseProfile'</span>,
      <span class="hljs-attr">bbox</span>: <span class="hljs-string">'bbox'</span>,
      <span class="hljs-attr">begin</span>: <span class="hljs-string">'begin'</span>,
      <span class="hljs-attr">bias</span>: <span class="hljs-string">'bias'</span>,
      <span class="hljs-attr">by</span>: <span class="hljs-string">'by'</span>,
      <span class="hljs-attr">calcmode</span>: <span class="hljs-string">'calcMode'</span>,
      <span class="hljs-attr">capheight</span>: <span class="hljs-string">'capHeight'</span>,
      <span class="hljs-string">'cap-height'</span>: <span class="hljs-string">'capHeight'</span>,
      <span class="hljs-attr">clip</span>: <span class="hljs-string">'clip'</span>,
      <span class="hljs-attr">clippath</span>: <span class="hljs-string">'clipPath'</span>,
      <span class="hljs-string">'clip-path'</span>: <span class="hljs-string">'clipPath'</span>,
      <span class="hljs-attr">clippathunits</span>: <span class="hljs-string">'clipPathUnits'</span>,
      <span class="hljs-attr">cliprule</span>: <span class="hljs-string">'clipRule'</span>,
      <span class="hljs-string">'clip-rule'</span>: <span class="hljs-string">'clipRule'</span>,
      <span class="hljs-attr">color</span>: <span class="hljs-string">'color'</span>,
      <span class="hljs-attr">colorinterpolation</span>: <span class="hljs-string">'colorInterpolation'</span>,
      <span class="hljs-string">'color-interpolation'</span>: <span class="hljs-string">'colorInterpolation'</span>,
      <span class="hljs-attr">colorinterpolationfilters</span>: <span class="hljs-string">'colorInterpolationFilters'</span>,
      <span class="hljs-string">'color-interpolation-filters'</span>: <span class="hljs-string">'colorInterpolationFilters'</span>,
      <span class="hljs-attr">colorprofile</span>: <span class="hljs-string">'colorProfile'</span>,
      <span class="hljs-string">'color-profile'</span>: <span class="hljs-string">'colorProfile'</span>,
      <span class="hljs-attr">colorrendering</span>: <span class="hljs-string">'colorRendering'</span>,
      <span class="hljs-string">'color-rendering'</span>: <span class="hljs-string">'colorRendering'</span>,
      <span class="hljs-attr">contentscripttype</span>: <span class="hljs-string">'contentScriptType'</span>,
      <span class="hljs-attr">contentstyletype</span>: <span class="hljs-string">'contentStyleType'</span>,
      <span class="hljs-attr">cursor</span>: <span class="hljs-string">'cursor'</span>,
      <span class="hljs-attr">cx</span>: <span class="hljs-string">'cx'</span>,
      <span class="hljs-attr">cy</span>: <span class="hljs-string">'cy'</span>,
      <span class="hljs-attr">d</span>: <span class="hljs-string">'d'</span>,
      <span class="hljs-attr">datatype</span>: <span class="hljs-string">'datatype'</span>,
      <span class="hljs-attr">decelerate</span>: <span class="hljs-string">'decelerate'</span>,
      <span class="hljs-attr">descent</span>: <span class="hljs-string">'descent'</span>,
      <span class="hljs-attr">diffuseconstant</span>: <span class="hljs-string">'diffuseConstant'</span>,
      <span class="hljs-attr">direction</span>: <span class="hljs-string">'direction'</span>,
      <span class="hljs-attr">display</span>: <span class="hljs-string">'display'</span>,
      <span class="hljs-attr">divisor</span>: <span class="hljs-string">'divisor'</span>,
      <span class="hljs-attr">dominantbaseline</span>: <span class="hljs-string">'dominantBaseline'</span>,
      <span class="hljs-string">'dominant-baseline'</span>: <span class="hljs-string">'dominantBaseline'</span>,
      <span class="hljs-attr">dur</span>: <span class="hljs-string">'dur'</span>,
      <span class="hljs-attr">dx</span>: <span class="hljs-string">'dx'</span>,
      <span class="hljs-attr">dy</span>: <span class="hljs-string">'dy'</span>,
      <span class="hljs-attr">edgemode</span>: <span class="hljs-string">'edgeMode'</span>,
      <span class="hljs-attr">elevation</span>: <span class="hljs-string">'elevation'</span>,
      <span class="hljs-attr">enablebackground</span>: <span class="hljs-string">'enableBackground'</span>,
      <span class="hljs-string">'enable-background'</span>: <span class="hljs-string">'enableBackground'</span>,
      <span class="hljs-attr">end</span>: <span class="hljs-string">'end'</span>,
      <span class="hljs-attr">exponent</span>: <span class="hljs-string">'exponent'</span>,
      <span class="hljs-attr">externalresourcesrequired</span>: <span class="hljs-string">'externalResourcesRequired'</span>,
      <span class="hljs-attr">fill</span>: <span class="hljs-string">'fill'</span>,
      <span class="hljs-attr">fillopacity</span>: <span class="hljs-string">'fillOpacity'</span>,
      <span class="hljs-string">'fill-opacity'</span>: <span class="hljs-string">'fillOpacity'</span>,
      <span class="hljs-attr">fillrule</span>: <span class="hljs-string">'fillRule'</span>,
      <span class="hljs-string">'fill-rule'</span>: <span class="hljs-string">'fillRule'</span>,
      <span class="hljs-attr">filter</span>: <span class="hljs-string">'filter'</span>,
      <span class="hljs-attr">filterres</span>: <span class="hljs-string">'filterRes'</span>,
      <span class="hljs-attr">filterunits</span>: <span class="hljs-string">'filterUnits'</span>,
      <span class="hljs-attr">floodopacity</span>: <span class="hljs-string">'floodOpacity'</span>,
      <span class="hljs-string">'flood-opacity'</span>: <span class="hljs-string">'floodOpacity'</span>,
      <span class="hljs-attr">floodcolor</span>: <span class="hljs-string">'floodColor'</span>,
      <span class="hljs-string">'flood-color'</span>: <span class="hljs-string">'floodColor'</span>,
      <span class="hljs-attr">focusable</span>: <span class="hljs-string">'focusable'</span>,
      <span class="hljs-attr">fontfamily</span>: <span class="hljs-string">'fontFamily'</span>,
      <span class="hljs-string">'font-family'</span>: <span class="hljs-string">'fontFamily'</span>,
      <span class="hljs-attr">fontsize</span>: <span class="hljs-string">'fontSize'</span>,
      <span class="hljs-string">'font-size'</span>: <span class="hljs-string">'fontSize'</span>,
      <span class="hljs-attr">fontsizeadjust</span>: <span class="hljs-string">'fontSizeAdjust'</span>,
      <span class="hljs-string">'font-size-adjust'</span>: <span class="hljs-string">'fontSizeAdjust'</span>,
      <span class="hljs-attr">fontstretch</span>: <span class="hljs-string">'fontStretch'</span>,
      <span class="hljs-string">'font-stretch'</span>: <span class="hljs-string">'fontStretch'</span>,
      <span class="hljs-attr">fontstyle</span>: <span class="hljs-string">'fontStyle'</span>,
      <span class="hljs-string">'font-style'</span>: <span class="hljs-string">'fontStyle'</span>,
      <span class="hljs-attr">fontvariant</span>: <span class="hljs-string">'fontVariant'</span>,
      <span class="hljs-string">'font-variant'</span>: <span class="hljs-string">'fontVariant'</span>,
      <span class="hljs-attr">fontweight</span>: <span class="hljs-string">'fontWeight'</span>,
      <span class="hljs-string">'font-weight'</span>: <span class="hljs-string">'fontWeight'</span>,
      <span class="hljs-attr">format</span>: <span class="hljs-string">'format'</span>,
      <span class="hljs-attr">from</span>: <span class="hljs-string">'from'</span>,
      <span class="hljs-attr">fx</span>: <span class="hljs-string">'fx'</span>,
      <span class="hljs-attr">fy</span>: <span class="hljs-string">'fy'</span>,
      <span class="hljs-attr">g1</span>: <span class="hljs-string">'g1'</span>,
      <span class="hljs-attr">g2</span>: <span class="hljs-string">'g2'</span>,
      <span class="hljs-attr">glyphname</span>: <span class="hljs-string">'glyphName'</span>,
      <span class="hljs-string">'glyph-name'</span>: <span class="hljs-string">'glyphName'</span>,
      <span class="hljs-attr">glyphorientationhorizontal</span>: <span class="hljs-string">'glyphOrientationHorizontal'</span>,
      <span class="hljs-string">'glyph-orientation-horizontal'</span>: <span class="hljs-string">'glyphOrientationHorizontal'</span>,
      <span class="hljs-attr">glyphorientationvertical</span>: <span class="hljs-string">'glyphOrientationVertical'</span>,
      <span class="hljs-string">'glyph-orientation-vertical'</span>: <span class="hljs-string">'glyphOrientationVertical'</span>,
      <span class="hljs-attr">glyphref</span>: <span class="hljs-string">'glyphRef'</span>,
      <span class="hljs-attr">gradienttransform</span>: <span class="hljs-string">'gradientTransform'</span>,
      <span class="hljs-attr">gradientunits</span>: <span class="hljs-string">'gradientUnits'</span>,
      <span class="hljs-attr">hanging</span>: <span class="hljs-string">'hanging'</span>,
      <span class="hljs-attr">horizadvx</span>: <span class="hljs-string">'horizAdvX'</span>,
      <span class="hljs-string">'horiz-adv-x'</span>: <span class="hljs-string">'horizAdvX'</span>,
      <span class="hljs-attr">horizoriginx</span>: <span class="hljs-string">'horizOriginX'</span>,
      <span class="hljs-string">'horiz-origin-x'</span>: <span class="hljs-string">'horizOriginX'</span>,
      <span class="hljs-attr">ideographic</span>: <span class="hljs-string">'ideographic'</span>,
      <span class="hljs-attr">imagerendering</span>: <span class="hljs-string">'imageRendering'</span>,
      <span class="hljs-string">'image-rendering'</span>: <span class="hljs-string">'imageRendering'</span>,
      <span class="hljs-attr">in2</span>: <span class="hljs-string">'in2'</span>,
      <span class="hljs-attr">in</span>: <span class="hljs-string">'in'</span>,
      <span class="hljs-attr">inlist</span>: <span class="hljs-string">'inlist'</span>,
      <span class="hljs-attr">intercept</span>: <span class="hljs-string">'intercept'</span>,
      <span class="hljs-attr">k1</span>: <span class="hljs-string">'k1'</span>,
      <span class="hljs-attr">k2</span>: <span class="hljs-string">'k2'</span>,
      <span class="hljs-attr">k3</span>: <span class="hljs-string">'k3'</span>,
      <span class="hljs-attr">k4</span>: <span class="hljs-string">'k4'</span>,
      <span class="hljs-attr">k</span>: <span class="hljs-string">'k'</span>,
      <span class="hljs-attr">kernelmatrix</span>: <span class="hljs-string">'kernelMatrix'</span>,
      <span class="hljs-attr">kernelunitlength</span>: <span class="hljs-string">'kernelUnitLength'</span>,
      <span class="hljs-attr">kerning</span>: <span class="hljs-string">'kerning'</span>,
      <span class="hljs-attr">keypoints</span>: <span class="hljs-string">'keyPoints'</span>,
      <span class="hljs-attr">keysplines</span>: <span class="hljs-string">'keySplines'</span>,
      <span class="hljs-attr">keytimes</span>: <span class="hljs-string">'keyTimes'</span>,
      <span class="hljs-attr">lengthadjust</span>: <span class="hljs-string">'lengthAdjust'</span>,
      <span class="hljs-attr">letterspacing</span>: <span class="hljs-string">'letterSpacing'</span>,
      <span class="hljs-string">'letter-spacing'</span>: <span class="hljs-string">'letterSpacing'</span>,
      <span class="hljs-attr">lightingcolor</span>: <span class="hljs-string">'lightingColor'</span>,
      <span class="hljs-string">'lighting-color'</span>: <span class="hljs-string">'lightingColor'</span>,
      <span class="hljs-attr">limitingconeangle</span>: <span class="hljs-string">'limitingConeAngle'</span>,
      <span class="hljs-attr">local</span>: <span class="hljs-string">'local'</span>,
      <span class="hljs-attr">markerend</span>: <span class="hljs-string">'markerEnd'</span>,
      <span class="hljs-string">'marker-end'</span>: <span class="hljs-string">'markerEnd'</span>,
      <span class="hljs-attr">markerheight</span>: <span class="hljs-string">'markerHeight'</span>,
      <span class="hljs-attr">markermid</span>: <span class="hljs-string">'markerMid'</span>,
      <span class="hljs-string">'marker-mid'</span>: <span class="hljs-string">'markerMid'</span>,
      <span class="hljs-attr">markerstart</span>: <span class="hljs-string">'markerStart'</span>,
      <span class="hljs-string">'marker-start'</span>: <span class="hljs-string">'markerStart'</span>,
      <span class="hljs-attr">markerunits</span>: <span class="hljs-string">'markerUnits'</span>,
      <span class="hljs-attr">markerwidth</span>: <span class="hljs-string">'markerWidth'</span>,
      <span class="hljs-attr">mask</span>: <span class="hljs-string">'mask'</span>,
      <span class="hljs-attr">maskcontentunits</span>: <span class="hljs-string">'maskContentUnits'</span>,
      <span class="hljs-attr">maskunits</span>: <span class="hljs-string">'maskUnits'</span>,
      <span class="hljs-attr">mathematical</span>: <span class="hljs-string">'mathematical'</span>,
      <span class="hljs-attr">mode</span>: <span class="hljs-string">'mode'</span>,
      <span class="hljs-attr">numoctaves</span>: <span class="hljs-string">'numOctaves'</span>,
      <span class="hljs-attr">offset</span>: <span class="hljs-string">'offset'</span>,
      <span class="hljs-attr">opacity</span>: <span class="hljs-string">'opacity'</span>,
      <span class="hljs-attr">operator</span>: <span class="hljs-string">'operator'</span>,
      <span class="hljs-attr">order</span>: <span class="hljs-string">'order'</span>,
      <span class="hljs-attr">orient</span>: <span class="hljs-string">'orient'</span>,
      <span class="hljs-attr">orientation</span>: <span class="hljs-string">'orientation'</span>,
      <span class="hljs-attr">origin</span>: <span class="hljs-string">'origin'</span>,
      <span class="hljs-attr">overflow</span>: <span class="hljs-string">'overflow'</span>,
      <span class="hljs-attr">overlineposition</span>: <span class="hljs-string">'overlinePosition'</span>,
      <span class="hljs-string">'overline-position'</span>: <span class="hljs-string">'overlinePosition'</span>,
      <span class="hljs-attr">overlinethickness</span>: <span class="hljs-string">'overlineThickness'</span>,
      <span class="hljs-string">'overline-thickness'</span>: <span class="hljs-string">'overlineThickness'</span>,
      <span class="hljs-attr">paintorder</span>: <span class="hljs-string">'paintOrder'</span>,
      <span class="hljs-string">'paint-order'</span>: <span class="hljs-string">'paintOrder'</span>,
      <span class="hljs-attr">panose1</span>: <span class="hljs-string">'panose1'</span>,
      <span class="hljs-string">'panose-1'</span>: <span class="hljs-string">'panose1'</span>,
      <span class="hljs-attr">pathlength</span>: <span class="hljs-string">'pathLength'</span>,
      <span class="hljs-attr">patterncontentunits</span>: <span class="hljs-string">'patternContentUnits'</span>,
      <span class="hljs-attr">patterntransform</span>: <span class="hljs-string">'patternTransform'</span>,
      <span class="hljs-attr">patternunits</span>: <span class="hljs-string">'patternUnits'</span>,
      <span class="hljs-attr">pointerevents</span>: <span class="hljs-string">'pointerEvents'</span>,
      <span class="hljs-string">'pointer-events'</span>: <span class="hljs-string">'pointerEvents'</span>,
      <span class="hljs-attr">points</span>: <span class="hljs-string">'points'</span>,
      <span class="hljs-attr">pointsatx</span>: <span class="hljs-string">'pointsAtX'</span>,
      <span class="hljs-attr">pointsaty</span>: <span class="hljs-string">'pointsAtY'</span>,
      <span class="hljs-attr">pointsatz</span>: <span class="hljs-string">'pointsAtZ'</span>,
      <span class="hljs-attr">prefix</span>: <span class="hljs-string">'prefix'</span>,
      <span class="hljs-attr">preservealpha</span>: <span class="hljs-string">'preserveAlpha'</span>,
      <span class="hljs-attr">preserveaspectratio</span>: <span class="hljs-string">'preserveAspectRatio'</span>,
      <span class="hljs-attr">primitiveunits</span>: <span class="hljs-string">'primitiveUnits'</span>,
      <span class="hljs-attr">property</span>: <span class="hljs-string">'property'</span>,
      <span class="hljs-attr">r</span>: <span class="hljs-string">'r'</span>,
      <span class="hljs-attr">radius</span>: <span class="hljs-string">'radius'</span>,
      <span class="hljs-attr">refx</span>: <span class="hljs-string">'refX'</span>,
      <span class="hljs-attr">refy</span>: <span class="hljs-string">'refY'</span>,
      <span class="hljs-attr">renderingintent</span>: <span class="hljs-string">'renderingIntent'</span>,
      <span class="hljs-string">'rendering-intent'</span>: <span class="hljs-string">'renderingIntent'</span>,
      <span class="hljs-attr">repeatcount</span>: <span class="hljs-string">'repeatCount'</span>,
      <span class="hljs-attr">repeatdur</span>: <span class="hljs-string">'repeatDur'</span>,
      <span class="hljs-attr">requiredextensions</span>: <span class="hljs-string">'requiredExtensions'</span>,
      <span class="hljs-attr">requiredfeatures</span>: <span class="hljs-string">'requiredFeatures'</span>,
      <span class="hljs-attr">resource</span>: <span class="hljs-string">'resource'</span>,
      <span class="hljs-attr">restart</span>: <span class="hljs-string">'restart'</span>,
      <span class="hljs-attr">result</span>: <span class="hljs-string">'result'</span>,
      <span class="hljs-attr">results</span>: <span class="hljs-string">'results'</span>,
      <span class="hljs-attr">rotate</span>: <span class="hljs-string">'rotate'</span>,
      <span class="hljs-attr">rx</span>: <span class="hljs-string">'rx'</span>,
      <span class="hljs-attr">ry</span>: <span class="hljs-string">'ry'</span>,
      <span class="hljs-attr">scale</span>: <span class="hljs-string">'scale'</span>,
      <span class="hljs-attr">security</span>: <span class="hljs-string">'security'</span>,
      <span class="hljs-attr">seed</span>: <span class="hljs-string">'seed'</span>,
      <span class="hljs-attr">shaperendering</span>: <span class="hljs-string">'shapeRendering'</span>,
      <span class="hljs-string">'shape-rendering'</span>: <span class="hljs-string">'shapeRendering'</span>,
      <span class="hljs-attr">slope</span>: <span class="hljs-string">'slope'</span>,
      <span class="hljs-attr">spacing</span>: <span class="hljs-string">'spacing'</span>,
      <span class="hljs-attr">specularconstant</span>: <span class="hljs-string">'specularConstant'</span>,
      <span class="hljs-attr">specularexponent</span>: <span class="hljs-string">'specularExponent'</span>,
      <span class="hljs-attr">speed</span>: <span class="hljs-string">'speed'</span>,
      <span class="hljs-attr">spreadmethod</span>: <span class="hljs-string">'spreadMethod'</span>,
      <span class="hljs-attr">startoffset</span>: <span class="hljs-string">'startOffset'</span>,
      <span class="hljs-attr">stddeviation</span>: <span class="hljs-string">'stdDeviation'</span>,
      <span class="hljs-attr">stemh</span>: <span class="hljs-string">'stemh'</span>,
      <span class="hljs-attr">stemv</span>: <span class="hljs-string">'stemv'</span>,
      <span class="hljs-attr">stitchtiles</span>: <span class="hljs-string">'stitchTiles'</span>,
      <span class="hljs-attr">stopcolor</span>: <span class="hljs-string">'stopColor'</span>,
      <span class="hljs-string">'stop-color'</span>: <span class="hljs-string">'stopColor'</span>,
      <span class="hljs-attr">stopopacity</span>: <span class="hljs-string">'stopOpacity'</span>,
      <span class="hljs-string">'stop-opacity'</span>: <span class="hljs-string">'stopOpacity'</span>,
      <span class="hljs-attr">strikethroughposition</span>: <span class="hljs-string">'strikethroughPosition'</span>,
      <span class="hljs-string">'strikethrough-position'</span>: <span class="hljs-string">'strikethroughPosition'</span>,
      <span class="hljs-attr">strikethroughthickness</span>: <span class="hljs-string">'strikethroughThickness'</span>,
      <span class="hljs-string">'strikethrough-thickness'</span>: <span class="hljs-string">'strikethroughThickness'</span>,
      <span class="hljs-attr">string</span>: <span class="hljs-string">'string'</span>,
      <span class="hljs-attr">stroke</span>: <span class="hljs-string">'stroke'</span>,
      <span class="hljs-attr">strokedasharray</span>: <span class="hljs-string">'strokeDasharray'</span>,
      <span class="hljs-string">'stroke-dasharray'</span>: <span class="hljs-string">'strokeDasharray'</span>,
      <span class="hljs-attr">strokedashoffset</span>: <span class="hljs-string">'strokeDashoffset'</span>,
      <span class="hljs-string">'stroke-dashoffset'</span>: <span class="hljs-string">'strokeDashoffset'</span>,
      <span class="hljs-attr">strokelinecap</span>: <span class="hljs-string">'strokeLinecap'</span>,
      <span class="hljs-string">'stroke-linecap'</span>: <span class="hljs-string">'strokeLinecap'</span>,
      <span class="hljs-attr">strokelinejoin</span>: <span class="hljs-string">'strokeLinejoin'</span>,
      <span class="hljs-string">'stroke-linejoin'</span>: <span class="hljs-string">'strokeLinejoin'</span>,
      <span class="hljs-attr">strokemiterlimit</span>: <span class="hljs-string">'strokeMiterlimit'</span>,
      <span class="hljs-string">'stroke-miterlimit'</span>: <span class="hljs-string">'strokeMiterlimit'</span>,
      <span class="hljs-attr">strokewidth</span>: <span class="hljs-string">'strokeWidth'</span>,
      <span class="hljs-string">'stroke-width'</span>: <span class="hljs-string">'strokeWidth'</span>,
      <span class="hljs-attr">strokeopacity</span>: <span class="hljs-string">'strokeOpacity'</span>,
      <span class="hljs-string">'stroke-opacity'</span>: <span class="hljs-string">'strokeOpacity'</span>,
      <span class="hljs-attr">suppresscontenteditablewarning</span>: <span class="hljs-string">'suppressContentEditableWarning'</span>,
      <span class="hljs-attr">suppresshydrationwarning</span>: <span class="hljs-string">'suppressHydrationWarning'</span>,
      <span class="hljs-attr">surfacescale</span>: <span class="hljs-string">'surfaceScale'</span>,
      <span class="hljs-attr">systemlanguage</span>: <span class="hljs-string">'systemLanguage'</span>,
      <span class="hljs-attr">tablevalues</span>: <span class="hljs-string">'tableValues'</span>,
      <span class="hljs-attr">targetx</span>: <span class="hljs-string">'targetX'</span>,
      <span class="hljs-attr">targety</span>: <span class="hljs-string">'targetY'</span>,
      <span class="hljs-attr">textanchor</span>: <span class="hljs-string">'textAnchor'</span>,
      <span class="hljs-string">'text-anchor'</span>: <span class="hljs-string">'textAnchor'</span>,
      <span class="hljs-attr">textdecoration</span>: <span class="hljs-string">'textDecoration'</span>,
      <span class="hljs-string">'text-decoration'</span>: <span class="hljs-string">'textDecoration'</span>,
      <span class="hljs-attr">textlength</span>: <span class="hljs-string">'textLength'</span>,
      <span class="hljs-attr">textrendering</span>: <span class="hljs-string">'textRendering'</span>,
      <span class="hljs-string">'text-rendering'</span>: <span class="hljs-string">'textRendering'</span>,
      <span class="hljs-attr">to</span>: <span class="hljs-string">'to'</span>,
      <span class="hljs-attr">transform</span>: <span class="hljs-string">'transform'</span>,
      <span class="hljs-attr">typeof</span>: <span class="hljs-string">'typeof'</span>,
      <span class="hljs-attr">u1</span>: <span class="hljs-string">'u1'</span>,
      <span class="hljs-attr">u2</span>: <span class="hljs-string">'u2'</span>,
      <span class="hljs-attr">underlineposition</span>: <span class="hljs-string">'underlinePosition'</span>,
      <span class="hljs-string">'underline-position'</span>: <span class="hljs-string">'underlinePosition'</span>,
      <span class="hljs-attr">underlinethickness</span>: <span class="hljs-string">'underlineThickness'</span>,
      <span class="hljs-string">'underline-thickness'</span>: <span class="hljs-string">'underlineThickness'</span>,
      <span class="hljs-attr">unicode</span>: <span class="hljs-string">'unicode'</span>,
      <span class="hljs-attr">unicodebidi</span>: <span class="hljs-string">'unicodeBidi'</span>,
      <span class="hljs-string">'unicode-bidi'</span>: <span class="hljs-string">'unicodeBidi'</span>,
      <span class="hljs-attr">unicoderange</span>: <span class="hljs-string">'unicodeRange'</span>,
      <span class="hljs-string">'unicode-range'</span>: <span class="hljs-string">'unicodeRange'</span>,
      <span class="hljs-attr">unitsperem</span>: <span class="hljs-string">'unitsPerEm'</span>,
      <span class="hljs-string">'units-per-em'</span>: <span class="hljs-string">'unitsPerEm'</span>,
      <span class="hljs-attr">unselectable</span>: <span class="hljs-string">'unselectable'</span>,
      <span class="hljs-attr">valphabetic</span>: <span class="hljs-string">'vAlphabetic'</span>,
      <span class="hljs-string">'v-alphabetic'</span>: <span class="hljs-string">'vAlphabetic'</span>,
      <span class="hljs-attr">values</span>: <span class="hljs-string">'values'</span>,
      <span class="hljs-attr">vectoreffect</span>: <span class="hljs-string">'vectorEffect'</span>,
      <span class="hljs-string">'vector-effect'</span>: <span class="hljs-string">'vectorEffect'</span>,
      <span class="hljs-attr">version</span>: <span class="hljs-string">'version'</span>,
      <span class="hljs-attr">vertadvy</span>: <span class="hljs-string">'vertAdvY'</span>,
      <span class="hljs-string">'vert-adv-y'</span>: <span class="hljs-string">'vertAdvY'</span>,
      <span class="hljs-attr">vertoriginx</span>: <span class="hljs-string">'vertOriginX'</span>,
      <span class="hljs-string">'vert-origin-x'</span>: <span class="hljs-string">'vertOriginX'</span>,
      <span class="hljs-attr">vertoriginy</span>: <span class="hljs-string">'vertOriginY'</span>,
      <span class="hljs-string">'vert-origin-y'</span>: <span class="hljs-string">'vertOriginY'</span>,
      <span class="hljs-attr">vhanging</span>: <span class="hljs-string">'vHanging'</span>,
      <span class="hljs-string">'v-hanging'</span>: <span class="hljs-string">'vHanging'</span>,
      <span class="hljs-attr">videographic</span>: <span class="hljs-string">'vIdeographic'</span>,
      <span class="hljs-string">'v-ideographic'</span>: <span class="hljs-string">'vIdeographic'</span>,
      <span class="hljs-attr">viewbox</span>: <span class="hljs-string">'viewBox'</span>,
      <span class="hljs-attr">viewtarget</span>: <span class="hljs-string">'viewTarget'</span>,
      <span class="hljs-attr">visibility</span>: <span class="hljs-string">'visibility'</span>,
      <span class="hljs-attr">vmathematical</span>: <span class="hljs-string">'vMathematical'</span>,
      <span class="hljs-string">'v-mathematical'</span>: <span class="hljs-string">'vMathematical'</span>,
      <span class="hljs-attr">vocab</span>: <span class="hljs-string">'vocab'</span>,
      <span class="hljs-attr">widths</span>: <span class="hljs-string">'widths'</span>,
      <span class="hljs-attr">wordspacing</span>: <span class="hljs-string">'wordSpacing'</span>,
      <span class="hljs-string">'word-spacing'</span>: <span class="hljs-string">'wordSpacing'</span>,
      <span class="hljs-attr">writingmode</span>: <span class="hljs-string">'writingMode'</span>,
      <span class="hljs-string">'writing-mode'</span>: <span class="hljs-string">'writingMode'</span>,
      <span class="hljs-attr">x1</span>: <span class="hljs-string">'x1'</span>,
      <span class="hljs-attr">x2</span>: <span class="hljs-string">'x2'</span>,
      <span class="hljs-attr">x</span>: <span class="hljs-string">'x'</span>,
      <span class="hljs-attr">xchannelselector</span>: <span class="hljs-string">'xChannelSelector'</span>,
      <span class="hljs-attr">xheight</span>: <span class="hljs-string">'xHeight'</span>,
      <span class="hljs-string">'x-height'</span>: <span class="hljs-string">'xHeight'</span>,
      <span class="hljs-attr">xlinkactuate</span>: <span class="hljs-string">'xlinkActuate'</span>,
      <span class="hljs-string">'xlink:actuate'</span>: <span class="hljs-string">'xlinkActuate'</span>,
      <span class="hljs-attr">xlinkarcrole</span>: <span class="hljs-string">'xlinkArcrole'</span>,
      <span class="hljs-string">'xlink:arcrole'</span>: <span class="hljs-string">'xlinkArcrole'</span>,
      <span class="hljs-attr">xlinkhref</span>: <span class="hljs-string">'xlinkHref'</span>,
      <span class="hljs-string">'xlink:href'</span>: <span class="hljs-string">'xlinkHref'</span>,
      <span class="hljs-attr">xlinkrole</span>: <span class="hljs-string">'xlinkRole'</span>,
      <span class="hljs-string">'xlink:role'</span>: <span class="hljs-string">'xlinkRole'</span>,
      <span class="hljs-attr">xlinkshow</span>: <span class="hljs-string">'xlinkShow'</span>,
      <span class="hljs-string">'xlink:show'</span>: <span class="hljs-string">'xlinkShow'</span>,
      <span class="hljs-attr">xlinktitle</span>: <span class="hljs-string">'xlinkTitle'</span>,
      <span class="hljs-string">'xlink:title'</span>: <span class="hljs-string">'xlinkTitle'</span>,
      <span class="hljs-attr">xlinktype</span>: <span class="hljs-string">'xlinkType'</span>,
      <span class="hljs-string">'xlink:type'</span>: <span class="hljs-string">'xlinkType'</span>,
      <span class="hljs-attr">xmlbase</span>: <span class="hljs-string">'xmlBase'</span>,
      <span class="hljs-string">'xml:base'</span>: <span class="hljs-string">'xmlBase'</span>,
      <span class="hljs-attr">xmllang</span>: <span class="hljs-string">'xmlLang'</span>,
      <span class="hljs-string">'xml:lang'</span>: <span class="hljs-string">'xmlLang'</span>,
      <span class="hljs-attr">xmlns</span>: <span class="hljs-string">'xmlns'</span>,
      <span class="hljs-string">'xml:space'</span>: <span class="hljs-string">'xmlSpace'</span>,
      <span class="hljs-attr">xmlnsxlink</span>: <span class="hljs-string">'xmlnsXlink'</span>,
      <span class="hljs-string">'xmlns:xlink'</span>: <span class="hljs-string">'xmlnsXlink'</span>,
      <span class="hljs-attr">xmlspace</span>: <span class="hljs-string">'xmlSpace'</span>,
      <span class="hljs-attr">y1</span>: <span class="hljs-string">'y1'</span>,
      <span class="hljs-attr">y2</span>: <span class="hljs-string">'y2'</span>,
      <span class="hljs-attr">y</span>: <span class="hljs-string">'y'</span>,
      <span class="hljs-attr">ychannelselector</span>: <span class="hljs-string">'yChannelSelector'</span>,
      <span class="hljs-attr">z</span>: <span class="hljs-string">'z'</span>,
      <span class="hljs-attr">zoomandpan</span>: <span class="hljs-string">'zoomAndPan'</span>
    };
    <span class="hljs-keyword">var</span> ariaProperties = {
      <span class="hljs-string">'aria-current'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-390" id="section-390"></a>
</div>
<p>state</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-details'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-disabled'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-391" id="section-391"></a>
</div>
<p>state</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-hidden'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-392" id="section-392"></a>
</div>
<p>state</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-invalid'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-393" id="section-393"></a>
</div>
<p>state</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-keyshortcuts'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-label'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-roledescription'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-394" id="section-394"></a>
</div>
<p>Widget Attributes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-autocomplete'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-checked'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-expanded'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-haspopup'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-level'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-modal'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-multiline'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-multiselectable'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-orientation'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-placeholder'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-pressed'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-readonly'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-required'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-selected'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-sort'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-valuemax'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-valuemin'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-valuenow'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-valuetext'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-395" id="section-395"></a>
</div>
<p>Live Region Attributes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-atomic'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-busy'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-live'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-relevant'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-396" id="section-396"></a>
</div>
<p>Drag-and-Drop Attributes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-dropeffect'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-grabbed'</span>: <span class="hljs-number">0</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-397" id="section-397"></a>
</div>
<p>Relationship Attributes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'aria-activedescendant'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-colcount'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-colindex'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-colspan'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-controls'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-describedby'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-errormessage'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-flowto'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-labelledby'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-owns'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-posinset'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-rowcount'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-rowindex'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-rowspan'</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">'aria-setsize'</span>: <span class="hljs-number">0</span>
    };
    <span class="hljs-keyword">var</span> warnedProperties = {};
    <span class="hljs-keyword">var</span> rARIA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^(aria)-['</span> + ATTRIBUTE_NAME_CHAR + <span class="hljs-string">']*$'</span>);
    <span class="hljs-keyword">var</span> rARIACamel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^(aria)[A-Z]['</span> + ATTRIBUTE_NAME_CHAR + <span class="hljs-string">']*$'</span>);
    <span class="hljs-keyword">var</span> hasOwnProperty$<span class="hljs-number">1</span> = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateProperty</span>(<span class="hljs-params">tagName, name</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (hasOwnProperty$<span class="hljs-number">1.</span>call(warnedProperties, name) &amp;&amp; warnedProperties[name]) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (rARIACamel.test(name)) {
          <span class="hljs-keyword">var</span> ariaName = <span class="hljs-string">'aria-'</span> + name.slice(<span class="hljs-number">4</span>).toLowerCase();
          <span class="hljs-keyword">var</span> correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : <span class="hljs-literal">null</span>; <span class="hljs-comment">// If this is an aria-* attribute, but is not listed in the known DOM</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-398" id="section-398"></a>
</div>
<p>DOM properties, then it is an invalid aria-* attribute.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">if</span> (correctName == <span class="hljs-literal">null</span>) {
            error(<span class="hljs-string">'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.'</span>, name);
            warnedProperties[name] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          } <span class="hljs-comment">// aria-* attributes should be lowercase; suggest the lowercase version.</span>


          <span class="hljs-keyword">if</span> (name !== correctName) {
            error(<span class="hljs-string">'Invalid ARIA attribute `%s`. Did you mean `%s`?'</span>, name, correctName);
            warnedProperties[name] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">if</span> (rARIA.test(name)) {
          <span class="hljs-keyword">var</span> lowerCasedName = name.toLowerCase();
          <span class="hljs-keyword">var</span> standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : <span class="hljs-literal">null</span>; <span class="hljs-comment">// If this is an aria-* attribute, but is not listed in the known DOM</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-399" id="section-399"></a>
</div>
<p>DOM properties, then it is an invalid aria-* attribute.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">if</span> (standardName == <span class="hljs-literal">null</span>) {
            warnedProperties[name] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          } <span class="hljs-comment">// aria-* attributes should be lowercase; suggest the lowercase version.</span>


          <span class="hljs-keyword">if</span> (name !== standardName) {
            error(<span class="hljs-string">'Unknown ARIA attribute `%s`. Did you mean `%s`?'</span>, name, standardName);
            warnedProperties[name] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnInvalidARIAProps</span>(<span class="hljs-params">type, props</span>) </span>{
      {
        <span class="hljs-keyword">var</span> invalidProps = [];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> props) {
          <span class="hljs-keyword">var</span> isValid = validateProperty(type, key);

          <span class="hljs-keyword">if</span> (!isValid) {
            invalidProps.push(key);
          }
        }

        <span class="hljs-keyword">var</span> unknownPropString = invalidProps.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">'`'</span> + prop + <span class="hljs-string">'`'</span>;
        }).join(<span class="hljs-string">', '</span>);

        <span class="hljs-keyword">if</span> (invalidProps.length === <span class="hljs-number">1</span>) {
          error(<span class="hljs-string">'Invalid aria prop %s on &lt;%s&gt; tag. '</span> + <span class="hljs-string">'For details, see https://fb.me/invalid-aria-prop'</span>, unknownPropString, type);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (invalidProps.length &gt; <span class="hljs-number">1</span>) {
          error(<span class="hljs-string">'Invalid aria props %s on &lt;%s&gt; tag. '</span> + <span class="hljs-string">'For details, see https://fb.me/invalid-aria-prop'</span>, unknownPropString, type);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateProperties</span>(<span class="hljs-params">type, props</span>) </span>{
      <span class="hljs-keyword">if</span> (isCustomComponent(type, props)) {
        <span class="hljs-keyword">return</span>;
      }

      warnInvalidARIAProps(type, props);
    }

    <span class="hljs-keyword">var</span> didWarnValueNull = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateProperties$1</span>(<span class="hljs-params">type, props</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (type !== <span class="hljs-string">'input'</span> &amp;&amp; type !== <span class="hljs-string">'textarea'</span> &amp;&amp; type !== <span class="hljs-string">'select'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (props != <span class="hljs-literal">null</span> &amp;&amp; props.value === <span class="hljs-literal">null</span> &amp;&amp; !didWarnValueNull) {
          didWarnValueNull = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'select'</span> &amp;&amp; props.multiple) {
            error(<span class="hljs-string">'`value` prop on `%s` should not be null. '</span> + <span class="hljs-string">'Consider using an empty array when `multiple` is set to `true` '</span> + <span class="hljs-string">'to clear the component or `undefined` for uncontrolled components.'</span>, type);
          } <span class="hljs-keyword">else</span> {
            error(<span class="hljs-string">'`value` prop on `%s` should not be null. '</span> + <span class="hljs-string">'Consider using an empty string to clear the component or `undefined` '</span> + <span class="hljs-string">'for uncontrolled components.'</span>, type);
          }
        }
      }
    }

    <span class="hljs-keyword">var</span> validateProperty$<span class="hljs-number">1</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

    {
      <span class="hljs-keyword">var</span> warnedProperties$<span class="hljs-number">1</span> = {};
      <span class="hljs-keyword">var</span> _hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
      <span class="hljs-keyword">var</span> EVENT_NAME_REGEX = <span class="hljs-regexp">/^on./</span>;
      <span class="hljs-keyword">var</span> INVALID_EVENT_NAME_REGEX = <span class="hljs-regexp">/^on[^A-Z]/</span>;
      <span class="hljs-keyword">var</span> rARIA$<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^(aria)-['</span> + ATTRIBUTE_NAME_CHAR + <span class="hljs-string">']*$'</span>);
      <span class="hljs-keyword">var</span> rARIACamel$<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^(aria)[A-Z]['</span> + ATTRIBUTE_NAME_CHAR + <span class="hljs-string">']*$'</span>);

      validateProperty$<span class="hljs-number">1</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tagName, name, value, canUseEventSystem</span>) </span>{
        <span class="hljs-keyword">if</span> (_hasOwnProperty.call(warnedProperties$<span class="hljs-number">1</span>, name) &amp;&amp; warnedProperties$<span class="hljs-number">1</span>[name]) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">var</span> lowerCasedName = name.toLowerCase();

        <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">'onfocusin'</span> || lowerCasedName === <span class="hljs-string">'onfocusout'</span>) {
          error(<span class="hljs-string">'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '</span> + <span class="hljs-string">'All React events are normalized to bubble, so onFocusIn and onFocusOut '</span> + <span class="hljs-string">'are not needed/supported by React.'</span>);
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// We can't rely on the event system being injected on the server.</span>


        <span class="hljs-keyword">if</span> (canUseEventSystem) {
          <span class="hljs-keyword">if</span> (registrationNameModules.hasOwnProperty(name)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">var</span> registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">if</span> (registrationName != <span class="hljs-literal">null</span>) {
            error(<span class="hljs-string">'Invalid event handler property `%s`. Did you mean `%s`?'</span>, name, registrationName);
            warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">if</span> (EVENT_NAME_REGEX.test(name)) {
            error(<span class="hljs-string">'Unknown event handler property `%s`. It will be ignored.'</span>, name);
            warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (EVENT_NAME_REGEX.test(name)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-400" id="section-400"></a>
</div>
<p>If no event plugins have been injected, we are in a server environment.
So we can't tell if the event name is correct for sure, but we can filter
out known bad ones like <code>onclick</code>. We can't suggest a specific replacement though.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (INVALID_EVENT_NAME_REGEX.test(name)) {
            error(<span class="hljs-string">'Invalid event handler property `%s`. '</span> + <span class="hljs-string">'React events use the camelCase naming convention, for example `onClick`.'</span>, name);
          }

          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// Let the ARIA attribute hook validate ARIA attributes</span>


        <span class="hljs-keyword">if</span> (rARIA$<span class="hljs-number">1.</span>test(name) || rARIACamel$<span class="hljs-number">1.</span>test(name)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">'innerhtml'</span>) {
          error(<span class="hljs-string">'Directly setting property `innerHTML` is not permitted. '</span> + <span class="hljs-string">'For more information, lookup documentation on `dangerouslySetInnerHTML`.'</span>);
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">'aria'</span>) {
          error(<span class="hljs-string">'The `aria` attribute is reserved for future use in React. '</span> + <span class="hljs-string">'Pass individual `aria-` attributes instead.'</span>);
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">'is'</span> &amp;&amp; value !== <span class="hljs-literal">null</span> &amp;&amp; value !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span>) {
          error(<span class="hljs-string">'Received a `%s` for a string attribute `is`. If this is expected, cast '</span> + <span class="hljs-string">'the value to a string.'</span>, <span class="hljs-keyword">typeof</span> value);
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(value)) {
          error(<span class="hljs-string">'Received NaN for the `%s` attribute. If this is expected, cast '</span> + <span class="hljs-string">'the value to a string.'</span>, name);
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">var</span> propertyInfo = getPropertyInfo(name);
        <span class="hljs-keyword">var</span> isReserved = propertyInfo !== <span class="hljs-literal">null</span> &amp;&amp; propertyInfo.type === RESERVED; <span class="hljs-comment">// Known attributes should match the casing specified in the property config.</span>

        <span class="hljs-keyword">if</span> (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          <span class="hljs-keyword">var</span> standardName = possibleStandardNames[lowerCasedName];

          <span class="hljs-keyword">if</span> (standardName !== name) {
            error(<span class="hljs-string">'Invalid DOM property `%s`. Did you mean `%s`?'</span>, name, standardName);
            warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved &amp;&amp; name !== lowerCasedName) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-401" id="section-401"></a>
</div>
<p>Unknown attributes should have lowercase casing since that's how they
will be cased anyway with server rendering.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          error(<span class="hljs-string">'React does not recognize the `%s` prop on a DOM element. If you '</span> + <span class="hljs-string">'intentionally want it to appear in the DOM as a custom '</span> + <span class="hljs-string">'attribute, spell it as lowercase `%s` instead. '</span> + <span class="hljs-string">'If you accidentally passed it from a parent component, remove '</span> + <span class="hljs-string">'it from the DOM element.'</span>, name, lowerCasedName);
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'boolean'</span> &amp;&amp; shouldRemoveAttributeWithWarning(name, value, propertyInfo, <span class="hljs-literal">false</span>)) {
          <span class="hljs-keyword">if</span> (value) {
            error(<span class="hljs-string">'Received `%s` for a non-boolean attribute `%s`.\n\n'</span> + <span class="hljs-string">'If you want to write it to the DOM, pass a string instead: '</span> + <span class="hljs-string">'%s="%s" or %s={value.toString()}.'</span>, value, name, name, value, name);
          } <span class="hljs-keyword">else</span> {
            error(<span class="hljs-string">'Received `%s` for a non-boolean attribute `%s`.\n\n'</span> + <span class="hljs-string">'If you want to write it to the DOM, pass a string instead: '</span> + <span class="hljs-string">'%s="%s" or %s={value.toString()}.\n\n'</span> + <span class="hljs-string">'If you used to conditionally omit it with %s={condition &amp;&amp; value}, '</span> + <span class="hljs-string">'pass %s={condition ? value : undefined} instead.'</span>, value, name, name, value, name, name, name);
          }

          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// Now that we've validated casing, do not validate</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-402" id="section-402"></a>
</div>
<p>data types for reserved props</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (isReserved) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// Warn when a known attribute is a bad type</span>


        <span class="hljs-keyword">if</span> (shouldRemoveAttributeWithWarning(name, value, propertyInfo, <span class="hljs-literal">false</span>)) {
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-comment">// Warn when passing the strings 'false' or 'true' into a boolean prop</span>


        <span class="hljs-keyword">if</span> ((value === <span class="hljs-string">'false'</span> || value === <span class="hljs-string">'true'</span>) &amp;&amp; propertyInfo !== <span class="hljs-literal">null</span> &amp;&amp; propertyInfo.type === BOOLEAN) {
          error(<span class="hljs-string">'Received the string `%s` for the boolean attribute `%s`. '</span> + <span class="hljs-string">'%s '</span> + <span class="hljs-string">'Did you mean %s={%s}?'</span>, value, name, value === <span class="hljs-string">'false'</span> ? <span class="hljs-string">'The browser will interpret it as a truthy value.'</span> : <span class="hljs-string">'Although this works, it will not work as expected if you pass the string "false".'</span>, name, value);
          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
    }

    <span class="hljs-keyword">var</span> warnUnknownProperties = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, props, canUseEventSystem</span>) </span>{
      {
        <span class="hljs-keyword">var</span> unknownProps = [];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> props) {
          <span class="hljs-keyword">var</span> isValid = validateProperty$<span class="hljs-number">1</span>(type, key, props[key], canUseEventSystem);

          <span class="hljs-keyword">if</span> (!isValid) {
            unknownProps.push(key);
          }
        }

        <span class="hljs-keyword">var</span> unknownPropString = unknownProps.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-string">'`'</span> + prop + <span class="hljs-string">'`'</span>;
        }).join(<span class="hljs-string">', '</span>);

        <span class="hljs-keyword">if</span> (unknownProps.length === <span class="hljs-number">1</span>) {
          error(<span class="hljs-string">'Invalid value for prop %s on &lt;%s&gt; tag. Either remove it from the element, '</span> + <span class="hljs-string">'or pass a string or number value to keep it in the DOM. '</span> + <span class="hljs-string">'For details, see https://fb.me/react-attribute-behavior'</span>, unknownPropString, type);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unknownProps.length &gt; <span class="hljs-number">1</span>) {
          error(<span class="hljs-string">'Invalid values for props %s on &lt;%s&gt; tag. Either remove them from the element, '</span> + <span class="hljs-string">'or pass a string or number value to keep them in the DOM. '</span> + <span class="hljs-string">'For details, see https://fb.me/react-attribute-behavior'</span>, unknownPropString, type);
        }
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateProperties$2</span>(<span class="hljs-params">type, props, canUseEventSystem</span>) </span>{
      <span class="hljs-keyword">if</span> (isCustomComponent(type, props)) {
        <span class="hljs-keyword">return</span>;
      }

      warnUnknownProperties(type, props, canUseEventSystem);
    }

    <span class="hljs-keyword">var</span> didWarnInvalidHydration = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> DANGEROUSLY_SET_INNER_HTML = <span class="hljs-string">'dangerouslySetInnerHTML'</span>;
    <span class="hljs-keyword">var</span> SUPPRESS_CONTENT_EDITABLE_WARNING = <span class="hljs-string">'suppressContentEditableWarning'</span>;
    <span class="hljs-keyword">var</span> SUPPRESS_HYDRATION_WARNING = <span class="hljs-string">'suppressHydrationWarning'</span>;
    <span class="hljs-keyword">var</span> AUTOFOCUS = <span class="hljs-string">'autoFocus'</span>;
    <span class="hljs-keyword">var</span> CHILDREN = <span class="hljs-string">'children'</span>;
    <span class="hljs-keyword">var</span> STYLE = <span class="hljs-string">'style'</span>;
    <span class="hljs-keyword">var</span> HTML$<span class="hljs-number">1</span> = <span class="hljs-string">'__html'</span>;
    <span class="hljs-keyword">var</span> HTML_NAMESPACE$<span class="hljs-number">1</span> = Namespaces.html;
    <span class="hljs-keyword">var</span> warnedUnknownTags;
    <span class="hljs-keyword">var</span> suppressHydrationWarning;
    <span class="hljs-keyword">var</span> validatePropertiesInDevelopment;
    <span class="hljs-keyword">var</span> warnForTextDifference;
    <span class="hljs-keyword">var</span> warnForPropDifference;
    <span class="hljs-keyword">var</span> warnForExtraAttributes;
    <span class="hljs-keyword">var</span> warnForInvalidEventListener;
    <span class="hljs-keyword">var</span> canDiffStyleForHydrationWarning;
    <span class="hljs-keyword">var</span> normalizeMarkupForTextOrAttribute;
    <span class="hljs-keyword">var</span> normalizeHTML;
    {
      warnedUnknownTags = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-403" id="section-403"></a>
</div>
<p>Chrome is the only major browser not shipping <time>. But as of July
2017 it intends to ship it due to widespread usage. We intentionally
<em>don't</em> warn for <time> even if it's unrecognized by Chrome because
it soon will be, and many apps have been using it anyway.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        time: <span class="hljs-literal">true</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-404" id="section-404"></a>
</div>
<p>There are working polyfills for <dialog>. Let people use it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        dialog: <span class="hljs-literal">true</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-405" id="section-405"></a>
</div>
<p>Electron ships a custom <webview> tag to display external web content in
an isolated frame and process.
This tag is not present in non Electron environments such as JSDom which
is often used for testing purposes.
@see https://electronjs.org/docs/api/webview-tag</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        webview: <span class="hljs-literal">true</span>
      };

      validatePropertiesInDevelopment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, props</span>) </span>{
        validateProperties(type, props);
        validateProperties$<span class="hljs-number">1</span>(type, props);
        validateProperties$<span class="hljs-number">2</span>(type, props,
        <span class="hljs-comment">/* canUseEventSystem */</span>
        <span class="hljs-literal">true</span>);
      }; <span class="hljs-comment">// IE 11 parses &amp; normalizes the style attribute as opposed to other</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-406" id="section-406"></a>
</div>
<p>browsers. It adds spaces and sorts the properties in some
non-alphabetical order. Handling that would require sorting CSS
properties in the client &amp; server versions or applying
<code>expectedStyle</code> to a temporary DOM node to read its <code>style</code> attribute
normalized. Since it only affects IE, we're skipping style warnings
in that browser completely in favor of doing all that work.
See https://github.com/facebook/react/issues/11807</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      canDiffStyleForHydrationWarning = canUseDOM &amp;&amp; !<span class="hljs-built_in">document</span>.documentMode; <span class="hljs-comment">// HTML parsing normalizes CR and CRLF to LF.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-407" id="section-407"></a>
</div>
<p>It also can turn \u0000 into \uFFFD inside attributes.
https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
If we have a mismatch, it might be caused by that.
We will still patch up in this case but not fire the warning.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> NORMALIZE_NEWLINES_REGEX = <span class="hljs-regexp">/\r\n?/g</span>;
      <span class="hljs-keyword">var</span> NORMALIZE_NULL_AND_REPLACEMENT_REGEX = <span class="hljs-regexp">/\u0000|\uFFFD/g</span>;

      normalizeMarkupForTextOrAttribute = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">markup</span>) </span>{
        <span class="hljs-keyword">var</span> markupString = <span class="hljs-keyword">typeof</span> markup === <span class="hljs-string">'string'</span> ? markup : <span class="hljs-string">''</span> + markup;
        <span class="hljs-keyword">return</span> markupString.replace(NORMALIZE_NEWLINES_REGEX, <span class="hljs-string">'\n'</span>).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, <span class="hljs-string">''</span>);
      };

      warnForTextDifference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">serverText, clientText</span>) </span>{
        <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
        <span class="hljs-keyword">var</span> normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);

        <span class="hljs-keyword">if</span> (normalizedServerText === normalizedClientText) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnInvalidHydration = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Text content did not match. Server: "%s" Client: "%s"'</span>, normalizedServerText, normalizedClientText);
      };

      warnForPropDifference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">propName, serverValue, clientValue</span>) </span>{
        <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
        <span class="hljs-keyword">var</span> normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);

        <span class="hljs-keyword">if</span> (normalizedServerValue === normalizedClientValue) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnInvalidHydration = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Prop `%s` did not match. Server: %s Client: %s'</span>, propName, <span class="hljs-built_in">JSON</span>.stringify(normalizedServerValue), <span class="hljs-built_in">JSON</span>.stringify(normalizedClientValue));
      };

      warnForExtraAttributes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">attributeNames</span>) </span>{
        <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnInvalidHydration = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> names = [];
        attributeNames.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
          names.push(name);
        });
        error(<span class="hljs-string">'Extra attributes from the server: %s'</span>, names);
      };

      warnForInvalidEventListener = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">registrationName, listener</span>) </span>{
        <span class="hljs-keyword">if</span> (listener === <span class="hljs-literal">false</span>) {
          error(<span class="hljs-string">'Expected `%s` listener to be a function, instead got `false`.\n\n'</span> + <span class="hljs-string">'If you used to conditionally omit it with %s={condition &amp;&amp; value}, '</span> + <span class="hljs-string">'pass %s={condition ? value : undefined} instead.'</span>, registrationName, registrationName, registrationName);
        } <span class="hljs-keyword">else</span> {
          error(<span class="hljs-string">'Expected `%s` listener to be a function, instead got a value of `%s` type.'</span>, registrationName, <span class="hljs-keyword">typeof</span> listener);
        }
      }; <span class="hljs-comment">// Parse the HTML and read it back to normalize the HTML string so that it</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-408" id="section-408"></a>
</div>
<p>can be used for comparison.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      normalizeHTML = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, html</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-409" id="section-409"></a>
</div>
<p>We could have created a separate document here to avoid
re-initializing custom elements if they exist. But this breaks
how <noscript> is being handled. So we use the same document.
See the discussion in https://github.com/facebook/react/pull/11157.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> testElement = parent.namespaceURI === HTML_NAMESPACE$<span class="hljs-number">1</span> ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
        testElement.innerHTML = html;
        <span class="hljs-keyword">return</span> testElement.innerHTML;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureListeningTo</span>(<span class="hljs-params">rootContainerElement, registrationName</span>) </span>{
      <span class="hljs-keyword">var</span> isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
      <span class="hljs-keyword">var</span> doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
      legacyListenToEvent(registrationName, doc);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOwnerDocumentFromRootContainer</span>(<span class="hljs-params">rootContainerElement</span>) </span>{
      <span class="hljs-keyword">return</span> rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{}

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trapClickOnNonInteractiveElement</span>(<span class="hljs-params">node</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-410" id="section-410"></a>
</div>
<p>Mobile Safari does not fire properly bubble click events on
non-interactive elements, which means delegated click listeners do not
fire. The workaround for this bug involves attaching an empty click
listener on the target node.
http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
Just set it using the onclick property so that we don't have to manage any
bookkeeping for it. Not sure if we need to clear it when the listener is
removed.
TODO: Only do this for the relevant Safaris maybe?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      node.onclick = noop;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitialDOMProperties</span>(<span class="hljs-params">tag, domElement, rootContainerElement, nextProps, isCustomComponentTag</span>) </span>{
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propKey <span class="hljs-keyword">in</span> nextProps) {
        <span class="hljs-keyword">if</span> (!nextProps.hasOwnProperty(propKey)) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> nextProp = nextProps[propKey];

        <span class="hljs-keyword">if</span> (propKey === STYLE) {
          {
            <span class="hljs-keyword">if</span> (nextProp) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-411" id="section-411"></a>
</div>
<p>Freeze the next style object so that we can assume it won't be
mutated. We have already warned for this in the past.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-built_in">Object</span>.freeze(nextProp);
            }
          } <span class="hljs-comment">// Relies on `updateStylesByID` not mutating `styleUpdates`.</span>

          setValueForStyles(domElement, nextProp);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) {
          <span class="hljs-keyword">var</span> nextHtml = nextProp ? nextProp[HTML$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;

          <span class="hljs-keyword">if</span> (nextHtml != <span class="hljs-literal">null</span>) {
            setInnerHTML(domElement, nextHtml);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">'string'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-412" id="section-412"></a>
</div>
<p>Avoid setting initial textContent when the text is empty. In IE11 setting
textContent on a <textarea> will cause the placeholder to not
show within the <textarea> until it has been focused and blurred again.
https://github.com/facebook/react/issues/6731#issuecomment-254874553</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> canSetTextContent = tag !== <span class="hljs-string">'textarea'</span> || nextProp !== <span class="hljs-string">''</span>;

            <span class="hljs-keyword">if</span> (canSetTextContent) {
              setTextContent(domElement, nextProp);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">'number'</span>) {
            setTextContent(domElement, <span class="hljs-string">''</span> + nextProp);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === AUTOFOCUS) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) {
          <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp !== <span class="hljs-string">'function'</span>) {
              warnForInvalidEventListener(propKey, nextProp);
            }

            ensureListeningTo(rootContainerElement, propKey);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
          setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDOMProperties</span>(<span class="hljs-params">domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-413" id="section-413"></a>
</div>
<p>TODO: Handle wasCustomComponentTag</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; updatePayload.length; i += <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">var</span> propKey = updatePayload[i];
        <span class="hljs-keyword">var</span> propValue = updatePayload[i + <span class="hljs-number">1</span>];

        <span class="hljs-keyword">if</span> (propKey === STYLE) {
          setValueForStyles(domElement, propValue);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) {
          setInnerHTML(domElement, propValue);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
          setTextContent(domElement, propValue);
        } <span class="hljs-keyword">else</span> {
          setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">type, props, rootContainerElement, parentNamespace</span>) </span>{
      <span class="hljs-keyword">var</span> isCustomComponentTag; <span class="hljs-comment">// We create tags in the namespace of their parent container, except HTML</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-414" id="section-414"></a>
</div>
<p>tags get no namespace.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
      <span class="hljs-keyword">var</span> domElement;
      <span class="hljs-keyword">var</span> namespaceURI = parentNamespace;

      <span class="hljs-keyword">if</span> (namespaceURI === HTML_NAMESPACE$<span class="hljs-number">1</span>) {
        namespaceURI = getIntrinsicNamespace(type);
      }

      <span class="hljs-keyword">if</span> (namespaceURI === HTML_NAMESPACE$<span class="hljs-number">1</span>) {
        {
          isCustomComponentTag = isCustomComponent(type, props); <span class="hljs-comment">// Should this check be gated by parent namespace? Not sure we want to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-415" id="section-415"></a>
</div>
<p>allow <SVG> or <mATH>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">if</span> (!isCustomComponentTag &amp;&amp; type !== type.toLowerCase()) {
            error(<span class="hljs-string">'&lt;%s /&gt; is using incorrect casing. '</span> + <span class="hljs-string">'Use PascalCase for React components, '</span> + <span class="hljs-string">'or lowercase for HTML elements.'</span>, type);
          }
        }

        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'script'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-416" id="section-416"></a>
</div>
<p>Create the script via .innerHTML so its &quot;parser-inserted&quot; flag is
set to true and it does not execute</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> div = ownerDocument.createElement(<span class="hljs-string">'div'</span>);
          div.innerHTML = <span class="hljs-string">'&lt;script&gt;&lt;'</span> + <span class="hljs-string">'/script&gt;'</span>; <span class="hljs-comment">// eslint-disable-line</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-417" id="section-417"></a>
</div>
<p>This is guaranteed to yield a script element.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">var</span> firstChild = div.firstChild;
          domElement = div.removeChild(firstChild);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.is === <span class="hljs-string">'string'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-418" id="section-418"></a>
</div>
<p>$FlowIssue <code>createElement</code> should be updated for Web Components</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          domElement = ownerDocument.createElement(type, {
            <span class="hljs-attr">is</span>: props.is
          });
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-419" id="section-419"></a>
</div>
<p>Separate else branch instead of using <code>props.is || undefined</code> above because of a Firefox bug.
See discussion in https://github.com/facebook/react/pull/6896
and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          domElement = ownerDocument.createElement(type); <span class="hljs-comment">// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-420" id="section-420"></a>
</div>
<p>attributes on <code>select</code>s needs to be added before <code>option</code>s are inserted.
This prevents:</p>
<ul>
<li>a bug where the <code>select</code> does not scroll to the correct option because singular
<code>select</code> elements automatically pick the first item #13222</li>
<li>a bug where the <code>select</code> set the first item as selected despite the <code>size</code> attribute #14239
See https://github.com/facebook/react/issues/13222
and https://github.com/facebook/react/issues/14239</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'select'</span>) {
            <span class="hljs-keyword">var</span> node = domElement;

            <span class="hljs-keyword">if</span> (props.multiple) {
              node.multiple = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (props.size) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-421" id="section-421"></a>
</div>
<p>Setting a size greater than 1 causes a select to behave like <code>multiple=true</code>, where
it is possible that no option is selected.</p>
<p>This is only necessary when a select in &quot;single selection mode&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              node.size = props.size;
            }
          }
        }
      } <span class="hljs-keyword">else</span> {
        domElement = ownerDocument.createElementNS(namespaceURI, type);
      }

      {
        <span class="hljs-keyword">if</span> (namespaceURI === HTML_NAMESPACE$<span class="hljs-number">1</span>) {
          <span class="hljs-keyword">if</span> (!isCustomComponentTag &amp;&amp; <span class="hljs-built_in">Object</span>.prototype.toString.call(domElement) === <span class="hljs-string">'[object HTMLUnknownElement]'</span> &amp;&amp; !<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
            warnedUnknownTags[type] = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'The tag &lt;%s&gt; is unrecognized in this browser. '</span> + <span class="hljs-string">'If you meant to render a React component, start its name with '</span> + <span class="hljs-string">'an uppercase letter.'</span>, type);
          }
        }
      }
      <span class="hljs-keyword">return</span> domElement;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTextNode</span>(<span class="hljs-params">text, rootContainerElement</span>) </span>{
      <span class="hljs-keyword">return</span> getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitialProperties</span>(<span class="hljs-params">domElement, tag, rawProps, rootContainerElement</span>) </span>{
      <span class="hljs-keyword">var</span> isCustomComponentTag = isCustomComponent(tag, rawProps);
      {
        validatePropertiesInDevelopment(tag, rawProps);
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make sure that we check isMounted before firing any of these events.</span>

      <span class="hljs-keyword">var</span> props;

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'iframe'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'embed'</span>:
          trapBubbledEvent(TOP_LOAD, domElement);
          props = rawProps;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'video'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'audio'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-422" id="section-422"></a>
</div>
<p>Create listener for each media event</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mediaEventTypes.length; i++) {
            trapBubbledEvent(mediaEventTypes[i], domElement);
          }

          props = rawProps;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'source'</span>:
          trapBubbledEvent(TOP_ERROR, domElement);
          props = rawProps;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'img'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'image'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'link'</span>:
          trapBubbledEvent(TOP_ERROR, domElement);
          trapBubbledEvent(TOP_LOAD, domElement);
          props = rawProps;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'form'</span>:
          trapBubbledEvent(TOP_RESET, domElement);
          trapBubbledEvent(TOP_SUBMIT, domElement);
          props = rawProps;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'details'</span>:
          trapBubbledEvent(TOP_TOGGLE, domElement);
          props = rawProps;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
          initWrapperState(domElement, rawProps);
          props = getHostProps(domElement, rawProps);
          trapBubbledEvent(TOP_INVALID, domElement); <span class="hljs-comment">// For controlled components we always need to ensure we're listening</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-423" id="section-423"></a>
</div>
<p>to onChange. Even if there is no listener.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          ensureListeningTo(rootContainerElement, <span class="hljs-string">'onChange'</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'option'</span>:
          validateProps(domElement, rawProps);
          props = getHostProps$<span class="hljs-number">1</span>(domElement, rawProps);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
          initWrapperState$<span class="hljs-number">1</span>(domElement, rawProps);
          props = getHostProps$<span class="hljs-number">2</span>(domElement, rawProps);
          trapBubbledEvent(TOP_INVALID, domElement); <span class="hljs-comment">// For controlled components we always need to ensure we're listening</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-424" id="section-424"></a>
</div>
<p>to onChange. Even if there is no listener.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          ensureListeningTo(rootContainerElement, <span class="hljs-string">'onChange'</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
          initWrapperState$<span class="hljs-number">2</span>(domElement, rawProps);
          props = getHostProps$<span class="hljs-number">3</span>(domElement, rawProps);
          trapBubbledEvent(TOP_INVALID, domElement); <span class="hljs-comment">// For controlled components we always need to ensure we're listening</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-425" id="section-425"></a>
</div>
<p>to onChange. Even if there is no listener.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          ensureListeningTo(rootContainerElement, <span class="hljs-string">'onChange'</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          props = rawProps;
      }

      assertValidProps(tag, props);
      setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-426" id="section-426"></a>
</div>
<p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          track(domElement);
          postMountWrapper(domElement, rawProps, <span class="hljs-literal">false</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-427" id="section-427"></a>
</div>
<p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          track(domElement);
          postMountWrapper$<span class="hljs-number">3</span>(domElement);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'option'</span>:
          postMountWrapper$<span class="hljs-number">1</span>(domElement, rawProps);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
          postMountWrapper$<span class="hljs-number">2</span>(domElement, rawProps);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.onClick === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-428" id="section-428"></a>
</div>
<p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            trapClickOnNonInteractiveElement(domElement);
          }

          <span class="hljs-keyword">break</span>;
      }
    } <span class="hljs-comment">// Calculate the diff between the two objects.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffProperties</span>(<span class="hljs-params">domElement, tag, lastRawProps, nextRawProps, rootContainerElement</span>) </span>{
      {
        validatePropertiesInDevelopment(tag, nextRawProps);
      }
      <span class="hljs-keyword">var</span> updatePayload = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> lastProps;
      <span class="hljs-keyword">var</span> nextProps;

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
          lastProps = getHostProps(domElement, lastRawProps);
          nextProps = getHostProps(domElement, nextRawProps);
          updatePayload = [];
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'option'</span>:
          lastProps = getHostProps$<span class="hljs-number">1</span>(domElement, lastRawProps);
          nextProps = getHostProps$<span class="hljs-number">1</span>(domElement, nextRawProps);
          updatePayload = [];
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
          lastProps = getHostProps$<span class="hljs-number">2</span>(domElement, lastRawProps);
          nextProps = getHostProps$<span class="hljs-number">2</span>(domElement, nextRawProps);
          updatePayload = [];
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
          lastProps = getHostProps$<span class="hljs-number">3</span>(domElement, lastRawProps);
          nextProps = getHostProps$<span class="hljs-number">3</span>(domElement, nextRawProps);
          updatePayload = [];
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          lastProps = lastRawProps;
          nextProps = nextRawProps;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> lastProps.onClick !== <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> nextProps.onClick === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-429" id="section-429"></a>
</div>
<p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            trapClickOnNonInteractiveElement(domElement);
          }

          <span class="hljs-keyword">break</span>;
      }

      assertValidProps(tag, nextProps);
      <span class="hljs-keyword">var</span> propKey;
      <span class="hljs-keyword">var</span> styleName;
      <span class="hljs-keyword">var</span> styleUpdates = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (propKey <span class="hljs-keyword">in</span> lastProps) {
        <span class="hljs-keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (propKey === STYLE) {
          <span class="hljs-keyword">var</span> lastStyle = lastProps[propKey];

          <span class="hljs-keyword">for</span> (styleName <span class="hljs-keyword">in</span> lastStyle) {
            <span class="hljs-keyword">if</span> (lastStyle.hasOwnProperty(styleName)) {
              <span class="hljs-keyword">if</span> (!styleUpdates) {
                styleUpdates = {};
              }

              styleUpdates[styleName] = <span class="hljs-string">''</span>;
            }
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === AUTOFOCUS) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-430" id="section-430"></a>
</div>
<p>This is a special case. If any listener updates we need to ensure
that the &quot;current&quot; fiber pointer gets updated so we need a commit
to update this element.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (!updatePayload) {
            updatePayload = [];
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-431" id="section-431"></a>
</div>
<p>For all other deleted properties we add it to the queue. We use
the whitelist in the commit phase instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          (updatePayload = updatePayload || []).push(propKey, <span class="hljs-literal">null</span>);
        }
      }

      <span class="hljs-keyword">for</span> (propKey <span class="hljs-keyword">in</span> nextProps) {
        <span class="hljs-keyword">var</span> nextProp = nextProps[propKey];
        <span class="hljs-keyword">var</span> lastProp = lastProps != <span class="hljs-literal">null</span> ? lastProps[propKey] : <span class="hljs-literal">undefined</span>;

        <span class="hljs-keyword">if</span> (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == <span class="hljs-literal">null</span> &amp;&amp; lastProp == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (propKey === STYLE) {
          {
            <span class="hljs-keyword">if</span> (nextProp) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-432" id="section-432"></a>
</div>
<p>Freeze the next style object so that we can assume it won't be
mutated. We have already warned for this in the past.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-built_in">Object</span>.freeze(nextProp);
            }
          }

          <span class="hljs-keyword">if</span> (lastProp) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-433" id="section-433"></a>
</div>
<p>Unset styles on <code>lastProp</code> but not on <code>nextProp</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">for</span> (styleName <span class="hljs-keyword">in</span> lastProp) {
              <span class="hljs-keyword">if</span> (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                <span class="hljs-keyword">if</span> (!styleUpdates) {
                  styleUpdates = {};
                }

                styleUpdates[styleName] = <span class="hljs-string">''</span>;
              }
            } <span class="hljs-comment">// Update styles that changed since `lastProp`.</span>


            <span class="hljs-keyword">for</span> (styleName <span class="hljs-keyword">in</span> nextProp) {
              <span class="hljs-keyword">if</span> (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {
                <span class="hljs-keyword">if</span> (!styleUpdates) {
                  styleUpdates = {};
                }

                styleUpdates[styleName] = nextProp[styleName];
              }
            }
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-434" id="section-434"></a>
</div>
<p>Relies on <code>updateStylesByID</code> not mutating <code>styleUpdates</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (!styleUpdates) {
              <span class="hljs-keyword">if</span> (!updatePayload) {
                updatePayload = [];
              }

              updatePayload.push(propKey, styleUpdates);
            }

            styleUpdates = nextProp;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) {
          <span class="hljs-keyword">var</span> nextHtml = nextProp ? nextProp[HTML$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;
          <span class="hljs-keyword">var</span> lastHtml = lastProp ? lastProp[HTML$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;

          <span class="hljs-keyword">if</span> (nextHtml != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (lastHtml !== nextHtml) {
              (updatePayload = updatePayload || []).push(propKey, nextHtml);
            }
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
          <span class="hljs-keyword">if</span> (lastProp !== nextProp &amp;&amp; (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">'number'</span>)) {
            (updatePayload = updatePayload || []).push(propKey, <span class="hljs-string">''</span> + nextProp);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) {
          <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-435" id="section-435"></a>
</div>
<p>We eagerly listen to this even though we haven't committed yet.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp !== <span class="hljs-string">'function'</span>) {
              warnForInvalidEventListener(propKey, nextProp);
            }

            ensureListeningTo(rootContainerElement, propKey);
          }

          <span class="hljs-keyword">if</span> (!updatePayload &amp;&amp; lastProp !== nextProp) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-436" id="section-436"></a>
</div>
<p>This is a special case. If any listener updates we need to ensure
that the &quot;current&quot; props pointer gets updated so we need a commit
to update this element.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            updatePayload = [];
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-437" id="section-437"></a>
</div>
<p>For any other property we always add it to the queue and then we
filter it out using the whitelist during the commit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          (updatePayload = updatePayload || []).push(propKey, nextProp);
        }
      }

      <span class="hljs-keyword">if</span> (styleUpdates) {
        {
          validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
        }
        (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
      }

      <span class="hljs-keyword">return</span> updatePayload;
    } <span class="hljs-comment">// Apply the diff.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateProperties</span>(<span class="hljs-params">domElement, updatePayload, tag, lastRawProps, nextRawProps</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-438" id="section-438"></a>
</div>
<p>Update checked <em>before</em> name.
In the middle of an update, it is possible to have multiple checked.
When a checked radio tries to change name, browser makes another radio's checked false.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'input'</span> &amp;&amp; nextRawProps.type === <span class="hljs-string">'radio'</span> &amp;&amp; nextRawProps.name != <span class="hljs-literal">null</span>) {
        updateChecked(domElement, nextRawProps);
      }

      <span class="hljs-keyword">var</span> wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
      <span class="hljs-keyword">var</span> isCustomComponentTag = isCustomComponent(tag, nextRawProps); <span class="hljs-comment">// Apply the diff.</span>

      updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Ensure that an update gets scheduled if any of the special props</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-439" id="section-439"></a>
</div>
<p>changed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-440" id="section-440"></a>
</div>
<p>Update the wrapper around inputs <em>after</em> updating props. This has to
happen after <code>updateDOMProperties</code>. Otherwise HTML5 input validations
raise warnings and prevent the new value from being assigned.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          updateWrapper(domElement, nextRawProps);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
          updateWrapper$<span class="hljs-number">1</span>(domElement, nextRawProps);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-441" id="section-441"></a>
</div>
<p><select> value update needs to occur after <option> children
reconciliation</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          postUpdateWrapper(domElement, nextRawProps);
          <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPossibleStandardName</span>(<span class="hljs-params">propName</span>) </span>{
      {
        <span class="hljs-keyword">var</span> lowerCasedName = propName.toLowerCase();

        <span class="hljs-keyword">if</span> (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> possibleStandardNames[lowerCasedName] || <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffHydratedProperties</span>(<span class="hljs-params">domElement, tag, rawProps, parentNamespace, rootContainerElement</span>) </span>{
      <span class="hljs-keyword">var</span> isCustomComponentTag;
      <span class="hljs-keyword">var</span> extraAttributeNames;
      {
        suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === <span class="hljs-literal">true</span>;
        isCustomComponentTag = isCustomComponent(tag, rawProps);
        validatePropertiesInDevelopment(tag, rawProps);
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make sure that we check isMounted before firing any of these events.</span>

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'iframe'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'embed'</span>:
          trapBubbledEvent(TOP_LOAD, domElement);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'video'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'audio'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-442" id="section-442"></a>
</div>
<p>Create listener for each media event</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mediaEventTypes.length; i++) {
            trapBubbledEvent(mediaEventTypes[i], domElement);
          }

          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'source'</span>:
          trapBubbledEvent(TOP_ERROR, domElement);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'img'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'image'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'link'</span>:
          trapBubbledEvent(TOP_ERROR, domElement);
          trapBubbledEvent(TOP_LOAD, domElement);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'form'</span>:
          trapBubbledEvent(TOP_RESET, domElement);
          trapBubbledEvent(TOP_SUBMIT, domElement);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'details'</span>:
          trapBubbledEvent(TOP_TOGGLE, domElement);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
          initWrapperState(domElement, rawProps);
          trapBubbledEvent(TOP_INVALID, domElement); <span class="hljs-comment">// For controlled components we always need to ensure we're listening</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-443" id="section-443"></a>
</div>
<p>to onChange. Even if there is no listener.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          ensureListeningTo(rootContainerElement, <span class="hljs-string">'onChange'</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'option'</span>:
          validateProps(domElement, rawProps);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
          initWrapperState$<span class="hljs-number">1</span>(domElement, rawProps);
          trapBubbledEvent(TOP_INVALID, domElement); <span class="hljs-comment">// For controlled components we always need to ensure we're listening</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-444" id="section-444"></a>
</div>
<p>to onChange. Even if there is no listener.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          ensureListeningTo(rootContainerElement, <span class="hljs-string">'onChange'</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
          initWrapperState$<span class="hljs-number">2</span>(domElement, rawProps);
          trapBubbledEvent(TOP_INVALID, domElement); <span class="hljs-comment">// For controlled components we always need to ensure we're listening</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-445" id="section-445"></a>
</div>
<p>to onChange. Even if there is no listener.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          ensureListeningTo(rootContainerElement, <span class="hljs-string">'onChange'</span>);
          <span class="hljs-keyword">break</span>;
      }

      assertValidProps(tag, rawProps);
      {
        extraAttributeNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
        <span class="hljs-keyword">var</span> attributes = domElement.attributes;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; attributes.length; _i++) {
          <span class="hljs-keyword">var</span> name = attributes[_i].name.toLowerCase();

          <span class="hljs-keyword">switch</span> (name) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-446" id="section-446"></a>
</div>
<p>Built-in SSR attribute is whitelisted</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">case</span> <span class="hljs-string">'data-reactroot'</span>:
              <span class="hljs-keyword">break</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-447" id="section-447"></a>
</div>
<p>Controlled attributes are not validated
TODO: Only ignore them on controlled tags.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">case</span> <span class="hljs-string">'value'</span>:
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">'checked'</span>:
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> <span class="hljs-string">'selected'</span>:
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-448" id="section-448"></a>
</div>
<p>Intentionally use the original name.
See discussion in https://github.com/facebook/react/pull/10676.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              extraAttributeNames.add(attributes[_i].name);
          }
        }
      }
      <span class="hljs-keyword">var</span> updatePayload = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propKey <span class="hljs-keyword">in</span> rawProps) {
        <span class="hljs-keyword">if</span> (!rawProps.hasOwnProperty(propKey)) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> nextProp = rawProps[propKey];

        <span class="hljs-keyword">if</span> (propKey === CHILDREN) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-449" id="section-449"></a>
</div>
<p>For text content children we compare against textContent. This
might match additional HTML that is hidden when we read it using
textContent. E.g. &quot;foo&quot; will match &quot;f<span>oo</span>&quot; but that still
satisfies our requirement. Our requirement is not to produce perfect
HTML and attributes. Ideally we should preserve structure but it's
ok not to if the visible content is still enough to indicate what
even listeners these nodes might be wired up to.
TODO: Warn if there is more than a single textNode as a child.
TODO: Should we use domElement.firstChild.nodeValue to compare?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">'string'</span>) {
            <span class="hljs-keyword">if</span> (domElement.textContent !== nextProp) {
              <span class="hljs-keyword">if</span> (!suppressHydrationWarning) {
                warnForTextDifference(domElement.textContent, nextProp);
              }

              updatePayload = [CHILDREN, nextProp];
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">'number'</span>) {
            <span class="hljs-keyword">if</span> (domElement.textContent !== <span class="hljs-string">''</span> + nextProp) {
              <span class="hljs-keyword">if</span> (!suppressHydrationWarning) {
                warnForTextDifference(domElement.textContent, nextProp);
              }

              updatePayload = [CHILDREN, <span class="hljs-string">''</span> + nextProp];
            }
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) {
          <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp !== <span class="hljs-string">'function'</span>) {
              warnForInvalidEventListener(propKey, nextProp);
            }

            ensureListeningTo(rootContainerElement, propKey);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Convince Flow we've calculated it (it's DEV-only in this method.)</span>
        <span class="hljs-keyword">typeof</span> isCustomComponentTag === <span class="hljs-string">'boolean'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-450" id="section-450"></a>
</div>
<p>Validate that the properties correspond to their expected values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> serverValue = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> propertyInfo = getPropertyInfo(propKey);
          <span class="hljs-keyword">if</span> (suppressHydrationWarning) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || <span class="hljs-comment">// Controlled attributes are not validated</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-451" id="section-451"></a>
</div>
<p>TODO: Only ignore them on controlled tags.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          propKey === <span class="hljs-string">'value'</span> || propKey === <span class="hljs-string">'checked'</span> || propKey === <span class="hljs-string">'selected'</span>) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) {
            <span class="hljs-keyword">var</span> serverHTML = domElement.innerHTML;
            <span class="hljs-keyword">var</span> nextHtml = nextProp ? nextProp[HTML$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;
            <span class="hljs-keyword">var</span> expectedHTML = normalizeHTML(domElement, nextHtml != <span class="hljs-literal">null</span> ? nextHtml : <span class="hljs-string">''</span>);

            <span class="hljs-keyword">if</span> (expectedHTML !== serverHTML) {
              warnForPropDifference(propKey, serverHTML, expectedHTML);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === STYLE) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-452" id="section-452"></a>
</div>
<p>$FlowFixMe - Should be inferred as not undefined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            extraAttributeNames.delete(propKey);

            <span class="hljs-keyword">if</span> (canDiffStyleForHydrationWarning) {
              <span class="hljs-keyword">var</span> expectedStyle = createDangerousStringForStyles(nextProp);
              serverValue = domElement.getAttribute(<span class="hljs-string">'style'</span>);

              <span class="hljs-keyword">if</span> (expectedStyle !== serverValue) {
                warnForPropDifference(propKey, serverValue, expectedStyle);
              }
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCustomComponentTag) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-453" id="section-453"></a>
</div>
<p>$FlowFixMe - Should be inferred as not undefined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            extraAttributeNames.delete(propKey.toLowerCase());
            serverValue = getValueForAttribute(domElement, propKey, nextProp);

            <span class="hljs-keyword">if</span> (nextProp !== serverValue) {
              warnForPropDifference(propKey, serverValue, nextProp);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) &amp;&amp; !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
            <span class="hljs-keyword">var</span> isMismatchDueToBadCasing = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-454" id="section-454"></a>
</div>
<p>$FlowFixMe - Should be inferred as not undefined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              extraAttributeNames.delete(propertyInfo.attributeName);
              serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> ownNamespace = parentNamespace;

              <span class="hljs-keyword">if</span> (ownNamespace === HTML_NAMESPACE$<span class="hljs-number">1</span>) {
                ownNamespace = getIntrinsicNamespace(tag);
              }

              <span class="hljs-keyword">if</span> (ownNamespace === HTML_NAMESPACE$<span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-455" id="section-455"></a>
</div>
<p>$FlowFixMe - Should be inferred as not undefined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                extraAttributeNames.delete(propKey.toLowerCase());
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> standardName = getPossibleStandardName(propKey);

                <span class="hljs-keyword">if</span> (standardName !== <span class="hljs-literal">null</span> &amp;&amp; standardName !== propKey) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-456" id="section-456"></a>
</div>
<p>If an SVG prop is supplied with bad casing, it will
be successfully parsed from HTML, but will produce a mismatch
(and would be incorrectly rendered on the client).
However, we already warn about bad casing elsewhere.
So we'll skip the misleading extra mismatch warning in this case.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  isMismatchDueToBadCasing = <span class="hljs-literal">true</span>; <span class="hljs-comment">// $FlowFixMe - Should be inferred as not undefined.</span>

                  extraAttributeNames.delete(standardName);
                } <span class="hljs-comment">// $FlowFixMe - Should be inferred as not undefined.</span>


                extraAttributeNames.delete(propKey);
              }

              serverValue = getValueForAttribute(domElement, propKey, nextProp);
            }

            <span class="hljs-keyword">if</span> (nextProp !== serverValue &amp;&amp; !isMismatchDueToBadCasing) {
              warnForPropDifference(propKey, serverValue, nextProp);
            }
          }
        }
      }

      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-457" id="section-457"></a>
</div>
<p>$FlowFixMe - Should be inferred as not undefined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (extraAttributeNames.size &gt; <span class="hljs-number">0</span> &amp;&amp; !suppressHydrationWarning) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-458" id="section-458"></a>
</div>
<p>$FlowFixMe - Should be inferred as not undefined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          warnForExtraAttributes(extraAttributeNames);
        }
      }

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-459" id="section-459"></a>
</div>
<p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          track(domElement);
          postMountWrapper(domElement, rawProps, <span class="hljs-literal">true</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-460" id="section-460"></a>
</div>
<p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          track(domElement);
          postMountWrapper$<span class="hljs-number">3</span>(domElement);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'option'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-461" id="section-461"></a>
</div>
<p>For input and textarea we current always set the value property at
post mount to force it to diverge from attributes. However, for
option and select we don't quite do the same thing and select
is not resilient to the DOM state changing so we don't do that here.
TODO: Consider not doing this for input and textarea.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> rawProps.onClick === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-462" id="section-462"></a>
</div>
<p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            trapClickOnNonInteractiveElement(domElement);
          }

          <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">return</span> updatePayload;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffHydratedText</span>(<span class="hljs-params">textNode, text</span>) </span>{
      <span class="hljs-keyword">var</span> isDifferent = textNode.nodeValue !== text;
      <span class="hljs-keyword">return</span> isDifferent;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnForUnmatchedText</span>(<span class="hljs-params">textNode, text</span>) </span>{
      {
        warnForTextDifference(textNode.nodeValue, text);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnForDeletedHydratableElement</span>(<span class="hljs-params">parentNode, child</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnInvalidHydration = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Did not expect server HTML to contain a &lt;%s&gt; in &lt;%s&gt;.'</span>, child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnForDeletedHydratableText</span>(<span class="hljs-params">parentNode, child</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnInvalidHydration = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Did not expect server HTML to contain the text node "%s" in &lt;%s&gt;.'</span>, child.nodeValue, parentNode.nodeName.toLowerCase());
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnForInsertedHydratedElement</span>(<span class="hljs-params">parentNode, tag, props</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnInvalidHydration = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Expected server HTML to contain a matching &lt;%s&gt; in &lt;%s&gt;.'</span>, tag, parentNode.nodeName.toLowerCase());
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnForInsertedHydratedText</span>(<span class="hljs-params">parentNode, text</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (text === <span class="hljs-string">''</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-463" id="section-463"></a>
</div>
<p>We expect to insert empty text nodes since they're not represented in
the HTML.
TODO: Remove this special case if we can just avoid inserting empty
text nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnInvalidHydration = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Expected server HTML to contain a matching text node for "%s" in &lt;%s&gt;.'</span>, text, parentNode.nodeName.toLowerCase());
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreControlledState$3</span>(<span class="hljs-params">domElement, tag, props</span>) </span>{
      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
          restoreControlledState(domElement, props);
          <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
          restoreControlledState$<span class="hljs-number">2</span>(domElement, props);
          <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
          restoreControlledState$<span class="hljs-number">1</span>(domElement, props);
          <span class="hljs-keyword">return</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getActiveElement</span>(<span class="hljs-params">doc</span>) </span>{
      doc = doc || (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">document</span> !== <span class="hljs-string">'undefined'</span> ? <span class="hljs-built_in">document</span> : <span class="hljs-literal">undefined</span>);

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> doc === <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> doc.activeElement || doc.body;
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> doc.body;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-464" id="section-464"></a>
</div>
<div class="dox">
<div class="summary">
<p>Given any node return the first leaf node without children.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
<span class="dox_type">DOMTextNode</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">DOMElement</span>
<span class="dox_type">DOMTextNode</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLeafNode</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">while</span> (node &amp;&amp; node.firstChild) {
        node = node.firstChild;
      }

      <span class="hljs-keyword">return</span> node;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-465" id="section-465"></a>
</div>
<div class="dox">
<div class="summary">
<p>Get the next sibling within a container. This will walk up the
DOM if a node's siblings have been exhausted.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
<span class="dox_type">DOMTextNode</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">DOMElement</span>
<span class="dox_type">DOMTextNode</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSiblingNode</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">while</span> (node) {
        <span class="hljs-keyword">if</span> (node.nextSibling) {
          <span class="hljs-keyword">return</span> node.nextSibling;
        }

        node = node.parentNode;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-466" id="section-466"></a>
</div>
<div class="dox">
<div class="summary">
<p>Get object describing the nodes which contain characters at offset.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">root</span>
<span class="dox_type">DOMElement</span>
<span class="dox_type">DOMTextNode</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">offset</span>
<span class="dox_type">number</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeForCharacterOffset</span>(<span class="hljs-params">root, offset</span>) </span>{
      <span class="hljs-keyword">var</span> node = getLeafNode(root);
      <span class="hljs-keyword">var</span> nodeStart = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> nodeEnd = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">while</span> (node) {
        <span class="hljs-keyword">if</span> (node.nodeType === TEXT_NODE) {
          nodeEnd = nodeStart + node.textContent.length;

          <span class="hljs-keyword">if</span> (nodeStart &lt;= offset &amp;&amp; nodeEnd &gt;= offset) {
            <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">node</span>: node,
              <span class="hljs-attr">offset</span>: offset - nodeStart
            };
          }

          nodeStart = nodeEnd;
        }

        node = getLeafNode(getSiblingNode(node));
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-467" id="section-467"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">outerNode</span>
<span class="dox_type">DOMElement</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOffsets</span>(<span class="hljs-params">outerNode</span>) </span>{
      <span class="hljs-keyword">var</span> ownerDocument = outerNode.ownerDocument;
      <span class="hljs-keyword">var</span> win = ownerDocument &amp;&amp; ownerDocument.defaultView || <span class="hljs-built_in">window</span>;
      <span class="hljs-keyword">var</span> selection = win.getSelection &amp;&amp; win.getSelection();

      <span class="hljs-keyword">if</span> (!selection || selection.rangeCount === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> anchorNode = selection.anchorNode,
          anchorOffset = selection.anchorOffset,
          focusNode = selection.focusNode,
          focusOffset = selection.focusOffset; <span class="hljs-comment">// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-468" id="section-468"></a>
</div>
<p>up/down buttons on an <input type="number">. Anonymous divs do not seem to
expose properties, triggering a &quot;Permission denied error&quot; if any of its
properties are accessed. The only seemingly possible way to avoid erroring
is to access a property that typically works for non-anonymous divs and
catch any error that may otherwise arise. See
https://bugzilla.mozilla.org/show_bug.cgi?id=208427</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">/* eslint-disable no-unused-expressions */</span>
        anchorNode.nodeType;
        focusNode.nodeType;
        <span class="hljs-comment">/* eslint-enable no-unused-expressions */</span>
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-469" id="section-469"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns {start, end} where <code>start</code> is the character/codepoint index of
(anchorNode, anchorOffset) within the textContent of <code>outerNode</code>, and
<code>end</code> is the index of (focusNode, focusOffset).</p>
</div>
<div class="body">
<p>Returns null if you pass in garbage input but we should probably just crash.</p>
<p>Exported only for testing.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getModernOffsetsFromPoints</span>(<span class="hljs-params">outerNode, anchorNode, anchorOffset, focusNode, focusOffset</span>) </span>{
      <span class="hljs-keyword">var</span> length = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> start = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">var</span> end = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">var</span> indexWithinAnchor = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> indexWithinFocus = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> node = outerNode;
      <span class="hljs-keyword">var</span> parentNode = <span class="hljs-literal">null</span>;

      outer: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> next = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">if</span> (node === anchorNode &amp;&amp; (anchorOffset === <span class="hljs-number">0</span> || node.nodeType === TEXT_NODE)) {
            start = length + anchorOffset;
          }

          <span class="hljs-keyword">if</span> (node === focusNode &amp;&amp; (focusOffset === <span class="hljs-number">0</span> || node.nodeType === TEXT_NODE)) {
            end = length + focusOffset;
          }

          <span class="hljs-keyword">if</span> (node.nodeType === TEXT_NODE) {
            length += node.nodeValue.length;
          }

          <span class="hljs-keyword">if</span> ((next = node.firstChild) === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">break</span>;
          } <span class="hljs-comment">// Moving from `node` to its first child `next`.</span>


          parentNode = node;
          node = next;
        }

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">if</span> (node === outerNode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-470" id="section-470"></a>
</div>
<p>If <code>outerNode</code> has children, this is always the second time visiting
it. If it has no children, this is still the first loop, and the only
valid selection is anchorNode and focusNode both equal to this node
and both offsets 0, in which case we will have handled above.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">break</span> outer;
          }

          <span class="hljs-keyword">if</span> (parentNode === anchorNode &amp;&amp; ++indexWithinAnchor === anchorOffset) {
            start = length;
          }

          <span class="hljs-keyword">if</span> (parentNode === focusNode &amp;&amp; ++indexWithinFocus === focusOffset) {
            end = length;
          }

          <span class="hljs-keyword">if</span> ((next = node.nextSibling) !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">break</span>;
          }

          node = parentNode;
          parentNode = node.parentNode;
        } <span class="hljs-comment">// Moving from `node` to its next sibling `next`.</span>


        node = next;
      }

      <span class="hljs-keyword">if</span> (start === <span class="hljs-number">-1</span> || end === <span class="hljs-number">-1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-471" id="section-471"></a>
</div>
<p>This should never happen. (Would happen if the anchor/focus nodes aren't
actually inside the passed-in node.)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">start</span>: start,
        <span class="hljs-attr">end</span>: end
      };
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-472" id="section-472"></a>
</div>
<div class="dox">
<div class="summary">
<p>In modern non-IE browsers, we can support both forward and backward
selections.</p>
</div>
<div class="body">
<p>Note: IE10+ supports the Selection object, but it does not support
the <code>extend</code> method, which means that even in modern IE, it's not possible
to programmatically create a backward selection. Thus, for all IE
versions, we use the old IE API to create our selections.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
<span class="dox_type">DOMTextNode</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">offsets</span>
<span class="dox_type">object</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setOffsets</span>(<span class="hljs-params">node, offsets</span>) </span>{
      <span class="hljs-keyword">var</span> doc = node.ownerDocument || <span class="hljs-built_in">document</span>;
      <span class="hljs-keyword">var</span> win = doc &amp;&amp; doc.defaultView || <span class="hljs-built_in">window</span>; <span class="hljs-comment">// Edge fails with "Object expected" in some scenarios.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-473" id="section-473"></a>
</div>
<p>(For instance: TinyMCE editor used in a list component that supports pasting to add more,
fails when pasting 100+ items)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (!win.getSelection) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> selection = win.getSelection();
      <span class="hljs-keyword">var</span> length = node.textContent.length;
      <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Math</span>.min(offsets.start, length);
      <span class="hljs-keyword">var</span> end = offsets.end === <span class="hljs-literal">undefined</span> ? start : <span class="hljs-built_in">Math</span>.min(offsets.end, length); <span class="hljs-comment">// IE 11 uses modern selection, but doesn't support the extend method.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-474" id="section-474"></a>
</div>
<p>Flip backward selections, so we can set with a single range.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (!selection.extend &amp;&amp; start &gt; end) {
        <span class="hljs-keyword">var</span> temp = end;
        end = start;
        start = temp;
      }

      <span class="hljs-keyword">var</span> startMarker = getNodeForCharacterOffset(node, start);
      <span class="hljs-keyword">var</span> endMarker = getNodeForCharacterOffset(node, end);

      <span class="hljs-keyword">if</span> (startMarker &amp;&amp; endMarker) {
        <span class="hljs-keyword">if</span> (selection.rangeCount === <span class="hljs-number">1</span> &amp;&amp; selection.anchorNode === startMarker.node &amp;&amp; selection.anchorOffset === startMarker.offset &amp;&amp; selection.focusNode === endMarker.node &amp;&amp; selection.focusOffset === endMarker.offset) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> range = doc.createRange();
        range.setStart(startMarker.node, startMarker.offset);
        selection.removeAllRanges();

        <span class="hljs-keyword">if</span> (start &gt; end) {
          selection.addRange(range);
          selection.extend(endMarker.node, endMarker.offset);
        } <span class="hljs-keyword">else</span> {
          range.setEnd(endMarker.node, endMarker.offset);
          selection.addRange(range);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTextNode</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node &amp;&amp; node.nodeType === TEXT_NODE;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">containsNode</span>(<span class="hljs-params">outerNode, innerNode</span>) </span>{
      <span class="hljs-keyword">if</span> (!outerNode || !innerNode) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (outerNode === innerNode) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTextNode(outerNode)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTextNode(innerNode)) {
        <span class="hljs-keyword">return</span> containsNode(outerNode, innerNode.parentNode);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'contains'</span> <span class="hljs-keyword">in</span> outerNode) {
        <span class="hljs-keyword">return</span> outerNode.contains(innerNode);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (outerNode.compareDocumentPosition) {
        <span class="hljs-keyword">return</span> !!(outerNode.compareDocumentPosition(innerNode) &amp; <span class="hljs-number">16</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInDocument</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node &amp;&amp; node.ownerDocument &amp;&amp; containsNode(node.ownerDocument.documentElement, node);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSameOriginFrame</span>(<span class="hljs-params">iframe</span>) </span>{
      <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-475" id="section-475"></a>
</div>
<p>Accessing the contentDocument of a HTMLIframeElement can cause the browser
to throw, e.g. if it has a cross-origin src attribute.
Safari will show an error in the console when the access results in &quot;Blocked a frame with origin&quot;. e.g:
iframe.contentDocument.defaultView;
A safety way is to access one of the cross origin properties: Window or Location
Which might result in &quot;SecurityError&quot; DOM Exception and it is compatible to Safari.
https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> iframe.contentWindow.location.href === <span class="hljs-string">'string'</span>;
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getActiveElementDeep</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> win = <span class="hljs-built_in">window</span>;
      <span class="hljs-keyword">var</span> element = getActiveElement();

      <span class="hljs-keyword">while</span> (element <span class="hljs-keyword">instanceof</span> win.HTMLIFrameElement) {
        <span class="hljs-keyword">if</span> (isSameOriginFrame(element)) {
          win = element.contentWindow;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> element;
        }

        element = getActiveElement(win.document);
      }

      <span class="hljs-keyword">return</span> element;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-476" id="section-476"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-477" id="section-477"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasSelectionCapabilities</span>(<span class="hljs-params">elem</span>) </span>{
      <span class="hljs-keyword">var</span> nodeName = elem &amp;&amp; elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();
      <span class="hljs-keyword">return</span> nodeName &amp;&amp; (nodeName === <span class="hljs-string">'input'</span> &amp;&amp; (elem.type === <span class="hljs-string">'text'</span> || elem.type === <span class="hljs-string">'search'</span> || elem.type === <span class="hljs-string">'tel'</span> || elem.type === <span class="hljs-string">'url'</span> || elem.type === <span class="hljs-string">'password'</span>) || nodeName === <span class="hljs-string">'textarea'</span> || elem.contentEditable === <span class="hljs-string">'true'</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelectionInformation</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> focusedElem = getActiveElementDeep();
      <span class="hljs-keyword">return</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-478" id="section-478"></a>
</div>
<p>Used by Flare</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        activeElementDetached: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">focusedElem</span>: focusedElem,
        <span class="hljs-attr">selectionRange</span>: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : <span class="hljs-literal">null</span>
      };
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-479" id="section-479"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreSelection</span>(<span class="hljs-params">priorSelectionInformation</span>) </span>{
      <span class="hljs-keyword">var</span> curFocusedElem = getActiveElementDeep();
      <span class="hljs-keyword">var</span> priorFocusedElem = priorSelectionInformation.focusedElem;
      <span class="hljs-keyword">var</span> priorSelectionRange = priorSelectionInformation.selectionRange;

      <span class="hljs-keyword">if</span> (curFocusedElem !== priorFocusedElem &amp;&amp; isInDocument(priorFocusedElem)) {
        <span class="hljs-keyword">if</span> (priorSelectionRange !== <span class="hljs-literal">null</span> &amp;&amp; hasSelectionCapabilities(priorFocusedElem)) {
          setSelection(priorFocusedElem, priorSelectionRange);
        } <span class="hljs-comment">// Focusing a node can change the scroll position, which is undesirable</span>


        <span class="hljs-keyword">var</span> ancestors = [];
        <span class="hljs-keyword">var</span> ancestor = priorFocusedElem;

        <span class="hljs-keyword">while</span> (ancestor = ancestor.parentNode) {
          <span class="hljs-keyword">if</span> (ancestor.nodeType === ELEMENT_NODE) {
            ancestors.push({
              <span class="hljs-attr">element</span>: ancestor,
              <span class="hljs-attr">left</span>: ancestor.scrollLeft,
              <span class="hljs-attr">top</span>: ancestor.scrollTop
            });
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> priorFocusedElem.focus === <span class="hljs-string">'function'</span>) {
          priorFocusedElem.focus();
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ancestors.length; i++) {
          <span class="hljs-keyword">var</span> info = ancestors[i];
          info.element.scrollLeft = info.left;
          info.element.scrollTop = info.top;
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-480" id="section-480"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelection</span>(<span class="hljs-params">input</span>) </span>{
      <span class="hljs-keyword">var</span> selection;

      <span class="hljs-keyword">if</span> (<span class="hljs-string">'selectionStart'</span> <span class="hljs-keyword">in</span> input) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-481" id="section-481"></a>
</div>
<p>Modern browser with input or textarea.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        selection = {
          <span class="hljs-attr">start</span>: input.selectionStart,
          <span class="hljs-attr">end</span>: input.selectionEnd
        };
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-482" id="section-482"></a>
</div>
<p>Content editable or old IE textarea.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        selection = getOffsets(input);
      }

      <span class="hljs-keyword">return</span> selection || {
        <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">end</span>: <span class="hljs-number">0</span>
      };
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-483" id="section-483"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSelection</span>(<span class="hljs-params">input, offsets</span>) </span>{
      <span class="hljs-keyword">var</span> start = offsets.start,
          end = offsets.end;

      <span class="hljs-keyword">if</span> (end === <span class="hljs-literal">undefined</span>) {
        end = start;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-string">'selectionStart'</span> <span class="hljs-keyword">in</span> input) {
        input.selectionStart = start;
        input.selectionEnd = <span class="hljs-built_in">Math</span>.min(end, input.value.length);
      } <span class="hljs-keyword">else</span> {
        setOffsets(input, offsets);
      }
    }

    <span class="hljs-keyword">var</span> validateDOMNesting = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

    <span class="hljs-keyword">var</span> updatedAncestorInfo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

    {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-484" id="section-484"></a>
</div>
<p>This validation code was written based on the HTML5 parsing spec:
https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope</p>
<p>Note: this does not catch all invalid nesting, nor does it try to (as it's
not clear what practical benefit doing so provides); instead, we warn only
for cases where the parser will give a parse tree differing from what React
intended. For example, <b><div></div></b> is invalid but we don't warn
because it still parses correctly; we do warn for other cases like nested</p>
<p> tags where the beginning of the second element implicitly closes the
first, causing a confusing mess.
https://html.spec.whatwg.org/multipage/syntax.html#special

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> specialTags = [<span class="hljs-string">'address'</span>, <span class="hljs-string">'applet'</span>, <span class="hljs-string">'area'</span>, <span class="hljs-string">'article'</span>, <span class="hljs-string">'aside'</span>, <span class="hljs-string">'base'</span>, <span class="hljs-string">'basefont'</span>, <span class="hljs-string">'bgsound'</span>, <span class="hljs-string">'blockquote'</span>, <span class="hljs-string">'body'</span>, <span class="hljs-string">'br'</span>, <span class="hljs-string">'button'</span>, <span class="hljs-string">'caption'</span>, <span class="hljs-string">'center'</span>, <span class="hljs-string">'col'</span>, <span class="hljs-string">'colgroup'</span>, <span class="hljs-string">'dd'</span>, <span class="hljs-string">'details'</span>, <span class="hljs-string">'dir'</span>, <span class="hljs-string">'div'</span>, <span class="hljs-string">'dl'</span>, <span class="hljs-string">'dt'</span>, <span class="hljs-string">'embed'</span>, <span class="hljs-string">'fieldset'</span>, <span class="hljs-string">'figcaption'</span>, <span class="hljs-string">'figure'</span>, <span class="hljs-string">'footer'</span>, <span class="hljs-string">'form'</span>, <span class="hljs-string">'frame'</span>, <span class="hljs-string">'frameset'</span>, <span class="hljs-string">'h1'</span>, <span class="hljs-string">'h2'</span>, <span class="hljs-string">'h3'</span>, <span class="hljs-string">'h4'</span>, <span class="hljs-string">'h5'</span>, <span class="hljs-string">'h6'</span>, <span class="hljs-string">'head'</span>, <span class="hljs-string">'header'</span>, <span class="hljs-string">'hgroup'</span>, <span class="hljs-string">'hr'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'iframe'</span>, <span class="hljs-string">'img'</span>, <span class="hljs-string">'input'</span>, <span class="hljs-string">'isindex'</span>, <span class="hljs-string">'li'</span>, <span class="hljs-string">'link'</span>, <span class="hljs-string">'listing'</span>, <span class="hljs-string">'main'</span>, <span class="hljs-string">'marquee'</span>, <span class="hljs-string">'menu'</span>, <span class="hljs-string">'menuitem'</span>, <span class="hljs-string">'meta'</span>, <span class="hljs-string">'nav'</span>, <span class="hljs-string">'noembed'</span>, <span class="hljs-string">'noframes'</span>, <span class="hljs-string">'noscript'</span>, <span class="hljs-string">'object'</span>, <span class="hljs-string">'ol'</span>, <span class="hljs-string">'p'</span>, <span class="hljs-string">'param'</span>, <span class="hljs-string">'plaintext'</span>, <span class="hljs-string">'pre'</span>, <span class="hljs-string">'script'</span>, <span class="hljs-string">'section'</span>, <span class="hljs-string">'select'</span>, <span class="hljs-string">'source'</span>, <span class="hljs-string">'style'</span>, <span class="hljs-string">'summary'</span>, <span class="hljs-string">'table'</span>, <span class="hljs-string">'tbody'</span>, <span class="hljs-string">'td'</span>, <span class="hljs-string">'template'</span>, <span class="hljs-string">'textarea'</span>, <span class="hljs-string">'tfoot'</span>, <span class="hljs-string">'th'</span>, <span class="hljs-string">'thead'</span>, <span class="hljs-string">'title'</span>, <span class="hljs-string">'tr'</span>, <span class="hljs-string">'track'</span>, <span class="hljs-string">'ul'</span>, <span class="hljs-string">'wbr'</span>, <span class="hljs-string">'xmp'</span>]; <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope</span>

      <span class="hljs-keyword">var</span> inScopeTags = [<span class="hljs-string">'applet'</span>, <span class="hljs-string">'caption'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'table'</span>, <span class="hljs-string">'td'</span>, <span class="hljs-string">'th'</span>, <span class="hljs-string">'marquee'</span>, <span class="hljs-string">'object'</span>, <span class="hljs-string">'template'</span>, <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-485" id="section-485"></a>
</div>
<p>TODO: Distinguish by namespace here -- for <title>, including it here
errs on the side of fewer warnings</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-string">'foreignObject'</span>, <span class="hljs-string">'desc'</span>, <span class="hljs-string">'title'</span>]; <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope</span>

      <span class="hljs-keyword">var</span> buttonScopeTags = inScopeTags.concat([<span class="hljs-string">'button'</span>]); <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags</span>

      <span class="hljs-keyword">var</span> impliedEndTags = [<span class="hljs-string">'dd'</span>, <span class="hljs-string">'dt'</span>, <span class="hljs-string">'li'</span>, <span class="hljs-string">'option'</span>, <span class="hljs-string">'optgroup'</span>, <span class="hljs-string">'p'</span>, <span class="hljs-string">'rp'</span>, <span class="hljs-string">'rt'</span>];
      <span class="hljs-keyword">var</span> emptyAncestorInfo = {
        <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">formTag</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">aTagInScope</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">buttonTagInScope</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">nobrTagInScope</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">pTagInButtonScope</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">listItemTagAutoclosing</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">dlItemTagAutoclosing</span>: <span class="hljs-literal">null</span>
      };

      updatedAncestorInfo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">oldInfo, tag</span>) </span>{
        <span class="hljs-keyword">var</span> ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);

        <span class="hljs-keyword">var</span> info = {
          <span class="hljs-attr">tag</span>: tag
        };

        <span class="hljs-keyword">if</span> (inScopeTags.indexOf(tag) !== <span class="hljs-number">-1</span>) {
          ancestorInfo.aTagInScope = <span class="hljs-literal">null</span>;
          ancestorInfo.buttonTagInScope = <span class="hljs-literal">null</span>;
          ancestorInfo.nobrTagInScope = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (buttonScopeTags.indexOf(tag) !== <span class="hljs-number">-1</span>) {
          ancestorInfo.pTagInButtonScope = <span class="hljs-literal">null</span>;
        } <span class="hljs-comment">// See rules for 'li', 'dd', 'dt' start tags in</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-486" id="section-486"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (specialTags.indexOf(tag) !== <span class="hljs-number">-1</span> &amp;&amp; tag !== <span class="hljs-string">'address'</span> &amp;&amp; tag !== <span class="hljs-string">'div'</span> &amp;&amp; tag !== <span class="hljs-string">'p'</span>) {
          ancestorInfo.listItemTagAutoclosing = <span class="hljs-literal">null</span>;
          ancestorInfo.dlItemTagAutoclosing = <span class="hljs-literal">null</span>;
        }

        ancestorInfo.current = info;

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'form'</span>) {
          ancestorInfo.formTag = info;
        }

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'a'</span>) {
          ancestorInfo.aTagInScope = info;
        }

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'button'</span>) {
          ancestorInfo.buttonTagInScope = info;
        }

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'nobr'</span>) {
          ancestorInfo.nobrTagInScope = info;
        }

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'p'</span>) {
          ancestorInfo.pTagInButtonScope = info;
        }

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'li'</span>) {
          ancestorInfo.listItemTagAutoclosing = info;
        }

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">'dd'</span> || tag === <span class="hljs-string">'dt'</span>) {
          ancestorInfo.dlItemTagAutoclosing = info;
        }

        <span class="hljs-keyword">return</span> ancestorInfo;
      };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-487" id="section-487"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns whether</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> isTagValidWithParent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag, parentTag</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-488" id="section-488"></a>
</div>
<p>First, let's check if we're in an unusual parsing mode...</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">switch</span> (parentTag) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-489" id="section-489"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'option'</span> || tag === <span class="hljs-string">'optgroup'</span> || tag === <span class="hljs-string">'#text'</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'optgroup'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'option'</span> || tag === <span class="hljs-string">'#text'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-490" id="section-490"></a>
</div>
<p>Strictly speaking, seeing an <option> doesn't mean we're in a <select>
but</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> <span class="hljs-string">'option'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'#text'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-491" id="section-491"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
No special behavior since these rules fall back to &quot;in body&quot; mode for
all except special table nodes which cause bad parsing behavior anyway.
https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> <span class="hljs-string">'tr'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'th'</span> || tag === <span class="hljs-string">'td'</span> || tag === <span class="hljs-string">'style'</span> || tag === <span class="hljs-string">'script'</span> || tag === <span class="hljs-string">'template'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-492" id="section-492"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> <span class="hljs-string">'tbody'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'thead'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'tfoot'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'tr'</span> || tag === <span class="hljs-string">'style'</span> || tag === <span class="hljs-string">'script'</span> || tag === <span class="hljs-string">'template'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-493" id="section-493"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> <span class="hljs-string">'colgroup'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'col'</span> || tag === <span class="hljs-string">'template'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-494" id="section-494"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> <span class="hljs-string">'table'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'caption'</span> || tag === <span class="hljs-string">'colgroup'</span> || tag === <span class="hljs-string">'tbody'</span> || tag === <span class="hljs-string">'tfoot'</span> || tag === <span class="hljs-string">'thead'</span> || tag === <span class="hljs-string">'style'</span> || tag === <span class="hljs-string">'script'</span> || tag === <span class="hljs-string">'template'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-495" id="section-495"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> <span class="hljs-string">'head'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'base'</span> || tag === <span class="hljs-string">'basefont'</span> || tag === <span class="hljs-string">'bgsound'</span> || tag === <span class="hljs-string">'link'</span> || tag === <span class="hljs-string">'meta'</span> || tag === <span class="hljs-string">'title'</span> || tag === <span class="hljs-string">'noscript'</span> || tag === <span class="hljs-string">'noframes'</span> || tag === <span class="hljs-string">'style'</span> || tag === <span class="hljs-string">'script'</span> || tag === <span class="hljs-string">'template'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-496" id="section-496"></a>
</div>
<p>https://html.spec.whatwg.org/multipage/semantics.html#the-html-element</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> <span class="hljs-string">'html'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'head'</span> || tag === <span class="hljs-string">'body'</span> || tag === <span class="hljs-string">'frameset'</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'frameset'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'frame'</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'#document'</span>:
            <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'html'</span>;
        } <span class="hljs-comment">// Probably in the "in body" parsing mode, so we outlaw only tag combos</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-497" id="section-497"></a>
</div>
<p>where the parsing rules cause implicit opens or closes to be added.
https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">switch</span> (tag) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h1'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h2'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h3'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h4'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h5'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h6'</span>:
            <span class="hljs-keyword">return</span> parentTag !== <span class="hljs-string">'h1'</span> &amp;&amp; parentTag !== <span class="hljs-string">'h2'</span> &amp;&amp; parentTag !== <span class="hljs-string">'h3'</span> &amp;&amp; parentTag !== <span class="hljs-string">'h4'</span> &amp;&amp; parentTag !== <span class="hljs-string">'h5'</span> &amp;&amp; parentTag !== <span class="hljs-string">'h6'</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'rp'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'rt'</span>:
            <span class="hljs-keyword">return</span> impliedEndTags.indexOf(parentTag) === <span class="hljs-number">-1</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'body'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'caption'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'col'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'colgroup'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'frameset'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'frame'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'head'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'html'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'tbody'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'td'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'tfoot'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'th'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'thead'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'tr'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-498" id="section-498"></a>
</div>
<p>These tags are only valid with a few parents that have special child
parsing rules -- if we're down here, then none of those matched and
so we allow it only if we don't know what the parent is, as all other
cases are invalid.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> parentTag == <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-499" id="section-499"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns whether</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> findInvalidAncestorForTag = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag, ancestorInfo</span>) </span>{
        <span class="hljs-keyword">switch</span> (tag) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'address'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'article'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'aside'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'blockquote'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'center'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'details'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'dialog'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'dir'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'div'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'dl'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'fieldset'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'figcaption'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'figure'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'footer'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'header'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'hgroup'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'main'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'menu'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'nav'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'ol'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'p'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'section'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'summary'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'ul'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'pre'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'listing'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'table'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'hr'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'xmp'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h1'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h2'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h3'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h4'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h5'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'h6'</span>:
            <span class="hljs-keyword">return</span> ancestorInfo.pTagInButtonScope;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'form'</span>:
            <span class="hljs-keyword">return</span> ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'li'</span>:
            <span class="hljs-keyword">return</span> ancestorInfo.listItemTagAutoclosing;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'dd'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'dt'</span>:
            <span class="hljs-keyword">return</span> ancestorInfo.dlItemTagAutoclosing;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'button'</span>:
            <span class="hljs-keyword">return</span> ancestorInfo.buttonTagInScope;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'a'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-500" id="section-500"></a>
</div>
<p>Spec says something about storing a list of markers, but it sounds
equivalent to this check.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> ancestorInfo.aTagInScope;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'nobr'</span>:
            <span class="hljs-keyword">return</span> ancestorInfo.nobrTagInScope;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      };

      <span class="hljs-keyword">var</span> didWarn$<span class="hljs-number">1</span> = {};

      validateDOMNesting = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">childTag, childText, ancestorInfo</span>) </span>{
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        <span class="hljs-keyword">var</span> parentInfo = ancestorInfo.current;
        <span class="hljs-keyword">var</span> parentTag = parentInfo &amp;&amp; parentInfo.tag;

        <span class="hljs-keyword">if</span> (childText != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (childTag != <span class="hljs-literal">null</span>) {
            error(<span class="hljs-string">'validateDOMNesting: when childText is passed, childTag should be null'</span>);
          }

          childTag = <span class="hljs-string">'#text'</span>;
        }

        <span class="hljs-keyword">var</span> invalidParent = isTagValidWithParent(childTag, parentTag) ? <span class="hljs-literal">null</span> : parentInfo;
        <span class="hljs-keyword">var</span> invalidAncestor = invalidParent ? <span class="hljs-literal">null</span> : findInvalidAncestorForTag(childTag, ancestorInfo);
        <span class="hljs-keyword">var</span> invalidParentOrAncestor = invalidParent || invalidAncestor;

        <span class="hljs-keyword">if</span> (!invalidParentOrAncestor) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> ancestorTag = invalidParentOrAncestor.tag;
        <span class="hljs-keyword">var</span> addendum = getCurrentFiberStackInDev();
        <span class="hljs-keyword">var</span> warnKey = !!invalidParent + <span class="hljs-string">'|'</span> + childTag + <span class="hljs-string">'|'</span> + ancestorTag + <span class="hljs-string">'|'</span> + addendum;

        <span class="hljs-keyword">if</span> (didWarn$<span class="hljs-number">1</span>[warnKey]) {
          <span class="hljs-keyword">return</span>;
        }

        didWarn$<span class="hljs-number">1</span>[warnKey] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> tagDisplayName = childTag;
        <span class="hljs-keyword">var</span> whitespaceInfo = <span class="hljs-string">''</span>;

        <span class="hljs-keyword">if</span> (childTag === <span class="hljs-string">'#text'</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\S/</span>.test(childText)) {
            tagDisplayName = <span class="hljs-string">'Text nodes'</span>;
          } <span class="hljs-keyword">else</span> {
            tagDisplayName = <span class="hljs-string">'Whitespace text nodes'</span>;
            whitespaceInfo = <span class="hljs-string">" Make sure you don't have any extra whitespace between tags on "</span> + <span class="hljs-string">'each line of your source code.'</span>;
          }
        } <span class="hljs-keyword">else</span> {
          tagDisplayName = <span class="hljs-string">'&lt;'</span> + childTag + <span class="hljs-string">'&gt;'</span>;
        }

        <span class="hljs-keyword">if</span> (invalidParent) {
          <span class="hljs-keyword">var</span> info = <span class="hljs-string">''</span>;

          <span class="hljs-keyword">if</span> (ancestorTag === <span class="hljs-string">'table'</span> &amp;&amp; childTag === <span class="hljs-string">'tr'</span>) {
            info += <span class="hljs-string">' Add a &lt;tbody&gt;, &lt;thead&gt; or &lt;tfoot&gt; to your code to match the DOM tree generated by '</span> + <span class="hljs-string">'the browser.'</span>;
          }

          error(<span class="hljs-string">'validateDOMNesting(...): %s cannot appear as a child of &lt;%s&gt;.%s%s'</span>, tagDisplayName, ancestorTag, whitespaceInfo, info);
        } <span class="hljs-keyword">else</span> {
          error(<span class="hljs-string">'validateDOMNesting(...): %s cannot appear as a descendant of '</span> + <span class="hljs-string">'&lt;%s&gt;.'</span>, tagDisplayName, ancestorTag);
        }
      };
    }
    <span class="hljs-keyword">var</span> SUPPRESS_HYDRATION_WARNING$<span class="hljs-number">1</span>;
    {
      SUPPRESS_HYDRATION_WARNING$<span class="hljs-number">1</span> = <span class="hljs-string">'suppressHydrationWarning'</span>;
    }
    <span class="hljs-keyword">var</span> SUSPENSE_START_DATA = <span class="hljs-string">'$'</span>;
    <span class="hljs-keyword">var</span> SUSPENSE_END_DATA = <span class="hljs-string">'/$'</span>;
    <span class="hljs-keyword">var</span> SUSPENSE_PENDING_START_DATA = <span class="hljs-string">'$?'</span>;
    <span class="hljs-keyword">var</span> SUSPENSE_FALLBACK_START_DATA = <span class="hljs-string">'$!'</span>;
    <span class="hljs-keyword">var</span> STYLE$<span class="hljs-number">1</span> = <span class="hljs-string">'style'</span>;
    <span class="hljs-keyword">var</span> eventsEnabled = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> selectionInformation = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldAutoFocusHostComponent</span>(<span class="hljs-params">type, props</span>) </span>{
      <span class="hljs-keyword">switch</span> (type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'button'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'input'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'select'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'textarea'</span>:
          <span class="hljs-keyword">return</span> !!props.autoFocus;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRootHostContext</span>(<span class="hljs-params">rootContainerInstance</span>) </span>{
      <span class="hljs-keyword">var</span> type;
      <span class="hljs-keyword">var</span> namespace;
      <span class="hljs-keyword">var</span> nodeType = rootContainerInstance.nodeType;

      <span class="hljs-keyword">switch</span> (nodeType) {
        <span class="hljs-keyword">case</span> DOCUMENT_NODE:
        <span class="hljs-keyword">case</span> DOCUMENT_FRAGMENT_NODE:
          {
            type = nodeType === DOCUMENT_NODE ? <span class="hljs-string">'#document'</span> : <span class="hljs-string">'#fragment'</span>;
            <span class="hljs-keyword">var</span> root = rootContainerInstance.documentElement;
            namespace = root ? root.namespaceURI : getChildNamespace(<span class="hljs-literal">null</span>, <span class="hljs-string">''</span>);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-attr">default</span>:
          {
            <span class="hljs-keyword">var</span> container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
            <span class="hljs-keyword">var</span> ownNamespace = container.namespaceURI || <span class="hljs-literal">null</span>;
            type = container.tagName;
            namespace = getChildNamespace(ownNamespace, type);
            <span class="hljs-keyword">break</span>;
          }
      }

      {
        <span class="hljs-keyword">var</span> validatedTag = type.toLowerCase();
        <span class="hljs-keyword">var</span> ancestorInfo = updatedAncestorInfo(<span class="hljs-literal">null</span>, validatedTag);
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">namespace</span>: namespace,
          <span class="hljs-attr">ancestorInfo</span>: ancestorInfo
        };
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildHostContext</span>(<span class="hljs-params">parentHostContext, type, rootContainerInstance</span>) </span>{
      {
        <span class="hljs-keyword">var</span> parentHostContextDev = parentHostContext;
        <span class="hljs-keyword">var</span> namespace = getChildNamespace(parentHostContextDev.namespace, type);
        <span class="hljs-keyword">var</span> ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">namespace</span>: namespace,
          <span class="hljs-attr">ancestorInfo</span>: ancestorInfo
        };
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPublicInstance</span>(<span class="hljs-params">instance</span>) </span>{
      <span class="hljs-keyword">return</span> instance;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareForCommit</span>(<span class="hljs-params">containerInfo</span>) </span>{
      eventsEnabled = isEnabled();
      selectionInformation = getSelectionInformation();
      setEnabled(<span class="hljs-literal">false</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetAfterCommit</span>(<span class="hljs-params">containerInfo</span>) </span>{
      restoreSelection(selectionInformation);
      setEnabled(eventsEnabled);
      eventsEnabled = <span class="hljs-literal">null</span>;
      selectionInformation = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInstance</span>(<span class="hljs-params">type, props, rootContainerInstance, hostContext, internalInstanceHandle</span>) </span>{
      <span class="hljs-keyword">var</span> parentNamespace;
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-501" id="section-501"></a>
</div>
<p>TODO: take namespace into account when validating.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> hostContextDev = hostContext;
        validateDOMNesting(type, <span class="hljs-literal">null</span>, hostContextDev.ancestorInfo);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">'number'</span>) {
          <span class="hljs-keyword">var</span> string = <span class="hljs-string">''</span> + props.children;
          <span class="hljs-keyword">var</span> ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
          validateDOMNesting(<span class="hljs-literal">null</span>, string, ownAncestorInfo);
        }

        parentNamespace = hostContextDev.namespace;
      }
      <span class="hljs-keyword">var</span> domElement = createElement(type, props, rootContainerInstance, parentNamespace);
      precacheFiberNode(internalInstanceHandle, domElement);
      updateFiberProps(domElement, props);
      <span class="hljs-keyword">return</span> domElement;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendInitialChild</span>(<span class="hljs-params">parentInstance, child</span>) </span>{
      parentInstance.appendChild(child);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finalizeInitialChildren</span>(<span class="hljs-params">domElement, type, props, rootContainerInstance, hostContext</span>) </span>{
      setInitialProperties(domElement, type, props, rootContainerInstance);
      <span class="hljs-keyword">return</span> shouldAutoFocusHostComponent(type, props);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareUpdate</span>(<span class="hljs-params">domElement, type, oldProps, newProps, rootContainerInstance, hostContext</span>) </span>{
      {
        <span class="hljs-keyword">var</span> hostContextDev = hostContext;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newProps.children !== <span class="hljs-keyword">typeof</span> oldProps.children &amp;&amp; (<span class="hljs-keyword">typeof</span> newProps.children === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newProps.children === <span class="hljs-string">'number'</span>)) {
          <span class="hljs-keyword">var</span> string = <span class="hljs-string">''</span> + newProps.children;
          <span class="hljs-keyword">var</span> ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
          validateDOMNesting(<span class="hljs-literal">null</span>, string, ownAncestorInfo);
        }
      }
      <span class="hljs-keyword">return</span> diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldSetTextContent</span>(<span class="hljs-params">type, props</span>) </span>{
      <span class="hljs-keyword">return</span> type === <span class="hljs-string">'textarea'</span> || type === <span class="hljs-string">'option'</span> || type === <span class="hljs-string">'noscript'</span> || <span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> props.children === <span class="hljs-string">'number'</span> || <span class="hljs-keyword">typeof</span> props.dangerouslySetInnerHTML === <span class="hljs-string">'object'</span> &amp;&amp; props.dangerouslySetInnerHTML !== <span class="hljs-literal">null</span> &amp;&amp; props.dangerouslySetInnerHTML.__html != <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldDeprioritizeSubtree</span>(<span class="hljs-params">type, props</span>) </span>{
      <span class="hljs-keyword">return</span> !!props.hidden;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTextInstance</span>(<span class="hljs-params">text, rootContainerInstance, hostContext, internalInstanceHandle</span>) </span>{
      {
        <span class="hljs-keyword">var</span> hostContextDev = hostContext;
        validateDOMNesting(<span class="hljs-literal">null</span>, text, hostContextDev.ancestorInfo);
      }
      <span class="hljs-keyword">var</span> textNode = createTextNode(text, rootContainerInstance);
      precacheFiberNode(internalInstanceHandle, textNode);
      <span class="hljs-keyword">return</span> textNode;
    } <span class="hljs-comment">// if a component just imports ReactDOM (e.g. for findDOMNode).</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-502" id="section-502"></a>
</div>
<p>Some environments might not have setTimeout or clearTimeout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> scheduleTimeout = <span class="hljs-keyword">typeof</span> setTimeout === <span class="hljs-string">'function'</span> ? setTimeout : <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">var</span> cancelTimeout = <span class="hljs-keyword">typeof</span> clearTimeout === <span class="hljs-string">'function'</span> ? clearTimeout : <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">var</span> noTimeout = <span class="hljs-number">-1</span>; <span class="hljs-comment">// -------------------</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMount</span>(<span class="hljs-params">domElement, type, newProps, internalInstanceHandle</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-503" id="section-503"></a>
</div>
<p>Despite the naming that might imply otherwise, this method only
fires if there is an <code>Update</code> effect scheduled during mounting.
This happens if <code>finalizeInitialChildren</code> returns <code>true</code> (which it
does to implement the <code>autoFocus</code> attribute on the client). But
there are also other cases when this might happen (such as patching
up text content during hydration mismatch). So we'll check this again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (shouldAutoFocusHostComponent(type, newProps)) {
        domElement.focus();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitUpdate</span>(<span class="hljs-params">domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-504" id="section-504"></a>
</div>
<p>Update the props handle so that we know which props are the ones with
with current event handlers.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      updateFiberProps(domElement, newProps); <span class="hljs-comment">// Apply the diff to the DOM node.</span>

      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetTextContent</span>(<span class="hljs-params">domElement</span>) </span>{
      setTextContent(domElement, <span class="hljs-string">''</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitTextUpdate</span>(<span class="hljs-params">textInstance, oldText, newText</span>) </span>{
      textInstance.nodeValue = newText;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendChild</span>(<span class="hljs-params">parentInstance, child</span>) </span>{
      parentInstance.appendChild(child);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendChildToContainer</span>(<span class="hljs-params">container, child</span>) </span>{
      <span class="hljs-keyword">var</span> parentNode;

      <span class="hljs-keyword">if</span> (container.nodeType === COMMENT_NODE) {
        parentNode = container.parentNode;
        parentNode.insertBefore(child, container);
      } <span class="hljs-keyword">else</span> {
        parentNode = container;
        parentNode.appendChild(child);
      } <span class="hljs-comment">// This container might be used for a portal.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-505" id="section-505"></a>
</div>
<p>If something inside a portal is clicked, that click should bubble
through the React tree. However, on Mobile Safari the click would
never bubble through the <em>DOM</em> tree unless an ancestor with onclick
event exists. So we wouldn't see it and dispatch it.
This is why we ensure that non React root containers have inline onclick
defined.
https://github.com/facebook/react/issues/11918</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> reactRootContainer = container._reactRootContainer;

      <span class="hljs-keyword">if</span> ((reactRootContainer === <span class="hljs-literal">null</span> || reactRootContainer === <span class="hljs-literal">undefined</span>) &amp;&amp; parentNode.onclick === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-506" id="section-506"></a>
</div>
<p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        trapClickOnNonInteractiveElement(parentNode);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertBefore</span>(<span class="hljs-params">parentInstance, child, beforeChild</span>) </span>{
      parentInstance.insertBefore(child, beforeChild);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertInContainerBefore</span>(<span class="hljs-params">container, child, beforeChild</span>) </span>{
      <span class="hljs-keyword">if</span> (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } <span class="hljs-keyword">else</span> {
        container.insertBefore(child, beforeChild);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeChild</span>(<span class="hljs-params">parentInstance, child</span>) </span>{
      parentInstance.removeChild(child);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeChildFromContainer</span>(<span class="hljs-params">container, child</span>) </span>{
      <span class="hljs-keyword">if</span> (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } <span class="hljs-keyword">else</span> {
        container.removeChild(child);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideInstance</span>(<span class="hljs-params">instance</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-507" id="section-507"></a>
</div>
<p>pass host context to this method?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      instance = instance;
      <span class="hljs-keyword">var</span> style = instance.style;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> style.setProperty === <span class="hljs-string">'function'</span>) {
        style.setProperty(<span class="hljs-string">'display'</span>, <span class="hljs-string">'none'</span>, <span class="hljs-string">'important'</span>);
      } <span class="hljs-keyword">else</span> {
        style.display = <span class="hljs-string">'none'</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideTextInstance</span>(<span class="hljs-params">textInstance</span>) </span>{
      textInstance.nodeValue = <span class="hljs-string">''</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unhideInstance</span>(<span class="hljs-params">instance, props</span>) </span>{
      instance = instance;
      <span class="hljs-keyword">var</span> styleProp = props[STYLE$<span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> display = styleProp !== <span class="hljs-literal">undefined</span> &amp;&amp; styleProp !== <span class="hljs-literal">null</span> &amp;&amp; styleProp.hasOwnProperty(<span class="hljs-string">'display'</span>) ? styleProp.display : <span class="hljs-literal">null</span>;
      instance.style.display = dangerousStyleValue(<span class="hljs-string">'display'</span>, display);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unhideTextInstance</span>(<span class="hljs-params">textInstance, text</span>) </span>{
      textInstance.nodeValue = text;
    } <span class="hljs-comment">// -------------------</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canHydrateInstance</span>(<span class="hljs-params">instance, type, props</span>) </span>{
      <span class="hljs-keyword">if</span> (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// This has now been refined to an element node.</span>


      <span class="hljs-keyword">return</span> instance;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canHydrateTextInstance</span>(<span class="hljs-params">instance, text</span>) </span>{
      <span class="hljs-keyword">if</span> (text === <span class="hljs-string">''</span> || instance.nodeType !== TEXT_NODE) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-508" id="section-508"></a>
</div>
<p>Empty strings are not parsed by HTML so there won't be a correct match here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// This has now been refined to a text node.</span>


      <span class="hljs-keyword">return</span> instance;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSuspenseInstancePending</span>(<span class="hljs-params">instance</span>) </span>{
      <span class="hljs-keyword">return</span> instance.data === SUSPENSE_PENDING_START_DATA;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSuspenseInstanceFallback</span>(<span class="hljs-params">instance</span>) </span>{
      <span class="hljs-keyword">return</span> instance.data === SUSPENSE_FALLBACK_START_DATA;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextHydratable</span>(<span class="hljs-params">node</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-509" id="section-509"></a>
</div>
<p>Skip non-hydratable nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">for</span> (; node != <span class="hljs-literal">null</span>; node = node.nextSibling) {
        <span class="hljs-keyword">var</span> nodeType = node.nodeType;

        <span class="hljs-keyword">if</span> (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextHydratableSibling</span>(<span class="hljs-params">instance</span>) </span>{
      <span class="hljs-keyword">return</span> getNextHydratable(instance.nextSibling);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirstHydratableChild</span>(<span class="hljs-params">parentInstance</span>) </span>{
      <span class="hljs-keyword">return</span> getNextHydratable(parentInstance.firstChild);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrateInstance</span>(<span class="hljs-params">instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle</span>) </span>{
      precacheFiberNode(internalInstanceHandle, instance); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Possibly defer this until the commit phase where all the events</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-510" id="section-510"></a>
</div>
<p>get attached.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      updateFiberProps(instance, props);
      <span class="hljs-keyword">var</span> parentNamespace;
      {
        <span class="hljs-keyword">var</span> hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      <span class="hljs-keyword">return</span> diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrateTextInstance</span>(<span class="hljs-params">textInstance, text, internalInstanceHandle</span>) </span>{
      precacheFiberNode(internalInstanceHandle, textInstance);
      <span class="hljs-keyword">return</span> diffHydratedText(textInstance, text);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextHydratableInstanceAfterSuspenseInstance</span>(<span class="hljs-params">suspenseInstance</span>) </span>{
      <span class="hljs-keyword">var</span> node = suspenseInstance.nextSibling; <span class="hljs-comment">// Skip past all nodes within this suspense boundary.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-511" id="section-511"></a>
</div>
<p>There might be nested nodes so we need to keep track of how
deep we are and only break out when we're back on top.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> depth = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">while</span> (node) {
        <span class="hljs-keyword">if</span> (node.nodeType === COMMENT_NODE) {
          <span class="hljs-keyword">var</span> data = node.data;

          <span class="hljs-keyword">if</span> (data === SUSPENSE_END_DATA) {
            <span class="hljs-keyword">if</span> (depth === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> getNextHydratableSibling(node);
            } <span class="hljs-keyword">else</span> {
              depth--;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
            depth++;
          }
        }

        node = node.nextSibling;
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Warn, we didn't find the end comment boundary.</span>


      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// Returns the SuspenseInstance if this node is a direct child of a</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-512" id="section-512"></a>
</div>
<p>SuspenseInstance. I.e. if its previous sibling is a Comment with
SUSPENSE_x_START_DATA. Otherwise, null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParentSuspenseInstance</span>(<span class="hljs-params">targetInstance</span>) </span>{
      <span class="hljs-keyword">var</span> node = targetInstance.previousSibling; <span class="hljs-comment">// Skip past all nodes within this suspense boundary.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-513" id="section-513"></a>
</div>
<p>There might be nested nodes so we need to keep track of how
deep we are and only break out when we're back on top.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> depth = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">while</span> (node) {
        <span class="hljs-keyword">if</span> (node.nodeType === COMMENT_NODE) {
          <span class="hljs-keyword">var</span> data = node.data;

          <span class="hljs-keyword">if</span> (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
            <span class="hljs-keyword">if</span> (depth === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> node;
            } <span class="hljs-keyword">else</span> {
              depth--;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === SUSPENSE_END_DATA) {
            depth++;
          }
        }

        node = node.previousSibling;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitHydratedContainer</span>(<span class="hljs-params">container</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-514" id="section-514"></a>
</div>
<p>Retry if any event replaying was blocked on this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      retryIfBlockedOn(container);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitHydratedSuspenseInstance</span>(<span class="hljs-params">suspenseInstance</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-515" id="section-515"></a>
</div>
<p>Retry if any event replaying was blocked on this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      retryIfBlockedOn(suspenseInstance);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotMatchHydratedContainerTextInstance</span>(<span class="hljs-params">parentContainer, textInstance, text</span>) </span>{
      {
        warnForUnmatchedText(textInstance, text);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotMatchHydratedTextInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, textInstance, text</span>) </span>{
      <span class="hljs-keyword">if</span> (parentProps[SUPPRESS_HYDRATION_WARNING$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
        warnForUnmatchedText(textInstance, text);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotHydrateContainerInstance</span>(<span class="hljs-params">parentContainer, instance</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (instance.nodeType === ELEMENT_NODE) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instance.nodeType === COMMENT_NODE) ;<span class="hljs-keyword">else</span> {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotHydrateInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, instance</span>) </span>{
      <span class="hljs-keyword">if</span> (parentProps[SUPPRESS_HYDRATION_WARNING$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (instance.nodeType === ELEMENT_NODE) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instance.nodeType === COMMENT_NODE) ;<span class="hljs-keyword">else</span> {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotFindHydratableContainerInstance</span>(<span class="hljs-params">parentContainer, type, props</span>) </span>{
      {
        warnForInsertedHydratedElement(parentContainer, type);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotFindHydratableContainerTextInstance</span>(<span class="hljs-params">parentContainer, text</span>) </span>{
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotFindHydratableInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, type, props</span>) </span>{
      <span class="hljs-keyword">if</span> (parentProps[SUPPRESS_HYDRATION_WARNING$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
        warnForInsertedHydratedElement(parentInstance, type);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotFindHydratableTextInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, text</span>) </span>{
      <span class="hljs-keyword">if</span> (parentProps[SUPPRESS_HYDRATION_WARNING$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">didNotFindHydratableSuspenseInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance</span>) </span>{
      <span class="hljs-keyword">if</span> (parentProps[SUPPRESS_HYDRATION_WARNING$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) ;
    }

    <span class="hljs-keyword">var</span> randomKey = <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).slice(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">var</span> internalInstanceKey = <span class="hljs-string">'__reactInternalInstance$'</span> + randomKey;
    <span class="hljs-keyword">var</span> internalEventHandlersKey = <span class="hljs-string">'__reactEventHandlers$'</span> + randomKey;
    <span class="hljs-keyword">var</span> internalContainerInstanceKey = <span class="hljs-string">'__reactContainere$'</span> + randomKey;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">precacheFiberNode</span>(<span class="hljs-params">hostInst, node</span>) </span>{
      node[internalInstanceKey] = hostInst;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markContainerAsRoot</span>(<span class="hljs-params">hostRoot, node</span>) </span>{
      node[internalContainerInstanceKey] = hostRoot;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmarkContainerAsRoot</span>(<span class="hljs-params">node</span>) </span>{
      node[internalContainerInstanceKey] = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isContainerMarkedAsRoot</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> !!node[internalContainerInstanceKey];
    } <span class="hljs-comment">// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-516" id="section-516"></a>
</div>
<p>If the target node is part of a hydrated or not yet rendered subtree, then
this may also return a SuspenseComponent or HostRoot to indicate that.
Conceptually the HostRoot fiber is a child of the Container node. So if you
pass the Container node as the targetNode, you will not actually get the
HostRoot back. To get to the HostRoot, you need to pass a child of it.
The same thing applies to Suspense boundaries.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getClosestInstanceFromNode</span>(<span class="hljs-params">targetNode</span>) </span>{
      <span class="hljs-keyword">var</span> targetInst = targetNode[internalInstanceKey];

      <span class="hljs-keyword">if</span> (targetInst) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-517" id="section-517"></a>
</div>
<p>Don't return HostRoot or SuspenseComponent here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> targetInst;
      } <span class="hljs-comment">// If the direct event target isn't a React owned DOM node, we need to look</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-518" id="section-518"></a>
</div>
<p>to see if one of its parents is a React owned DOM node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> parentNode = targetNode.parentNode;

      <span class="hljs-keyword">while</span> (parentNode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-519" id="section-519"></a>
</div>
<p>We'll check if this is a container root that could include
React nodes in the future. We need to check this first because
if we're a child of a dehydrated container, we need to first
find that inner container before moving on to finding the parent
instance. Note that we don't check this field on  the targetNode
itself because the fibers are conceptually between the container
node and the first child. It isn't surrounding the container node.
If it's not a container, we check if it's an instance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];

        <span class="hljs-keyword">if</span> (targetInst) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-520" id="section-520"></a>
</div>
<p>Since this wasn't the direct target of the event, we might have
stepped past dehydrated DOM nodes to get here. However they could
also have been non-React nodes. We need to answer which one.
If we the instance doesn't have any children, then there can't be
a nested suspense boundary within it. So we can use this as a fast
bailout. Most of the time, when people add non-React children to
the tree, it is using a ref to a child-less DOM node.
Normally we'd only need to check one of the fibers because if it
has ever gone from having children to deleting them or vice versa
it would have deleted the dehydrated boundary nested inside already.
However, since the HostRoot starts out with an alternate it might
have one on the alternate so we need to check in case this was a
root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> alternate = targetInst.alternate;

          <span class="hljs-keyword">if</span> (targetInst.child !== <span class="hljs-literal">null</span> || alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.child !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-521" id="section-521"></a>
</div>
<p>Next we need to figure out if the node that skipped past is
nested within a dehydrated boundary and if so, which one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> suspenseInstance = getParentSuspenseInstance(targetNode);

            <span class="hljs-keyword">while</span> (suspenseInstance !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-522" id="section-522"></a>
</div>
<p>We found a suspense instance. That means that we haven't
hydrated it yet. Even though we leave the comments in the
DOM after hydrating, and there are boundaries in the DOM
that could already be hydrated, we wouldn't have found them
through this pass since if the target is hydrated it would
have had an internalInstanceKey on it.
Let's get the fiber associated with the SuspenseComponent
as the deepest instance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> targetSuspenseInst = suspenseInstance[internalInstanceKey];

              <span class="hljs-keyword">if</span> (targetSuspenseInst) {
                <span class="hljs-keyword">return</span> targetSuspenseInst;
              } <span class="hljs-comment">// If we don't find a Fiber on the comment, it might be because</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-523" id="section-523"></a>
</div>
<p>we haven't gotten to hydrate it yet. There might still be a
parent boundary that hasn't above this one so we need to find
the outer most that is known.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

              suspenseInstance = getParentSuspenseInstance(suspenseInstance); <span class="hljs-comment">// If we don't find one, then that should mean that the parent</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-524" id="section-524"></a>
</div>
<p>host component also hasn't hydrated yet. We can return it
below since it will bail out on the isMounted check later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            }
          }

          <span class="hljs-keyword">return</span> targetInst;
        }

        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-525" id="section-525"></a>
</div>
<div class="dox">
<div class="summary">
<p>Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
instance, or null if the node was not rendered by this React.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInstanceFromNode$1</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> inst = node[internalInstanceKey] || node[internalContainerInstanceKey];

      <span class="hljs-keyword">if</span> (inst) {
        <span class="hljs-keyword">if</span> (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
          <span class="hljs-keyword">return</span> inst;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-526" id="section-526"></a>
</div>
<div class="dox">
<div class="summary">
<p>Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
DOM node.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeFromInstance$1</span>(<span class="hljs-params">inst</span>) </span>{
      <span class="hljs-keyword">if</span> (inst.tag === HostComponent || inst.tag === HostText) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-527" id="section-527"></a>
</div>
<p>In Fiber this, is just the state node right now. We assume it will be
a host component or host text.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> inst.stateNode;
      } <span class="hljs-comment">// Without this first invariant, passing a non-DOM-component triggers the next</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-528" id="section-528"></a>
</div>
<p>invariant for a missing parent, which is super confusing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"getNodeFromInstance: Invalid argument."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFiberCurrentPropsFromNode$1</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node[internalEventHandlersKey] || <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFiberProps</span>(<span class="hljs-params">node, props</span>) </span>{
      node[internalEventHandlersKey] = props;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParent</span>(<span class="hljs-params">inst</span>) </span>{
      <span class="hljs-keyword">do</span> {
        inst = inst.return; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If this is a HostRoot we might want to bail out.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-529" id="section-529"></a>
</div>
<p>That is depending on if we want nested subtrees (layers) to bubble
events to their parent. We could also go through parentNode on the
host node but that wouldn't work for React Native and doesn't let us
do the portal feature.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      } <span class="hljs-keyword">while</span> (inst &amp;&amp; inst.tag !== HostComponent);

      <span class="hljs-keyword">if</span> (inst) {
        <span class="hljs-keyword">return</span> inst;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-530" id="section-530"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return the lowest common ancestor of A and B, or null if they are in
different trees.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLowestCommonAncestor</span>(<span class="hljs-params">instA, instB</span>) </span>{
      <span class="hljs-keyword">var</span> depthA = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> tempA = instA; tempA; tempA = getParent(tempA)) {
        depthA++;
      }

      <span class="hljs-keyword">var</span> depthB = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> tempB = instB; tempB; tempB = getParent(tempB)) {
        depthB++;
      } <span class="hljs-comment">// If A is deeper, crawl up.</span>


      <span class="hljs-keyword">while</span> (depthA - depthB &gt; <span class="hljs-number">0</span>) {
        instA = getParent(instA);
        depthA--;
      } <span class="hljs-comment">// If B is deeper, crawl up.</span>


      <span class="hljs-keyword">while</span> (depthB - depthA &gt; <span class="hljs-number">0</span>) {
        instB = getParent(instB);
        depthB--;
      } <span class="hljs-comment">// Walk in lockstep until we find a match.</span>


      <span class="hljs-keyword">var</span> depth = depthA;

      <span class="hljs-keyword">while</span> (depth--) {
        <span class="hljs-keyword">if</span> (instA === instB || instA === instB.alternate) {
          <span class="hljs-keyword">return</span> instA;
        }

        instA = getParent(instA);
        instB = getParent(instB);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-531" id="section-531"></a>
</div>
<div class="dox">
<div class="summary">
<p>Simulates the traversal of a two-phase, capture/bubble event dispatch.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseTwoPhase</span>(<span class="hljs-params">inst, fn, arg</span>) </span>{
      <span class="hljs-keyword">var</span> path = [];

      <span class="hljs-keyword">while</span> (inst) {
        path.push(inst);
        inst = getParent(inst);
      }

      <span class="hljs-keyword">var</span> i;

      <span class="hljs-keyword">for</span> (i = path.length; i-- &gt; <span class="hljs-number">0</span>;) {
        fn(path[i], <span class="hljs-string">'captured'</span>, arg);
      }

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; path.length; i++) {
        fn(path[i], <span class="hljs-string">'bubbled'</span>, arg);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-532" id="section-532"></a>
</div>
<div class="dox">
<div class="summary">
<p>Traverses the ID hierarchy and invokes the supplied <code>cb</code> on any IDs that
should would receive a <code>mouseEnter</code> or <code>mouseLeave</code> event.</p>
</div>
<div class="body">
<p>Does not invoke the callback on the nearest common ancestor because nothing
&quot;entered&quot; or &quot;left&quot; that element.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseEnterLeave</span>(<span class="hljs-params">from, to, fn, argFrom, argTo</span>) </span>{
      <span class="hljs-keyword">var</span> common = <span class="hljs-keyword">from</span> &amp;&amp; to ? getLowestCommonAncestor(<span class="hljs-keyword">from</span>, to) : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> pathFrom = [];

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>) {
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> === common) {
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> alternate = <span class="hljs-keyword">from</span>.alternate;

        <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate === common) {
          <span class="hljs-keyword">break</span>;
        }

        pathFrom.push(<span class="hljs-keyword">from</span>);
        <span class="hljs-keyword">from</span> = getParent(<span class="hljs-keyword">from</span>);
      }

      <span class="hljs-keyword">var</span> pathTo = [];

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (!to) {
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (to === common) {
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> _alternate = to.alternate;

        <span class="hljs-keyword">if</span> (_alternate !== <span class="hljs-literal">null</span> &amp;&amp; _alternate === common) {
          <span class="hljs-keyword">break</span>;
        }

        pathTo.push(to);
        to = getParent(to);
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pathFrom.length; i++) {
        fn(pathFrom[i], <span class="hljs-string">'bubbled'</span>, argFrom);
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = pathTo.length; _i-- &gt; <span class="hljs-number">0</span>;) {
        fn(pathTo[_i], <span class="hljs-string">'captured'</span>, argTo);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInteractive</span>(<span class="hljs-params">tag</span>) </span>{
      <span class="hljs-keyword">return</span> tag === <span class="hljs-string">'button'</span> || tag === <span class="hljs-string">'input'</span> || tag === <span class="hljs-string">'select'</span> || tag === <span class="hljs-string">'textarea'</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldPreventMouseEvent</span>(<span class="hljs-params">name, type, props</span>) </span>{
      <span class="hljs-keyword">switch</span> (name) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onClick'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onClickCapture'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onDoubleClick'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onDoubleClickCapture'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onMouseDown'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onMouseDownCapture'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onMouseMove'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onMouseMoveCapture'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onMouseUp'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onMouseUpCapture'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'onMouseEnter'</span>:
          <span class="hljs-keyword">return</span> !!(props.disabled &amp;&amp; isInteractive(type));

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-533" id="section-533"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">inst</span>
<span class="dox_type">object</span>
<span>The instance, which is the source of events.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">registrationName</span>
<span class="dox_type">string</span>
<span>Name of listener (e.g. <code>onClick</code>).
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">function</span>
<span>The stored callback.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListener</span>(<span class="hljs-params">inst, registrationName</span>) </span>{
      <span class="hljs-keyword">var</span> listener; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> shouldPreventMouseEvent is DOM-specific and definitely should not</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-534" id="section-534"></a>
</div>
<p>live here; needs to be moved to a better place soon</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> stateNode = inst.stateNode;

      <span class="hljs-keyword">if</span> (!stateNode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-535" id="section-535"></a>
</div>
<p>Work in progress (ex: onload events in incremental mode).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> props = getFiberCurrentPropsFromNode(stateNode);

      <span class="hljs-keyword">if</span> (!props) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-536" id="section-536"></a>
</div>
<p>Work in progress.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      listener = props[registrationName];

      <span class="hljs-keyword">if</span> (shouldPreventMouseEvent(registrationName, inst.type, props)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (!(!listener || <span class="hljs-keyword">typeof</span> listener === <span class="hljs-string">'function'</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected `"</span> + registrationName + <span class="hljs-string">"` listener to be a function, instead got a value of `"</span> + <span class="hljs-keyword">typeof</span> listener + <span class="hljs-string">"` type."</span>);
        }
      }

      <span class="hljs-keyword">return</span> listener;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-537" id="section-537"></a>
</div>
<div class="dox">
<div class="summary">
<p>Some event types have a notion of different registration names for different
&quot;phases&quot; of propagation. This finds listeners by a given phase.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listenerAtPhase</span>(<span class="hljs-params">inst, event, propagationPhase</span>) </span>{
      <span class="hljs-keyword">var</span> registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      <span class="hljs-keyword">return</span> getListener(inst, registrationName);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-538" id="section-538"></a>
</div>
<div class="dox">
<div class="summary">
<p>A small set of propagation patterns, each of which will accept a small amount
of information, and generate a set of &quot;dispatch ready event objects&quot; - which
are sets of events that have already been annotated with a set of dispatched
listener functions/ids. The API is designed this way to discourage these
propagation strategies from actually executing the dispatches, since we
always want to collect the entire set of dispatches before executing even a
single one.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-539" id="section-539"></a>
</div>
<div class="dox">
<div class="summary">
<p>Tags a <code>SyntheticEvent</code> with dispatched listeners. Creating this function
here, allows us to not have to bind or create functions for each event.
Mutating the event's members allows us to not have to create a wrapping
&quot;dispatch&quot; object that pairs the event with the listener.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateDirectionalDispatches</span>(<span class="hljs-params">inst, phase, event</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!inst) {
          error(<span class="hljs-string">'Dispatching inst must not be null'</span>);
        }
      }
      <span class="hljs-keyword">var</span> listener = listenerAtPhase(inst, event, phase);

      <span class="hljs-keyword">if</span> (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-540" id="section-540"></a>
</div>
<div class="dox">
<div class="summary">
<p>Collect dispatches (must be entirely collected before dispatching - see unit
tests). Lazily allocate the array to conserve memory.  We must loop through
each event and perform the traversal for each one. We cannot perform a
single traversal for the entire collection of events because each event may
have a different target.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateTwoPhaseDispatchesSingle</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">if</span> (event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) {
        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-541" id="section-541"></a>
</div>
<div class="dox">
<div class="summary">
<p>Accumulates without regard to direction, does not look for phased
registration names. Same as <code>accumulateDirectDispatchesSingle</code> but without
requiring that the <code>dispatchMarker</code> be the same as the dispatched ID.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateDispatches</span>(<span class="hljs-params">inst, ignoredDirection, event</span>) </span>{
      <span class="hljs-keyword">if</span> (inst &amp;&amp; event &amp;&amp; event.dispatchConfig.registrationName) {
        <span class="hljs-keyword">var</span> registrationName = event.dispatchConfig.registrationName;
        <span class="hljs-keyword">var</span> listener = getListener(inst, registrationName);

        <span class="hljs-keyword">if</span> (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-542" id="section-542"></a>
</div>
<div class="dox">
<div class="summary">
<p>Accumulates dispatches on an <code>SyntheticEvent</code>, but only for the
<code>dispatchMarker</code>.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">event</span>
<span class="dox_type">SyntheticEvent</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateDirectDispatchesSingle</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">if</span> (event &amp;&amp; event.dispatchConfig.registrationName) {
        accumulateDispatches(event._targetInst, <span class="hljs-literal">null</span>, event);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateTwoPhaseDispatches</span>(<span class="hljs-params">events</span>) </span>{
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateEnterLeaveDispatches</span>(<span class="hljs-params">leave, enter, from, to</span>) </span>{
      traverseEnterLeave(<span class="hljs-keyword">from</span>, to, accumulateDispatches, leave, enter);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accumulateDirectDispatches</span>(<span class="hljs-params">events</span>) </span>{
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-543" id="section-543"></a>
</div>
<div class="dox">
<div class="summary">
<p>These variables store information about text content of a target node,
allowing comparison of content before and after a given event.</p>
</div>
<div class="body">
<p>Identify the node where selection currently begins, then observe
both its text content and its current position in the DOM. Since the
browser may natively replace the target node during composition, we can
use its position to find its replacement.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> root = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> startText = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> fallbackText = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span>(<span class="hljs-params">nativeEventTarget</span>) </span>{
      root = nativeEventTarget;
      startText = getText();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>{
      root = <span class="hljs-literal">null</span>;
      startText = <span class="hljs-literal">null</span>;
      fallbackText = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (fallbackText) {
        <span class="hljs-keyword">return</span> fallbackText;
      }

      <span class="hljs-keyword">var</span> start;
      <span class="hljs-keyword">var</span> startValue = startText;
      <span class="hljs-keyword">var</span> startLength = startValue.length;
      <span class="hljs-keyword">var</span> end;
      <span class="hljs-keyword">var</span> endValue = getText();
      <span class="hljs-keyword">var</span> endLength = endValue.length;

      <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; startLength; start++) {
        <span class="hljs-keyword">if</span> (startValue[start] !== endValue[start]) {
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">var</span> minEnd = startLength - start;

      <span class="hljs-keyword">for</span> (end = <span class="hljs-number">1</span>; end &lt;= minEnd; end++) {
        <span class="hljs-keyword">if</span> (startValue[startLength - end] !== endValue[endLength - end]) {
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">var</span> sliceTail = end &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> - end : <span class="hljs-literal">undefined</span>;
      fallbackText = endValue.slice(start, sliceTail);
      <span class="hljs-keyword">return</span> fallbackText;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getText</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-string">'value'</span> <span class="hljs-keyword">in</span> root) {
        <span class="hljs-keyword">return</span> root.value;
      }

      <span class="hljs-keyword">return</span> root.textContent;
    }

    <span class="hljs-keyword">var</span> EVENT_POOL_SIZE = <span class="hljs-number">10</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-544" id="section-544"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> EventInterface = {
      <span class="hljs-attr">type</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">target</span>: <span class="hljs-literal">null</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-545" id="section-545"></a>
</div>
<p>currentTarget is set when dispatching; no use in copying it here</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      currentTarget: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      },
      <span class="hljs-attr">eventPhase</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">timeStamp</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">return</span> event.timeStamp || <span class="hljs-built_in">Date</span>.now();
      },
      <span class="hljs-attr">defaultPrevented</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">isTrusted</span>: <span class="hljs-literal">null</span>
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionThatReturnsTrue</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionThatReturnsFalse</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-546" id="section-546"></a>
</div>
<div class="dox">
<div class="summary">
<p>Synthetic events are dispatched by event plugins, typically in response to a
top-level event delegation handler.</p>
</div>
<div class="body">
<p>These systems should generally use pooling to reduce the frequency of garbage
collection. The system should check <code>isPersistent</code> to determine whether the
event should be released into the pool after being dispatched. Users that
need a persisted event should invoke <code>persist</code>.</p>
<p>Synthetic events (and subclasses) implement the DOM Level 3 Events API by
normalizing browser quirks. Subclasses do not necessarily have to implement a
DOM interface; custom application-specific events can also subclass this.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">dispatchConfig</span>
<span class="dox_type">object</span>
<span>Configuration used to dispatch this event.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">targetInst</span>
<span>Marker identifying the event target.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
<span>Native browser event.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEventTarget</span>
<span class="dox_type">DOMEventTarget</span>
<span>Target node.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SyntheticEvent</span>(<span class="hljs-params">dispatchConfig, targetInst, nativeEvent, nativeEventTarget</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-547" id="section-547"></a>
</div>
<p>these have a getter/setter for warnings</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.nativeEvent;
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.preventDefault;
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.stopPropagation;
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.isDefaultPrevented;
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.isPropagationStopped;
      }
      <span class="hljs-keyword">this</span>.dispatchConfig = dispatchConfig;
      <span class="hljs-keyword">this</span>._targetInst = targetInst;
      <span class="hljs-keyword">this</span>.nativeEvent = nativeEvent;
      <span class="hljs-keyword">var</span> Interface = <span class="hljs-keyword">this</span>.constructor.Interface;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propName <span class="hljs-keyword">in</span> Interface) {
        <span class="hljs-keyword">if</span> (!Interface.hasOwnProperty(propName)) {
          <span class="hljs-keyword">continue</span>;
        }

        {
          <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>[propName]; <span class="hljs-comment">// this has a getter/setter for warnings</span>
        }
        <span class="hljs-keyword">var</span> normalize = Interface[propName];

        <span class="hljs-keyword">if</span> (normalize) {
          <span class="hljs-keyword">this</span>[propName] = normalize(nativeEvent);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (propName === <span class="hljs-string">'target'</span>) {
            <span class="hljs-keyword">this</span>.target = nativeEventTarget;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>[propName] = nativeEvent[propName];
          }
        }
      }

      <span class="hljs-keyword">var</span> defaultPrevented = nativeEvent.defaultPrevented != <span class="hljs-literal">null</span> ? nativeEvent.defaultPrevented : nativeEvent.returnValue === <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (defaultPrevented) {
        <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsTrue;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsFalse;
      }

      <span class="hljs-keyword">this</span>.isPropagationStopped = functionThatReturnsFalse;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    _assign(SyntheticEvent.prototype, {
      <span class="hljs-attr">preventDefault</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.defaultPrevented = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.nativeEvent;

        <span class="hljs-keyword">if</span> (!event) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (event.preventDefault) {
          event.preventDefault();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.returnValue !== <span class="hljs-string">'unknown'</span>) {
          event.returnValue = <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsTrue;
      },
      <span class="hljs-attr">stopPropagation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.nativeEvent;

        <span class="hljs-keyword">if</span> (!event) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (event.stopPropagation) {
          event.stopPropagation();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.cancelBubble !== <span class="hljs-string">'unknown'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-548" id="section-548"></a>
</div>
<p>The ChangeEventPlugin registers a &quot;propertychange&quot; event for
IE. This event does not support bubbling or cancelling, and
any references to cancelBubble throw &quot;Member not found&quot;.  A
typeof check of &quot;unknown&quot; circumvents this issue (and is also
IE specific).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          event.cancelBubble = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">this</span>.isPropagationStopped = functionThatReturnsTrue;
      },

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-549" id="section-549"></a>
</div>
<div class="dox">
<div class="summary">
<p>We release all dispatched <code>SyntheticEvent</code>s after each event loop, adding
them back into the pool. This allows a way to hold onto a reference that
won't be added back into the pool.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      persist: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.isPersistent = functionThatReturnsTrue;
      },

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-550" id="section-550"></a>
</div>
<div class="dox">
<div class="summary">
<p>Checks if this event should be released back into the pool.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
<span>True if this should not be released, false otherwise.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      isPersistent: functionThatReturnsFalse,

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-551" id="section-551"></a>
</div>
<div class="dox">
<div class="summary">
<p><code>PooledClass</code> looks for <code>destructor</code> on each instance it releases.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      destructor: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> Interface = <span class="hljs-keyword">this</span>.constructor.Interface;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propName <span class="hljs-keyword">in</span> Interface) {
          {
            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
          }
        }

        <span class="hljs-keyword">this</span>.dispatchConfig = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>._targetInst = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>.nativeEvent = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>.isDefaultPrevented = functionThatReturnsFalse;
        <span class="hljs-keyword">this</span>.isPropagationStopped = functionThatReturnsFalse;
        <span class="hljs-keyword">this</span>._dispatchListeners = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>._dispatchInstances = <span class="hljs-literal">null</span>;
        {
          <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">'nativeEvent'</span>, getPooledWarningPropertyDefinition(<span class="hljs-string">'nativeEvent'</span>, <span class="hljs-literal">null</span>));
          <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">'isDefaultPrevented'</span>, getPooledWarningPropertyDefinition(<span class="hljs-string">'isDefaultPrevented'</span>, functionThatReturnsFalse));
          <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">'isPropagationStopped'</span>, getPooledWarningPropertyDefinition(<span class="hljs-string">'isPropagationStopped'</span>, functionThatReturnsFalse));
          <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">'preventDefault'</span>, getPooledWarningPropertyDefinition(<span class="hljs-string">'preventDefault'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}));
          <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">'stopPropagation'</span>, getPooledWarningPropertyDefinition(<span class="hljs-string">'stopPropagation'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}));
        }
      }
    });

    SyntheticEvent.Interface = EventInterface;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-552" id="section-552"></a>
</div>
<div class="dox">
<div class="summary">
<p>Helper to reduce boilerplate when creating subclasses.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    SyntheticEvent.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Interface</span>) </span>{
      <span class="hljs-keyword">var</span> Super = <span class="hljs-keyword">this</span>;

      <span class="hljs-keyword">var</span> E = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

      E.prototype = Super.prototype;
      <span class="hljs-keyword">var</span> prototype = <span class="hljs-keyword">new</span> E();

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Class</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> Super.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      }

      _assign(prototype, Class.prototype);

      Class.prototype = prototype;
      Class.prototype.constructor = Class;
      Class.Interface = _assign({}, Super.Interface, Interface);
      Class.extend = Super.extend;
      addEventPoolingTo(Class);
      <span class="hljs-keyword">return</span> Class;
    };

    addEventPoolingTo(SyntheticEvent);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-553" id="section-553"></a>
</div>
<div class="dox">
<div class="summary">
<p>Helper to nullify syntheticEvent instance properties when destructing</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">propName</span>
<span class="dox_type">String</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">getVal</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
<span>defineProperty object
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPooledWarningPropertyDefinition</span>(<span class="hljs-params">propName, getVal</span>) </span>{
      <span class="hljs-keyword">var</span> isFunction = <span class="hljs-keyword">typeof</span> getVal === <span class="hljs-string">'function'</span>;
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">set</span>: <span class="hljs-keyword">set</span>,
        <span class="hljs-keyword">get</span>: <span class="hljs-keyword">get</span>
      };

      function <span class="hljs-keyword">set</span>(val) {
        <span class="hljs-keyword">var</span> action = isFunction ? <span class="hljs-string">'setting the method'</span> : <span class="hljs-string">'setting the property'</span>;
        warn(action, <span class="hljs-string">'This is effectively a no-op'</span>);
        <span class="hljs-keyword">return</span> val;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> action = isFunction ? <span class="hljs-string">'accessing the method'</span> : <span class="hljs-string">'accessing the property'</span>;
        <span class="hljs-keyword">var</span> result = isFunction ? <span class="hljs-string">'This is a no-op function'</span> : <span class="hljs-string">'This is set to null'</span>;
        warn(action, result);
        <span class="hljs-keyword">return</span> getVal;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warn</span>(<span class="hljs-params">action, result</span>) </span>{
        {
          error(<span class="hljs-string">"This synthetic event is reused for performance reasons. If you're seeing this, "</span> + <span class="hljs-string">"you're %s `%s` on a released/nullified synthetic event. %s. "</span> + <span class="hljs-string">'If you must keep the original synthetic event around, use event.persist(). '</span> + <span class="hljs-string">'See https://fb.me/react-event-pooling for more information.'</span>, action, propName, result);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPooledEvent</span>(<span class="hljs-params">dispatchConfig, targetInst, nativeEvent, nativeInst</span>) </span>{
      <span class="hljs-keyword">var</span> EventConstructor = <span class="hljs-keyword">this</span>;

      <span class="hljs-keyword">if</span> (EventConstructor.eventPool.length) {
        <span class="hljs-keyword">var</span> instance = EventConstructor.eventPool.pop();
        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
        <span class="hljs-keyword">return</span> instance;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">releasePooledEvent</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">var</span> EventConstructor = <span class="hljs-keyword">this</span>;

      <span class="hljs-keyword">if</span> (!(event <span class="hljs-keyword">instanceof</span> EventConstructor)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Trying to release an event instance into a pool of a different type."</span>);
        }
      }

      event.destructor();

      <span class="hljs-keyword">if</span> (EventConstructor.eventPool.length &lt; EVENT_POOL_SIZE) {
        EventConstructor.eventPool.push(event);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventPoolingTo</span>(<span class="hljs-params">EventConstructor</span>) </span>{
      EventConstructor.eventPool = [];
      EventConstructor.getPooled = getPooledEvent;
      EventConstructor.release = releasePooledEvent;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-554" id="section-554"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents">http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> SyntheticCompositionEvent = SyntheticEvent.extend({
      <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-555" id="section-555"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="     /#events-inputevents">http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticInputEvent = SyntheticEvent.extend({
      <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>
    });
    <span class="hljs-keyword">var</span> END_KEYCODES = [<span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">27</span>, <span class="hljs-number">32</span>]; <span class="hljs-comment">// Tab, Return, Esc, Space</span>

    <span class="hljs-keyword">var</span> START_KEYCODE = <span class="hljs-number">229</span>;
    <span class="hljs-keyword">var</span> canUseCompositionEvent = canUseDOM &amp;&amp; <span class="hljs-string">'CompositionEvent'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>;
    <span class="hljs-keyword">var</span> documentMode = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (canUseDOM &amp;&amp; <span class="hljs-string">'documentMode'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>) {
      documentMode = <span class="hljs-built_in">document</span>.documentMode;
    } <span class="hljs-comment">// Webkit offers a very useful `textInput` event that can be used to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-556" id="section-556"></a>
</div>
<p>directly represent <code>beforeInput</code>. The IE <code>textinput</code> event is not as
useful, so we don't use it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> canUseTextInputEvent = canUseDOM &amp;&amp; <span class="hljs-string">'TextEvent'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> &amp;&amp; !documentMode; <span class="hljs-comment">// In IE9+, we have access to composition events, but the data supplied</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-557" id="section-557"></a>
</div>
<p>by the native compositionend event may be incorrect. Japanese ideographic
spaces, for instance (\u3000) are not recorded correctly.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> useFallbackCompositionData = canUseDOM &amp;&amp; (!canUseCompositionEvent || documentMode &amp;&amp; documentMode &gt; <span class="hljs-number">8</span> &amp;&amp; documentMode &lt;= <span class="hljs-number">11</span>);
    <span class="hljs-keyword">var</span> SPACEBAR_CODE = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">var</span> SPACEBAR_CHAR = <span class="hljs-built_in">String</span>.fromCharCode(SPACEBAR_CODE); <span class="hljs-comment">// Events and their corresponding property names.</span>

    <span class="hljs-keyword">var</span> eventTypes = {
      <span class="hljs-attr">beforeInput</span>: {
        <span class="hljs-attr">phasedRegistrationNames</span>: {
          <span class="hljs-attr">bubbled</span>: <span class="hljs-string">'onBeforeInput'</span>,
          <span class="hljs-attr">captured</span>: <span class="hljs-string">'onBeforeInputCapture'</span>
        },
        <span class="hljs-attr">dependencies</span>: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]
      },
      <span class="hljs-attr">compositionEnd</span>: {
        <span class="hljs-attr">phasedRegistrationNames</span>: {
          <span class="hljs-attr">bubbled</span>: <span class="hljs-string">'onCompositionEnd'</span>,
          <span class="hljs-attr">captured</span>: <span class="hljs-string">'onCompositionEndCapture'</span>
        },
        <span class="hljs-attr">dependencies</span>: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
      },
      <span class="hljs-attr">compositionStart</span>: {
        <span class="hljs-attr">phasedRegistrationNames</span>: {
          <span class="hljs-attr">bubbled</span>: <span class="hljs-string">'onCompositionStart'</span>,
          <span class="hljs-attr">captured</span>: <span class="hljs-string">'onCompositionStartCapture'</span>
        },
        <span class="hljs-attr">dependencies</span>: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
      },
      <span class="hljs-attr">compositionUpdate</span>: {
        <span class="hljs-attr">phasedRegistrationNames</span>: {
          <span class="hljs-attr">bubbled</span>: <span class="hljs-string">'onCompositionUpdate'</span>,
          <span class="hljs-attr">captured</span>: <span class="hljs-string">'onCompositionUpdateCapture'</span>
        },
        <span class="hljs-attr">dependencies</span>: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
      }
    }; <span class="hljs-comment">// Track whether we've ever handled a keypress on the space key.</span>

    <span class="hljs-keyword">var</span> hasSpaceKeypress = <span class="hljs-literal">false</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-558" id="section-558"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return whether a native keypress event is assumed to be a command.
This is required because Firefox fires <code>keypress</code> events for key commands
(cut, copy, select-all, etc.) even though no character is inserted.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isKeypressCommand</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">return</span> (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &amp;&amp; <span class="hljs-comment">// ctrlKey &amp;&amp; altKey is equivalent to AltGr, and is not a command.</span>
      !(nativeEvent.ctrlKey &amp;&amp; nativeEvent.altKey);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-559" id="section-559"></a>
</div>
<div class="dox">
<div class="summary">
<p>Translate native top level events into event types.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">topLevelType</span>
<span class="dox_type">string</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCompositionEventType</span>(<span class="hljs-params">topLevelType</span>) </span>{
      <span class="hljs-keyword">switch</span> (topLevelType) {
        <span class="hljs-keyword">case</span> TOP_COMPOSITION_START:
          <span class="hljs-keyword">return</span> eventTypes.compositionStart;

        <span class="hljs-keyword">case</span> TOP_COMPOSITION_END:
          <span class="hljs-keyword">return</span> eventTypes.compositionEnd;

        <span class="hljs-keyword">case</span> TOP_COMPOSITION_UPDATE:
          <span class="hljs-keyword">return</span> eventTypes.compositionUpdate;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-560" id="section-560"></a>
</div>
<div class="dox">
<div class="summary">
<p>Does our fallback best-guess model think this event signifies that
composition has begun?</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">topLevelType</span>
<span class="dox_type">string</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFallbackCompositionStart</span>(<span class="hljs-params">topLevelType, nativeEvent</span>) </span>{
      <span class="hljs-keyword">return</span> topLevelType === TOP_KEY_DOWN &amp;&amp; nativeEvent.keyCode === START_KEYCODE;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-561" id="section-561"></a>
</div>
<div class="dox">
<div class="summary">
<p>Does our fallback mode think that this event is the end of composition?</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">topLevelType</span>
<span class="dox_type">string</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFallbackCompositionEnd</span>(<span class="hljs-params">topLevelType, nativeEvent</span>) </span>{
      <span class="hljs-keyword">switch</span> (topLevelType) {
        <span class="hljs-keyword">case</span> TOP_KEY_UP:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-562" id="section-562"></a>
</div>
<p>Command keys insert or clear IME input.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> END_KEYCODES.indexOf(nativeEvent.keyCode) !== <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">case</span> TOP_KEY_DOWN:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-563" id="section-563"></a>
</div>
<p>Expect IME keyCode on each keydown. If we get any other
code we must have exited earlier.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> nativeEvent.keyCode !== START_KEYCODE;

        <span class="hljs-keyword">case</span> TOP_KEY_PRESS:
        <span class="hljs-keyword">case</span> TOP_MOUSE_DOWN:
        <span class="hljs-keyword">case</span> TOP_BLUR:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-564" id="section-564"></a>
</div>
<p>Events are not possible without cancelling IME.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-565" id="section-565"></a>
</div>
<div class="dox">
<div class="summary">
<p>Google Input Tools provides composition data via a CustomEvent,
with the <code>data</code> property populated in the <code>detail</code> object. If this
is available on the event object, use it. If not, this is a plain
composition event and we have nothing special to extract.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDataFromCustomEvent</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">var</span> detail = nativeEvent.detail;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> detail === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-string">'data'</span> <span class="hljs-keyword">in</span> detail) {
        <span class="hljs-keyword">return</span> detail.data;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-566" id="section-566"></a>
</div>
<div class="dox">
<div class="summary">
<p>Check if a composition event was triggered by Korean IME.
Our fallback mode does not work well with IE's Korean IME,
so just use native composition events when Korean IME is used.
Although CompositionEvent.locale property is deprecated,
it is available in IE, where our fallback mode is enabled.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">boolean</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUsingKoreanIME</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">return</span> nativeEvent.locale === <span class="hljs-string">'ko'</span>;
    } <span class="hljs-comment">// Track the current IME composition status, if any.</span>


    <span class="hljs-keyword">var</span> isComposing = <span class="hljs-literal">false</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-567" id="section-567"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
<span>A SyntheticCompositionEvent.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractCompositionEvent</span>(<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget</span>) </span>{
      <span class="hljs-keyword">var</span> eventType;
      <span class="hljs-keyword">var</span> fallbackData;

      <span class="hljs-keyword">if</span> (canUseCompositionEvent) {
        eventType = getCompositionEventType(topLevelType);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isComposing) {
        <span class="hljs-keyword">if</span> (isFallbackCompositionStart(topLevelType, nativeEvent)) {
          eventType = eventTypes.compositionStart;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionEnd;
      }

      <span class="hljs-keyword">if</span> (!eventType) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (useFallbackCompositionData &amp;&amp; !isUsingKoreanIME(nativeEvent)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-568" id="section-568"></a>
</div>
<p>The current composition is stored statically and must not be
overwritten while composition continues.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!isComposing &amp;&amp; eventType === eventTypes.compositionStart) {
          isComposing = initialize(nativeEventTarget);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eventType === eventTypes.compositionEnd) {
          <span class="hljs-keyword">if</span> (isComposing) {
            fallbackData = getData();
          }
        }
      }

      <span class="hljs-keyword">var</span> event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

      <span class="hljs-keyword">if</span> (fallbackData) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-569" id="section-569"></a>
</div>
<p>Inject data generated from fallback path into the synthetic event.
This matches the property of native CompositionEventInterface.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        event.data = fallbackData;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> customData = getDataFromCustomEvent(nativeEvent);

        <span class="hljs-keyword">if</span> (customData !== <span class="hljs-literal">null</span>) {
          event.data = customData;
        }
      }

      accumulateTwoPhaseDispatches(event);
      <span class="hljs-keyword">return</span> event;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-570" id="section-570"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">topLevelType</span>
<span class="dox_type">TopLevelType</span>
<span>Number from <code>TopLevelType</code>.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
<span>Native browser event.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
<span>The string corresponding to this <code>beforeInput</code> event.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNativeBeforeInputChars</span>(<span class="hljs-params">topLevelType, nativeEvent</span>) </span>{
      <span class="hljs-keyword">switch</span> (topLevelType) {
        <span class="hljs-keyword">case</span> TOP_COMPOSITION_END:
          <span class="hljs-keyword">return</span> getDataFromCustomEvent(nativeEvent);

        <span class="hljs-keyword">case</span> TOP_KEY_PRESS:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-571" id="section-571"></a>
</div>
<div class="dox">
<div class="summary">
<p>If native <code>textInput</code> events are available, our goal is to make
use of them. However, there is a special case: the spacebar key.
In Webkit, preventing default on a spacebar <code>textInput</code> event
cancels character insertion, but it <em>also</em> causes the browser
to fall back to its default spacebar behavior of scrolling the
page.</p>
</div>
<div class="body">
<p>Tracking at:
https://code.google.com/p/chromium/issues/detail?id=355103</p>
<p>To avoid this issue, use the keypress event as if no <code>textInput</code>
event is available.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> which = nativeEvent.which;

          <span class="hljs-keyword">if</span> (which !== SPACEBAR_CODE) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          hasSpaceKeypress = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> SPACEBAR_CHAR;

        <span class="hljs-keyword">case</span> TOP_TEXT_INPUT:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-572" id="section-572"></a>
</div>
<p>Record the characters to be added to the DOM.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> chars = nativeEvent.data; <span class="hljs-comment">// If it's a spacebar character, assume that we have already handled</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-573" id="section-573"></a>
</div>
<p>it at the keypress level and bail immediately. Android Chrome
doesn't give us keycodes, so we need to ignore it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">if</span> (chars === SPACEBAR_CHAR &amp;&amp; hasSpaceKeypress) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> chars;

        <span class="hljs-keyword">default</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-574" id="section-574"></a>
</div>
<p>For other native event types, do nothing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-575" id="section-575"></a>
</div>
<div class="dox">
<div class="summary">
<p>For browsers that do not provide the <code>textInput</code> event, extract the
appropriate string to use for SyntheticInputEvent.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">topLevelType</span>
<span class="dox_type">number</span>
<span>Number from <code>TopLevelEventTypes</code>.
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
<span>Native browser event.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
<span>The fallback string for this <code>beforeInput</code> event.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFallbackBeforeInputChars</span>(<span class="hljs-params">topLevelType, nativeEvent</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-576" id="section-576"></a>
</div>
<p>If we are currently composing (IME) and using a fallback to do so,
try to extract the composed characters from the fallback object.
If composition event is available, we extract a string only at
compositionevent, otherwise extract it at fallback events.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (isComposing) {
        <span class="hljs-keyword">if</span> (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType, nativeEvent)) {
          <span class="hljs-keyword">var</span> chars = getData();
          reset();
          isComposing = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">return</span> chars;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">switch</span> (topLevelType) {
        <span class="hljs-keyword">case</span> TOP_PASTE:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-577" id="section-577"></a>
</div>
<p>If a paste event occurs after a keypress, throw out the input
chars. Paste events should not lead to BeforeInput events.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">case</span> TOP_KEY_PRESS:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-578" id="section-578"></a>
</div>
<div class="dox">
<div class="summary">
<p>As of v27, Firefox may fire keypress events even when no character
will be inserted. A few possibilities:</p>
</div>
<div class="body">
<ul>
<li>
<p><code>which</code> is <code>0</code>. Arrow keys, Esc key, etc.</p>
</li>
<li>
<p><code>which</code> is the pressed key code, but no char is available.
Ex: 'AltGr + d<code>in Polish. There is no modified character for this key combination and no character is inserted into the document, but FF fires the keypress for char code</code>100<code>anyway. No</code>input` event will occur.</p>
</li>
<li>
<p><code>which</code> is the pressed key code, but a command combination is
being used. Ex: <code>Cmd+C</code>. No character is inserted, and no
<code>input</code> event will occur.</p>
</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (!isKeypressCommand(nativeEvent)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-579" id="section-579"></a>
</div>
<p>IE fires the <code>keypress</code> event when a user types an emoji via
Touch keyboard of Windows.  In such a case, the <code>char</code> property
holds an emoji character like <code>\uD83D\uDE0A</code>.  Because its length
is 2, the property <code>which</code> does not represent an emoji correctly.
In such a case, we directly return the <code>char</code> property instead of
using <code>which</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (nativeEvent.char &amp;&amp; nativeEvent.char.length &gt; <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> nativeEvent.char;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nativeEvent.which) {
              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(nativeEvent.which);
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">case</span> TOP_COMPOSITION_END:
          <span class="hljs-keyword">return</span> useFallbackCompositionData &amp;&amp; !isUsingKoreanIME(nativeEvent) ? <span class="hljs-literal">null</span> : nativeEvent.data;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-580" id="section-580"></a>
</div>
<div class="dox">
<div class="summary">
<p>Extract a SyntheticInputEvent for <code>beforeInput</code>, based on either native
<code>textInput</code> or fallback behavior.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
<span>A SyntheticInputEvent.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractBeforeInputEvent</span>(<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget</span>) </span>{
      <span class="hljs-keyword">var</span> chars;

      <span class="hljs-keyword">if</span> (canUseTextInputEvent) {
        chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
      } <span class="hljs-keyword">else</span> {
        chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
      } <span class="hljs-comment">// If no characters are being inserted, no BeforeInput event should</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-581" id="section-581"></a>
</div>
<p>be fired.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (!chars) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
      event.data = chars;
      accumulateTwoPhaseDispatches(event);
      <span class="hljs-keyword">return</span> event;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-582" id="section-582"></a>
</div>
<div class="dox">
<div class="summary">
<p>Create an <code>onBeforeInput</code> event to match
http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.</p>
</div>
<div class="body">
<p>This event plugin is based on the native <code>textInput</code> event
available in Chrome, Safari, Opera, and IE. This event fires after
<code>onKeyPress</code> and <code>onCompositionEnd</code>, but before <code>onInput</code>.</p>
<p><code>beforeInput</code> is spec'd but not implemented in any browsers, and
the <code>input</code> event does not provide any useful information about what has
actually been added, contrary to the spec. Thus, <code>textInput</code> is the best
available event to identify the characters that have actually been inserted
into the target node.</p>
<p>This plugin is also responsible for emitting <code>composition</code> events, thus
allowing us to share composition fallback code for both <code>beforeInput</code> and
<code>composition</code> event types.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> BeforeInputEventPlugin = {
      <span class="hljs-attr">eventTypes</span>: eventTypes,
      <span class="hljs-attr">extractEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags</span>) </span>{
        <span class="hljs-keyword">var</span> composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        <span class="hljs-keyword">var</span> beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);

        <span class="hljs-keyword">if</span> (composition === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> beforeInput;
        }

        <span class="hljs-keyword">if</span> (beforeInput === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> composition;
        }

        <span class="hljs-keyword">return</span> [composition, beforeInput];
      }
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-583" id="section-583"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary">http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> supportedInputTypes = {
      <span class="hljs-attr">color</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">date</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">datetime</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-string">'datetime-local'</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">email</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">month</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">number</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">password</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">range</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">search</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">tel</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">text</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">time</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">url</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">week</span>: <span class="hljs-literal">true</span>
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTextInputElement</span>(<span class="hljs-params">elem</span>) </span>{
      <span class="hljs-keyword">var</span> nodeName = elem &amp;&amp; elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();

      <span class="hljs-keyword">if</span> (nodeName === <span class="hljs-string">'input'</span>) {
        <span class="hljs-keyword">return</span> !!supportedInputTypes[elem.type];
      }

      <span class="hljs-keyword">if</span> (nodeName === <span class="hljs-string">'textarea'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> eventTypes$<span class="hljs-number">1</span> = {
      <span class="hljs-attr">change</span>: {
        <span class="hljs-attr">phasedRegistrationNames</span>: {
          <span class="hljs-attr">bubbled</span>: <span class="hljs-string">'onChange'</span>,
          <span class="hljs-attr">captured</span>: <span class="hljs-string">'onChangeCapture'</span>
        },
        <span class="hljs-attr">dependencies</span>: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAndAccumulateChangeEvent</span>(<span class="hljs-params">inst, nativeEvent, target</span>) </span>{
      <span class="hljs-keyword">var</span> event = SyntheticEvent.getPooled(eventTypes$<span class="hljs-number">1.</span>change, inst, nativeEvent, target);
      event.type = <span class="hljs-string">'change'</span>; <span class="hljs-comment">// Flag this event loop as needing state restore.</span>

      enqueueStateRestore(target);
      accumulateTwoPhaseDispatches(event);
      <span class="hljs-keyword">return</span> event;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-584" id="section-584"></a>
</div>
<div class="dox">
<div class="summary">
<p>For IE shims</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> activeElement = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> activeElementInst = <span class="hljs-literal">null</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-585" id="section-585"></a>
</div>
<div class="dox">
<div class="summary">
<p>SECTION: handle <code>change</code> event</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldUseChangeEvent</span>(<span class="hljs-params">elem</span>) </span>{
      <span class="hljs-keyword">var</span> nodeName = elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();
      <span class="hljs-keyword">return</span> nodeName === <span class="hljs-string">'select'</span> || nodeName === <span class="hljs-string">'input'</span> &amp;&amp; elem.type === <span class="hljs-string">'file'</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">manualDispatchChangeEvent</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">var</span> event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent)); <span class="hljs-comment">// If change and propertychange bubbled, we'd just bind to it like all the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-586" id="section-586"></a>
</div>
<p>other events and have it go through ReactBrowserEventEmitter. Since it
doesn't, we manually listen for the events and so we have to enqueue and
process the abstract event manually.</p>
<p>Batching is necessary here in order to ensure that all event handlers run
before the next rerender (including event handlers attached to ancestor
elements instead of directly on the input). Without this, controlled
components don't work properly in conjunction with event bubbling because
the component is rerendered and the value reverted before all the event
handlers can run. See https://github.com/facebook/react/issues/708.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      batchedUpdates(runEventInBatch, event);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runEventInBatch</span>(<span class="hljs-params">event</span>) </span>{
      runEventsInBatch(event);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInstIfValueChanged</span>(<span class="hljs-params">targetInst</span>) </span>{
      <span class="hljs-keyword">var</span> targetNode = getNodeFromInstance$<span class="hljs-number">1</span>(targetInst);

      <span class="hljs-keyword">if</span> (updateValueIfChanged(targetNode)) {
        <span class="hljs-keyword">return</span> targetInst;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTargetInstForChangeEvent</span>(<span class="hljs-params">topLevelType, targetInst</span>) </span>{
      <span class="hljs-keyword">if</span> (topLevelType === TOP_CHANGE) {
        <span class="hljs-keyword">return</span> targetInst;
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-587" id="section-587"></a>
</div>
<div class="dox">
<div class="summary">
<p>SECTION: handle <code>input</code> event</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> isInputEventSupported = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (canUseDOM) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-588" id="section-588"></a>
</div>
<p>IE9 claims to support the input event but fails to trigger it when
deleting text, so we ignore its input events.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      isInputEventSupported = isEventSupported(<span class="hljs-string">'input'</span>) &amp;&amp; (!<span class="hljs-built_in">document</span>.documentMode || <span class="hljs-built_in">document</span>.documentMode &gt; <span class="hljs-number">9</span>);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-589" id="section-589"></a>
</div>
<div class="dox">
<div class="summary">
<p>(For IE &lt;=9) Starts tracking propertychange events on the passed-in element
and override the value property so that we can distinguish user events from
value changes in JS.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWatchingForValueChange</span>(<span class="hljs-params">target, targetInst</span>) </span>{
      activeElement = target;
      activeElementInst = targetInst;
      activeElement.attachEvent(<span class="hljs-string">'onpropertychange'</span>, handlePropertyChange);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-590" id="section-590"></a>
</div>
<div class="dox">
<div class="summary">
<p>(For IE &lt;=9) Removes the event listeners from the currently-tracked element,
if any exists.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopWatchingForValueChange</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!activeElement) {
        <span class="hljs-keyword">return</span>;
      }

      activeElement.detachEvent(<span class="hljs-string">'onpropertychange'</span>, handlePropertyChange);
      activeElement = <span class="hljs-literal">null</span>;
      activeElementInst = <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-591" id="section-591"></a>
</div>
<div class="dox">
<div class="summary">
<p>(For IE &lt;=9) Handles a propertychange event, sending a <code>change</code> event if
the value of the active element has changed.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePropertyChange</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">if</span> (nativeEvent.propertyName !== <span class="hljs-string">'value'</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (getInstIfValueChanged(activeElementInst)) {
        manualDispatchChangeEvent(nativeEvent);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEventsForInputEventPolyfill</span>(<span class="hljs-params">topLevelType, target, targetInst</span>) </span>{
      <span class="hljs-keyword">if</span> (topLevelType === TOP_FOCUS) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-592" id="section-592"></a>
</div>
<p>In IE9, propertychange fires for most input events but is buggy and
doesn't fire when text is deleted, but conveniently, selectionchange
appears to fire in all of the remaining cases so we catch those and
forward the event if the value has changed
In either case, we don't want to call the event handler if the value
is changed from JS so we redefine a setter for <code>.value</code> that updates
our activeElementValue variable, allowing us to ignore those changes</p>
<p>stopWatching() should be a noop here but we call it just in case we
missed a blur event somehow.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        stopWatchingForValueChange();
        startWatchingForValueChange(target, targetInst);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (topLevelType === TOP_BLUR) {
        stopWatchingForValueChange();
      }
    } <span class="hljs-comment">// For IE8 and IE9.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTargetInstForInputEventPolyfill</span>(<span class="hljs-params">topLevelType, targetInst</span>) </span>{
      <span class="hljs-keyword">if</span> (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-593" id="section-593"></a>
</div>
<p>On the selectionchange event, the target is just document which isn't
helpful for us so just check activeElement instead.</p>
<p>99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
propertychange on the first input event after setting <code>value</code> from a
script and fires only keydown, keypress, keyup. Catching keyup usually
gets it and catching keydown lets us fire an event for the first
keystroke if user does a key repeat (it'll be a little delayed: right
before the second keystroke). Other input methods (e.g., paste) seem to
fire selectionchange normally.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> getInstIfValueChanged(activeElementInst);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-594" id="section-594"></a>
</div>
<div class="dox">
<div class="summary">
<p>SECTION: handle <code>click</code> event</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldUseClickEvent</span>(<span class="hljs-params">elem</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-595" id="section-595"></a>
</div>
<p>Use the <code>click</code> event to detect changes to checkbox and radio inputs.
This approach works across all browsers, whereas <code>change</code> does not fire
until <code>blur</code> in IE8.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> nodeName = elem.nodeName;
      <span class="hljs-keyword">return</span> nodeName &amp;&amp; nodeName.toLowerCase() === <span class="hljs-string">'input'</span> &amp;&amp; (elem.type === <span class="hljs-string">'checkbox'</span> || elem.type === <span class="hljs-string">'radio'</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTargetInstForClickEvent</span>(<span class="hljs-params">topLevelType, targetInst</span>) </span>{
      <span class="hljs-keyword">if</span> (topLevelType === TOP_CLICK) {
        <span class="hljs-keyword">return</span> getInstIfValueChanged(targetInst);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTargetInstForInputOrChangeEvent</span>(<span class="hljs-params">topLevelType, targetInst</span>) </span>{
      <span class="hljs-keyword">if</span> (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {
        <span class="hljs-keyword">return</span> getInstIfValueChanged(targetInst);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleControlledInputBlur</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> state = node._wrapperState;

      <span class="hljs-keyword">if</span> (!state || !state.controlled || node.type !== <span class="hljs-string">'number'</span>) {
        <span class="hljs-keyword">return</span>;
      }

      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-596" id="section-596"></a>
</div>
<p>If controlled, assign the value attribute to the current value on blur</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        setDefaultValue(node, <span class="hljs-string">'number'</span>, node.value);
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-597" id="section-597"></a>
</div>
<div class="dox">
<div class="summary">
<p>This plugin creates an <code>onChange</code> event that normalizes change events
across form elements. This event fires at a time when it's possible to
change the element's value without seeing a flicker.</p>
</div>
<div class="body">
<p>Supported elements are:</p>
<ul>
<li>input (see <code>isTextInputElement</code>)</li>
<li>textarea</li>
<li>select</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> ChangeEventPlugin = {
      <span class="hljs-attr">eventTypes</span>: eventTypes$<span class="hljs-number">1</span>,
      <span class="hljs-attr">_isInputEventSupported</span>: isInputEventSupported,
      <span class="hljs-attr">extractEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags</span>) </span>{
        <span class="hljs-keyword">var</span> targetNode = targetInst ? getNodeFromInstance$<span class="hljs-number">1</span>(targetInst) : <span class="hljs-built_in">window</span>;
        <span class="hljs-keyword">var</span> getTargetInstFunc, handleEventFunc;

        <span class="hljs-keyword">if</span> (shouldUseChangeEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForChangeEvent;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTextInputElement(targetNode)) {
          <span class="hljs-keyword">if</span> (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          } <span class="hljs-keyword">else</span> {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }

        <span class="hljs-keyword">if</span> (getTargetInstFunc) {
          <span class="hljs-keyword">var</span> inst = getTargetInstFunc(topLevelType, targetInst);

          <span class="hljs-keyword">if</span> (inst) {
            <span class="hljs-keyword">var</span> event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
            <span class="hljs-keyword">return</span> event;
          }
        }

        <span class="hljs-keyword">if</span> (handleEventFunc) {
          handleEventFunc(topLevelType, targetNode, targetInst);
        } <span class="hljs-comment">// When blurring, set the value attribute for number inputs</span>


        <span class="hljs-keyword">if</span> (topLevelType === TOP_BLUR) {
          handleControlledInputBlur(targetNode);
        }
      }
    };
    <span class="hljs-keyword">var</span> SyntheticUIEvent = SyntheticEvent.extend({
      <span class="hljs-attr">view</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">detail</span>: <span class="hljs-literal">null</span>
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-598" id="section-598"></a>
</div>
<div class="dox">
<div class="summary">
<p>Translation from modifier key to the associated property in the event.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers">http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> modifierKeyToProp = {
      <span class="hljs-attr">Alt</span>: <span class="hljs-string">'altKey'</span>,
      <span class="hljs-attr">Control</span>: <span class="hljs-string">'ctrlKey'</span>,
      <span class="hljs-attr">Meta</span>: <span class="hljs-string">'metaKey'</span>,
      <span class="hljs-attr">Shift</span>: <span class="hljs-string">'shiftKey'</span>
    }; <span class="hljs-comment">// Older browsers (Safari &lt;= 10, iOS Safari &lt;= 10.2) do not support</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-599" id="section-599"></a>
</div>
<p>getModifierState. If getModifierState is not supported, we map it to a set of
modifier keys exposed by the event. In this case, Lock-keys are not supported.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">modifierStateGetter</span>(<span class="hljs-params">keyArg</span>) </span>{
      <span class="hljs-keyword">var</span> syntheticEvent = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> nativeEvent = syntheticEvent.nativeEvent;

      <span class="hljs-keyword">if</span> (nativeEvent.getModifierState) {
        <span class="hljs-keyword">return</span> nativeEvent.getModifierState(keyArg);
      }

      <span class="hljs-keyword">var</span> keyProp = modifierKeyToProp[keyArg];
      <span class="hljs-keyword">return</span> keyProp ? !!nativeEvent[keyProp] : <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventModifierState</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">return</span> modifierStateGetter;
    }

    <span class="hljs-keyword">var</span> previousScreenX = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> previousScreenY = <span class="hljs-number">0</span>; <span class="hljs-comment">// Use flags to signal movementX/Y has already been set</span>

    <span class="hljs-keyword">var</span> isMovementXSet = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> isMovementYSet = <span class="hljs-literal">false</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-600" id="section-600"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticMouseEvent = SyntheticUIEvent.extend({
      <span class="hljs-attr">screenX</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">screenY</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">clientX</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">clientY</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">pageX</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">pageY</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">ctrlKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">shiftKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">altKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">metaKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">getModifierState</span>: getEventModifierState,
      <span class="hljs-attr">button</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">buttons</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">relatedTarget</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">return</span> event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
      },
      <span class="hljs-attr">movementX</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-string">'movementX'</span> <span class="hljs-keyword">in</span> event) {
          <span class="hljs-keyword">return</span> event.movementX;
        }

        <span class="hljs-keyword">var</span> screenX = previousScreenX;
        previousScreenX = event.screenX;

        <span class="hljs-keyword">if</span> (!isMovementXSet) {
          isMovementXSet = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">return</span> event.type === <span class="hljs-string">'mousemove'</span> ? event.screenX - screenX : <span class="hljs-number">0</span>;
      },
      <span class="hljs-attr">movementY</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-string">'movementY'</span> <span class="hljs-keyword">in</span> event) {
          <span class="hljs-keyword">return</span> event.movementY;
        }

        <span class="hljs-keyword">var</span> screenY = previousScreenY;
        previousScreenY = event.screenY;

        <span class="hljs-keyword">if</span> (!isMovementYSet) {
          isMovementYSet = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">return</span> event.type === <span class="hljs-string">'mousemove'</span> ? event.screenY - screenY : <span class="hljs-number">0</span>;
      }
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-601" id="section-601"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/pointerevents/">http://www.w3.org/TR/pointerevents/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticPointerEvent = SyntheticMouseEvent.extend({
      <span class="hljs-attr">pointerId</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">width</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">height</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">pressure</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">tangentialPressure</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">tiltX</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">tiltY</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">twist</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">pointerType</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">isPrimary</span>: <span class="hljs-literal">null</span>
    });
    <span class="hljs-keyword">var</span> eventTypes$<span class="hljs-number">2</span> = {
      <span class="hljs-attr">mouseEnter</span>: {
        <span class="hljs-attr">registrationName</span>: <span class="hljs-string">'onMouseEnter'</span>,
        <span class="hljs-attr">dependencies</span>: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
      },
      <span class="hljs-attr">mouseLeave</span>: {
        <span class="hljs-attr">registrationName</span>: <span class="hljs-string">'onMouseLeave'</span>,
        <span class="hljs-attr">dependencies</span>: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
      },
      <span class="hljs-attr">pointerEnter</span>: {
        <span class="hljs-attr">registrationName</span>: <span class="hljs-string">'onPointerEnter'</span>,
        <span class="hljs-attr">dependencies</span>: [TOP_POINTER_OUT, TOP_POINTER_OVER]
      },
      <span class="hljs-attr">pointerLeave</span>: {
        <span class="hljs-attr">registrationName</span>: <span class="hljs-string">'onPointerLeave'</span>,
        <span class="hljs-attr">dependencies</span>: [TOP_POINTER_OUT, TOP_POINTER_OVER]
      }
    };
    <span class="hljs-keyword">var</span> EnterLeaveEventPlugin = {
      <span class="hljs-attr">eventTypes</span>: eventTypes$<span class="hljs-number">2</span>,

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-602" id="section-602"></a>
</div>
<div class="dox">
<div class="summary">
<p>For almost every interaction we care about, there will be both a top-level
<code>mouseover</code> and <code>mouseout</code> event that occurs. Only use <code>mouseout</code> so that
we do not extract duplicate events. However, moving the mouse into the
browser from outside will not fire a <code>mouseout</code> event. In this case, we use
the <code>mouseover</code> top-level event.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      extractEvents: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags</span>) </span>{
        <span class="hljs-keyword">var</span> isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;
        <span class="hljs-keyword">var</span> isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;

        <span class="hljs-keyword">if</span> (isOverEvent &amp;&amp; (eventSystemFlags &amp; IS_REPLAYED) === <span class="hljs-number">0</span> &amp;&amp; (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-603" id="section-603"></a>
</div>
<p>If this is an over event with a target, then we've already dispatched
the event in the out event of the other target. If this is replayed,
then it's because we couldn't dispatch against this target previously
so we have to do it now instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (!isOutEvent &amp;&amp; !isOverEvent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-604" id="section-604"></a>
</div>
<p>Must not be a mouse or pointer in or out - ignoring.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> win;

        <span class="hljs-keyword">if</span> (nativeEventTarget.window === nativeEventTarget) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-605" id="section-605"></a>
</div>
<p><code>nativeEventTarget</code> is probably a window object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          win = nativeEventTarget;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-606" id="section-606"></a>
</div>
<p>TODO: Figure out why <code>ownerDocument</code> is sometimes undefined in IE8.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> doc = nativeEventTarget.ownerDocument;

          <span class="hljs-keyword">if</span> (doc) {
            win = doc.defaultView || doc.parentWindow;
          } <span class="hljs-keyword">else</span> {
            win = <span class="hljs-built_in">window</span>;
          }
        }

        <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span>;
        <span class="hljs-keyword">var</span> to;

        <span class="hljs-keyword">if</span> (isOutEvent) {
          <span class="hljs-keyword">from</span> = targetInst;
          <span class="hljs-keyword">var</span> related = nativeEvent.relatedTarget || nativeEvent.toElement;
          to = related ? getClosestInstanceFromNode(related) : <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">if</span> (to !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> nearestMounted = getNearestMountedFiber(to);

            <span class="hljs-keyword">if</span> (to !== nearestMounted || to.tag !== HostComponent &amp;&amp; to.tag !== HostText) {
              to = <span class="hljs-literal">null</span>;
            }
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-607" id="section-607"></a>
</div>
<p>Moving to a node from outside the window.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">from</span> = <span class="hljs-literal">null</span>;
          to = targetInst;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> === to) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-608" id="section-608"></a>
</div>
<p>Nothing pertains to our managed components.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> eventInterface, leaveEventType, enterEventType, eventTypePrefix;

        <span class="hljs-keyword">if</span> (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {
          eventInterface = SyntheticMouseEvent;
          leaveEventType = eventTypes$<span class="hljs-number">2.</span>mouseLeave;
          enterEventType = eventTypes$<span class="hljs-number">2.</span>mouseEnter;
          eventTypePrefix = <span class="hljs-string">'mouse'</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {
          eventInterface = SyntheticPointerEvent;
          leaveEventType = eventTypes$<span class="hljs-number">2.</span>pointerLeave;
          enterEventType = eventTypes$<span class="hljs-number">2.</span>pointerEnter;
          eventTypePrefix = <span class="hljs-string">'pointer'</span>;
        }

        <span class="hljs-keyword">var</span> fromNode = <span class="hljs-keyword">from</span> == <span class="hljs-literal">null</span> ? win : getNodeFromInstance$<span class="hljs-number">1</span>(<span class="hljs-keyword">from</span>);
        <span class="hljs-keyword">var</span> toNode = to == <span class="hljs-literal">null</span> ? win : getNodeFromInstance$<span class="hljs-number">1</span>(to);
        <span class="hljs-keyword">var</span> leave = eventInterface.getPooled(leaveEventType, <span class="hljs-keyword">from</span>, nativeEvent, nativeEventTarget);
        leave.type = eventTypePrefix + <span class="hljs-string">'leave'</span>;
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        <span class="hljs-keyword">var</span> enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);
        enter.type = eventTypePrefix + <span class="hljs-string">'enter'</span>;
        enter.target = toNode;
        enter.relatedTarget = fromNode;
        accumulateEnterLeaveDispatches(leave, enter, <span class="hljs-keyword">from</span>, to); <span class="hljs-comment">// If we are not processing the first ancestor, then we</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-609" id="section-609"></a>
</div>
<p>should not process the same nativeEvent again, as we
will have already processed it in the first ancestor.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> ((eventSystemFlags &amp; IS_FIRST_ANCESTOR) === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> [leave];
        }

        <span class="hljs-keyword">return</span> [leave, enter];
      }
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-610" id="section-610"></a>
</div>
<div class="dox">
<div class="summary">
<p>inlined Object.is polyfill to avoid requiring consumers ship their own
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is</span>(<span class="hljs-params">x, y</span>) </span>{
      <span class="hljs-keyword">return</span> x === y &amp;&amp; (x !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / x === <span class="hljs-number">1</span> / y) || x !== x &amp;&amp; y !== y <span class="hljs-comment">// eslint-disable-line no-self-compare</span>
      ;
    }

    <span class="hljs-keyword">var</span> objectIs = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.is === <span class="hljs-string">'function'</span> ? <span class="hljs-built_in">Object</span>.is : is;
    <span class="hljs-keyword">var</span> hasOwnProperty$<span class="hljs-number">2</span> = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-611" id="section-611"></a>
</div>
<div class="dox">
<div class="summary">
<p>Performs equality by iterating through keys on an object and returning false
when any key has values which are not strictly equal between the arguments.
Returns true when the values of all keys are strictly equal.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowEqual</span>(<span class="hljs-params">objA, objB</span>) </span>{
      <span class="hljs-keyword">if</span> (objectIs(objA, objB)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> objA !== <span class="hljs-string">'object'</span> || objA === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> objB !== <span class="hljs-string">'object'</span> || objB === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> keysA = <span class="hljs-built_in">Object</span>.keys(objA);
      <span class="hljs-keyword">var</span> keysB = <span class="hljs-built_in">Object</span>.keys(objB);

      <span class="hljs-keyword">if</span> (keysA.length !== keysB.length) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-comment">// Test for A's keys different from B.</span>


      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keysA.length; i++) {
        <span class="hljs-keyword">if</span> (!hasOwnProperty$<span class="hljs-number">2.</span>call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">var</span> skipSelectionChangeEvent = canUseDOM &amp;&amp; <span class="hljs-string">'documentMode'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span> &amp;&amp; <span class="hljs-built_in">document</span>.documentMode &lt;= <span class="hljs-number">11</span>;
    <span class="hljs-keyword">var</span> eventTypes$<span class="hljs-number">3</span> = {
      <span class="hljs-attr">select</span>: {
        <span class="hljs-attr">phasedRegistrationNames</span>: {
          <span class="hljs-attr">bubbled</span>: <span class="hljs-string">'onSelect'</span>,
          <span class="hljs-attr">captured</span>: <span class="hljs-string">'onSelectCapture'</span>
        },
        <span class="hljs-attr">dependencies</span>: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]
      }
    };
    <span class="hljs-keyword">var</span> activeElement$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> activeElementInst$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> lastSelection = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> mouseDown = <span class="hljs-literal">false</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-612" id="section-612"></a>
</div>
<div class="dox">
<div class="summary">
<p>Get an object which is a unique representation of the current selection.</p>
</div>
<div class="body">
<p>The return value will not be consistent across nodes or browsers, but
two identical selections on the same node will return identical objects.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">node</span>
<span class="dox_type">DOMElement</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">object</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelection$1</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-string">'selectionStart'</span> <span class="hljs-keyword">in</span> node &amp;&amp; hasSelectionCapabilities(node)) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">start</span>: node.selectionStart,
          <span class="hljs-attr">end</span>: node.selectionEnd
        };
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> win = node.ownerDocument &amp;&amp; node.ownerDocument.defaultView || <span class="hljs-built_in">window</span>;
        <span class="hljs-keyword">var</span> selection = win.getSelection();
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">anchorNode</span>: selection.anchorNode,
          <span class="hljs-attr">anchorOffset</span>: selection.anchorOffset,
          <span class="hljs-attr">focusNode</span>: selection.focusNode,
          <span class="hljs-attr">focusOffset</span>: selection.focusOffset
        };
      }
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-613" id="section-613"></a>
</div>
<div class="dox">
<div class="summary">
<p>Get document associated with the event target.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEventTarget</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">Document</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventTargetDocument</span>(<span class="hljs-params">eventTarget</span>) </span>{
      <span class="hljs-keyword">return</span> eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-614" id="section-614"></a>
</div>
<div class="dox">
<div class="summary">
<p>Poll selection to see whether it's changed.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEventTarget</span>
<span class="dox_type">object</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">SyntheticEvent</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructSelectEvent</span>(<span class="hljs-params">nativeEvent, nativeEventTarget</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-615" id="section-615"></a>
</div>
<p>Ensure we have the right element, and that the user is not dragging a
selection (this matches native <code>select</code> event behavior). In HTML5, select
fires only on input and textarea thus if there's no focused element we
won't dispatch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> doc = getEventTargetDocument(nativeEventTarget);

      <span class="hljs-keyword">if</span> (mouseDown || activeElement$<span class="hljs-number">1</span> == <span class="hljs-literal">null</span> || activeElement$<span class="hljs-number">1</span> !== getActiveElement(doc)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// Only fire when selection has actually changed.</span>


      <span class="hljs-keyword">var</span> currentSelection = getSelection$<span class="hljs-number">1</span>(activeElement$<span class="hljs-number">1</span>);

      <span class="hljs-keyword">if</span> (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
        lastSelection = currentSelection;
        <span class="hljs-keyword">var</span> syntheticEvent = SyntheticEvent.getPooled(eventTypes$<span class="hljs-number">3.</span>select, activeElementInst$<span class="hljs-number">1</span>, nativeEvent, nativeEventTarget);
        syntheticEvent.type = <span class="hljs-string">'select'</span>;
        syntheticEvent.target = activeElement$<span class="hljs-number">1</span>;
        accumulateTwoPhaseDispatches(syntheticEvent);
        <span class="hljs-keyword">return</span> syntheticEvent;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-616" id="section-616"></a>
</div>
<div class="dox">
<div class="summary">
<p>This plugin creates an <code>onSelect</code> event that normalizes select events
across form elements.</p>
</div>
<div class="body">
<p>Supported elements are:</p>
<ul>
<li>input (see <code>isTextInputElement</code>)</li>
<li>textarea</li>
<li>contentEditable</li>
</ul>
<p>This differs from native browser implementations in the following ways:</p>
<ul>
<li>Fires on contentEditable fields as well as inputs.</li>
<li>Fires for collapsed selection.</li>
<li>Fires after user input.</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> SelectEventPlugin = {
      <span class="hljs-attr">eventTypes</span>: eventTypes$<span class="hljs-number">3</span>,
      <span class="hljs-attr">extractEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, container</span>) </span>{
        <span class="hljs-keyword">var</span> containerOrDoc = container || getEventTargetDocument(nativeEventTarget); <span class="hljs-comment">// Track whether all listeners exists for this plugin. If none exist, we do</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-617" id="section-617"></a>
</div>
<p>not extract events. See #3639.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (!containerOrDoc || !isListeningToAllDependencies(<span class="hljs-string">'onSelect'</span>, containerOrDoc)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> targetNode = targetInst ? getNodeFromInstance$<span class="hljs-number">1</span>(targetInst) : <span class="hljs-built_in">window</span>;

        <span class="hljs-keyword">switch</span> (topLevelType) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-618" id="section-618"></a>
</div>
<p>Track the input node that has focus.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">case</span> TOP_FOCUS:
            <span class="hljs-keyword">if</span> (isTextInputElement(targetNode) || targetNode.contentEditable === <span class="hljs-string">'true'</span>) {
              activeElement$<span class="hljs-number">1</span> = targetNode;
              activeElementInst$<span class="hljs-number">1</span> = targetInst;
              lastSelection = <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_BLUR:
            activeElement$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
            activeElementInst$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
            lastSelection = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">break</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-619" id="section-619"></a>
</div>
<p>Don't fire the event while the user is dragging. This matches the
semantics of the native select event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> TOP_MOUSE_DOWN:
            mouseDown = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_CONTEXT_MENU:
          <span class="hljs-keyword">case</span> TOP_MOUSE_UP:
          <span class="hljs-keyword">case</span> TOP_DRAG_END:
            mouseDown = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">return</span> constructSelectEvent(nativeEvent, nativeEventTarget);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-620" id="section-620"></a>
</div>
<p>Chrome and IE fire non-standard event when selection is changed (and
sometimes when it hasn't). IE's event fires out of order with respect
to key and input events on deletion, so we discard it.</p>
<p>Firefox doesn't support selectionchange, so check selection status
after each key entry. The selection changes after keydown and before
keyup, but we check on keydown as well in the case of holding down a
key, when multiple keydown events are fired but only one keyup is.
This is also our approach for IE handling, for the reason above.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> TOP_SELECTION_CHANGE:
            <span class="hljs-keyword">if</span> (skipSelectionChangeEvent) {
              <span class="hljs-keyword">break</span>;
            }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-621" id="section-621"></a>
</div>
<p>falls through</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">case</span> TOP_KEY_DOWN:
          <span class="hljs-keyword">case</span> TOP_KEY_UP:
            <span class="hljs-keyword">return</span> constructSelectEvent(nativeEvent, nativeEventTarget);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-622" id="section-622"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/css3-animations/#AnimationEvent-interface">http://www.w3.org/TR/css3-animations/#AnimationEvent-interface</a>
</div>
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent">https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticAnimationEvent = SyntheticEvent.extend({
      <span class="hljs-attr">animationName</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">elapsedTime</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">pseudoElement</span>: <span class="hljs-literal">null</span>
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-623" id="section-623"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/clipboard-apis/">http://www.w3.org/TR/clipboard-apis/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticClipboardEvent = SyntheticEvent.extend({
      <span class="hljs-attr">clipboardData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'clipboardData'</span> <span class="hljs-keyword">in</span> event ? event.clipboardData : <span class="hljs-built_in">window</span>.clipboardData;
      }
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-624" id="section-624"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticFocusEvent = SyntheticUIEvent.extend({
      <span class="hljs-attr">relatedTarget</span>: <span class="hljs-literal">null</span>
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-625" id="section-625"></a>
</div>
<div class="dox">
<div class="summary">
<p><code>charCode</code> represents the actual &quot;character code&quot; and is safe to use with
<code>String.fromCharCode</code>. As such, only keys that correspond to printable
characters produce a valid <code>charCode</code>, the only exception to this is Enter.
The Tab-key is considered non-printable and does not have a <code>charCode</code>,
presumably because it does not produce a tab-character in browsers.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
<span>Native browser event.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">number</span>
<span>Normalized <code>charCode</code> property.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventCharCode</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">var</span> charCode;
      <span class="hljs-keyword">var</span> keyCode = nativeEvent.keyCode;

      <span class="hljs-keyword">if</span> (<span class="hljs-string">'charCode'</span> <span class="hljs-keyword">in</span> nativeEvent) {
        charCode = nativeEvent.charCode; <span class="hljs-comment">// FF does not set `charCode` for the Enter-key, check against `keyCode`.</span>

        <span class="hljs-keyword">if</span> (charCode === <span class="hljs-number">0</span> &amp;&amp; keyCode === <span class="hljs-number">13</span>) {
          charCode = <span class="hljs-number">13</span>;
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-626" id="section-626"></a>
</div>
<p>IE8 does not implement <code>charCode</code>, but <code>keyCode</code> has the correct value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        charCode = keyCode;
      } <span class="hljs-comment">// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-627" id="section-627"></a>
</div>
<p>report Enter as charCode 10 when ctrl is pressed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (charCode === <span class="hljs-number">10</span>) {
        charCode = <span class="hljs-number">13</span>;
      } <span class="hljs-comment">// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-628" id="section-628"></a>
</div>
<p>Must not discard the (non-)printable Enter-key.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (charCode &gt;= <span class="hljs-number">32</span> || charCode === <span class="hljs-number">13</span>) {
        <span class="hljs-keyword">return</span> charCode;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-629" id="section-629"></a>
</div>
<div class="dox">
<div class="summary">
<p>Normalization of deprecated HTML5 <code>key</code> values</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names">https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> normalizeKey = {
      <span class="hljs-attr">Esc</span>: <span class="hljs-string">'Escape'</span>,
      <span class="hljs-attr">Spacebar</span>: <span class="hljs-string">' '</span>,
      <span class="hljs-attr">Left</span>: <span class="hljs-string">'ArrowLeft'</span>,
      <span class="hljs-attr">Up</span>: <span class="hljs-string">'ArrowUp'</span>,
      <span class="hljs-attr">Right</span>: <span class="hljs-string">'ArrowRight'</span>,
      <span class="hljs-attr">Down</span>: <span class="hljs-string">'ArrowDown'</span>,
      <span class="hljs-attr">Del</span>: <span class="hljs-string">'Delete'</span>,
      <span class="hljs-attr">Win</span>: <span class="hljs-string">'OS'</span>,
      <span class="hljs-attr">Menu</span>: <span class="hljs-string">'ContextMenu'</span>,
      <span class="hljs-attr">Apps</span>: <span class="hljs-string">'ContextMenu'</span>,
      <span class="hljs-attr">Scroll</span>: <span class="hljs-string">'ScrollLock'</span>,
      <span class="hljs-attr">MozPrintableKey</span>: <span class="hljs-string">'Unidentified'</span>
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-630" id="section-630"></a>
</div>
<div class="dox">
<div class="summary">
<p>Translation from legacy <code>keyCode</code> to HTML5 <code>key</code>
Only special keys supported, all others depend on keyboard layout or browser</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names">https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> translateToKey = {
      <span class="hljs-string">'8'</span>: <span class="hljs-string">'Backspace'</span>,
      <span class="hljs-string">'9'</span>: <span class="hljs-string">'Tab'</span>,
      <span class="hljs-string">'12'</span>: <span class="hljs-string">'Clear'</span>,
      <span class="hljs-string">'13'</span>: <span class="hljs-string">'Enter'</span>,
      <span class="hljs-string">'16'</span>: <span class="hljs-string">'Shift'</span>,
      <span class="hljs-string">'17'</span>: <span class="hljs-string">'Control'</span>,
      <span class="hljs-string">'18'</span>: <span class="hljs-string">'Alt'</span>,
      <span class="hljs-string">'19'</span>: <span class="hljs-string">'Pause'</span>,
      <span class="hljs-string">'20'</span>: <span class="hljs-string">'CapsLock'</span>,
      <span class="hljs-string">'27'</span>: <span class="hljs-string">'Escape'</span>,
      <span class="hljs-string">'32'</span>: <span class="hljs-string">' '</span>,
      <span class="hljs-string">'33'</span>: <span class="hljs-string">'PageUp'</span>,
      <span class="hljs-string">'34'</span>: <span class="hljs-string">'PageDown'</span>,
      <span class="hljs-string">'35'</span>: <span class="hljs-string">'End'</span>,
      <span class="hljs-string">'36'</span>: <span class="hljs-string">'Home'</span>,
      <span class="hljs-string">'37'</span>: <span class="hljs-string">'ArrowLeft'</span>,
      <span class="hljs-string">'38'</span>: <span class="hljs-string">'ArrowUp'</span>,
      <span class="hljs-string">'39'</span>: <span class="hljs-string">'ArrowRight'</span>,
      <span class="hljs-string">'40'</span>: <span class="hljs-string">'ArrowDown'</span>,
      <span class="hljs-string">'45'</span>: <span class="hljs-string">'Insert'</span>,
      <span class="hljs-string">'46'</span>: <span class="hljs-string">'Delete'</span>,
      <span class="hljs-string">'112'</span>: <span class="hljs-string">'F1'</span>,
      <span class="hljs-string">'113'</span>: <span class="hljs-string">'F2'</span>,
      <span class="hljs-string">'114'</span>: <span class="hljs-string">'F3'</span>,
      <span class="hljs-string">'115'</span>: <span class="hljs-string">'F4'</span>,
      <span class="hljs-string">'116'</span>: <span class="hljs-string">'F5'</span>,
      <span class="hljs-string">'117'</span>: <span class="hljs-string">'F6'</span>,
      <span class="hljs-string">'118'</span>: <span class="hljs-string">'F7'</span>,
      <span class="hljs-string">'119'</span>: <span class="hljs-string">'F8'</span>,
      <span class="hljs-string">'120'</span>: <span class="hljs-string">'F9'</span>,
      <span class="hljs-string">'121'</span>: <span class="hljs-string">'F10'</span>,
      <span class="hljs-string">'122'</span>: <span class="hljs-string">'F11'</span>,
      <span class="hljs-string">'123'</span>: <span class="hljs-string">'F12'</span>,
      <span class="hljs-string">'144'</span>: <span class="hljs-string">'NumLock'</span>,
      <span class="hljs-string">'145'</span>: <span class="hljs-string">'ScrollLock'</span>,
      <span class="hljs-string">'224'</span>: <span class="hljs-string">'Meta'</span>
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-631" id="section-631"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">nativeEvent</span>
<span class="dox_type">object</span>
<span>Native browser event.
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
<span>Normalized <code>key</code> property.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventKey</span>(<span class="hljs-params">nativeEvent</span>) </span>{
      <span class="hljs-keyword">if</span> (nativeEvent.key) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-632" id="section-632"></a>
</div>
<p>Normalize inconsistent values reported by browsers due to
implementations of a working draft specification.
FireFox implements <code>key</code> but returns <code>MozPrintableKey</code> for all
printable characters (normalized to <code>Unidentified</code>), ignore it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> key = normalizeKey[nativeEvent.key] || nativeEvent.key;

        <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'Unidentified'</span>) {
          <span class="hljs-keyword">return</span> key;
        }
      } <span class="hljs-comment">// Browser does not implement `key`, polyfill as much of it as we can.</span>


      <span class="hljs-keyword">if</span> (nativeEvent.type === <span class="hljs-string">'keypress'</span>) {
        <span class="hljs-keyword">var</span> charCode = getEventCharCode(nativeEvent); <span class="hljs-comment">// The enter-key is technically both printable and non-printable and can</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-633" id="section-633"></a>
</div>
<p>thus be captured by <code>keypress</code>, no other non-printable key should.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">return</span> charCode === <span class="hljs-number">13</span> ? <span class="hljs-string">'Enter'</span> : <span class="hljs-built_in">String</span>.fromCharCode(charCode);
      }

      <span class="hljs-keyword">if</span> (nativeEvent.type === <span class="hljs-string">'keydown'</span> || nativeEvent.type === <span class="hljs-string">'keyup'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-634" id="section-634"></a>
</div>
<p>While user keyboard layout determines the actual meaning of each
<code>keyCode</code> value, almost all function keys have a universal value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> translateToKey[nativeEvent.keyCode] || <span class="hljs-string">'Unidentified'</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-635" id="section-635"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> SyntheticKeyboardEvent = SyntheticUIEvent.extend({
      <span class="hljs-attr">key</span>: getEventKey,
      <span class="hljs-attr">location</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">ctrlKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">shiftKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">altKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">metaKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">repeat</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">locale</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">getModifierState</span>: getEventModifierState,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-636" id="section-636"></a>
</div>
<p>Legacy Interface</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      charCode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-637" id="section-637"></a>
</div>
<p><code>charCode</code> is the result of a KeyPress event and represents the value of
the actual printable character.
KeyPress is deprecated, but its replacement is not yet final and not
implemented in any major browser. Only KeyPress has charCode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (event.type === <span class="hljs-string">'keypress'</span>) {
          <span class="hljs-keyword">return</span> getEventCharCode(event);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      },
      <span class="hljs-attr">keyCode</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-638" id="section-638"></a>
</div>
<p><code>keyCode</code> is the result of a KeyDown/Up event and represents the value of
physical keyboard key.
The actual meaning of the value depends on the users' keyboard layout
which cannot be detected. Assuming that it is a US keyboard layout
provides a surprisingly accurate mapping for US and European users.
Due to this, it is left to the user to implement at this time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (event.type === <span class="hljs-string">'keydown'</span> || event.type === <span class="hljs-string">'keyup'</span>) {
          <span class="hljs-keyword">return</span> event.keyCode;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      },
      <span class="hljs-attr">which</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-639" id="section-639"></a>
</div>
<p><code>which</code> is an alias for either <code>keyCode</code> or <code>charCode</code> depending on the
type of the event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (event.type === <span class="hljs-string">'keypress'</span>) {
          <span class="hljs-keyword">return</span> getEventCharCode(event);
        }

        <span class="hljs-keyword">if</span> (event.type === <span class="hljs-string">'keydown'</span> || event.type === <span class="hljs-string">'keyup'</span>) {
          <span class="hljs-keyword">return</span> event.keyCode;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-640" id="section-640"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticDragEvent = SyntheticMouseEvent.extend({
      <span class="hljs-attr">dataTransfer</span>: <span class="hljs-literal">null</span>
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-641" id="section-641"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/touch-events/">http://www.w3.org/TR/touch-events/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticTouchEvent = SyntheticUIEvent.extend({
      <span class="hljs-attr">touches</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">targetTouches</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">changedTouches</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">altKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">metaKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">ctrlKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">shiftKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">getModifierState</span>: getEventModifierState
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-642" id="section-642"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-">http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-</a>
</div>
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent">https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticTransitionEvent = SyntheticEvent.extend({
      <span class="hljs-attr">propertyName</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">elapsedTime</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">pseudoElement</span>: <span class="hljs-literal">null</span>
    });
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-643" id="section-643"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SyntheticWheelEvent = SyntheticMouseEvent.extend({
      <span class="hljs-attr">deltaX</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'deltaX'</span> <span class="hljs-keyword">in</span> event ? event.deltaX : <span class="hljs-comment">// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).</span>
        <span class="hljs-string">'wheelDeltaX'</span> <span class="hljs-keyword">in</span> event ? -event.wheelDeltaX : <span class="hljs-number">0</span>;
      },
      <span class="hljs-attr">deltaY</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'deltaY'</span> <span class="hljs-keyword">in</span> event ? event.deltaY : <span class="hljs-comment">// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).</span>
        <span class="hljs-string">'wheelDeltaY'</span> <span class="hljs-keyword">in</span> event ? -event.wheelDeltaY : <span class="hljs-comment">// Fallback to `wheelDelta` for IE&lt;9 and normalize (down is positive).</span>
        <span class="hljs-string">'wheelDelta'</span> <span class="hljs-keyword">in</span> event ? -event.wheelDelta : <span class="hljs-number">0</span>;
      },
      <span class="hljs-attr">deltaZ</span>: <span class="hljs-literal">null</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-644" id="section-644"></a>
</div>
<p>Browsers without &quot;deltaMode&quot; is reporting in raw wheel delta where one
notch on the scroll is always +/- 120, roughly equivalent to pixels.
A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      deltaMode: <span class="hljs-literal">null</span>
    });
    <span class="hljs-keyword">var</span> knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];
    <span class="hljs-keyword">var</span> SimpleEventPlugin = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-645" id="section-645"></a>
</div>
<p>simpleEventPluginEventTypes gets populated from
the DOMEventProperties module.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      eventTypes: simpleEventPluginEventTypes,
      <span class="hljs-attr">extractEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags</span>) </span>{
        <span class="hljs-keyword">var</span> dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);

        <span class="hljs-keyword">if</span> (!dispatchConfig) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> EventConstructor;

        <span class="hljs-keyword">switch</span> (topLevelType) {
          <span class="hljs-keyword">case</span> TOP_KEY_PRESS:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-646" id="section-646"></a>
</div>
<p>Firefox creates a keypress event for function keys too. This removes
the unwanted keypress events. Enter is however both printable and
non-printable. One would expect Tab to be as well (but it isn't).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (getEventCharCode(nativeEvent) === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

          <span class="hljs-comment">/* falls through */</span>

          <span class="hljs-keyword">case</span> TOP_KEY_DOWN:
          <span class="hljs-keyword">case</span> TOP_KEY_UP:
            EventConstructor = SyntheticKeyboardEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_BLUR:
          <span class="hljs-keyword">case</span> TOP_FOCUS:
            EventConstructor = SyntheticFocusEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_CLICK:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-647" id="section-647"></a>
</div>
<p>Firefox creates a click event on right mouse clicks. This removes the
unwanted click events.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (nativeEvent.button === <span class="hljs-number">2</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

          <span class="hljs-comment">/* falls through */</span>

          <span class="hljs-keyword">case</span> TOP_AUX_CLICK:
          <span class="hljs-keyword">case</span> TOP_DOUBLE_CLICK:
          <span class="hljs-keyword">case</span> TOP_MOUSE_DOWN:
          <span class="hljs-keyword">case</span> TOP_MOUSE_MOVE:
          <span class="hljs-keyword">case</span> TOP_MOUSE_UP: <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Disabled elements should not respond to mouse events</span>

          <span class="hljs-comment">/* falls through */</span>

          <span class="hljs-keyword">case</span> TOP_MOUSE_OUT:
          <span class="hljs-keyword">case</span> TOP_MOUSE_OVER:
          <span class="hljs-keyword">case</span> TOP_CONTEXT_MENU:
            EventConstructor = SyntheticMouseEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_DRAG:
          <span class="hljs-keyword">case</span> TOP_DRAG_END:
          <span class="hljs-keyword">case</span> TOP_DRAG_ENTER:
          <span class="hljs-keyword">case</span> TOP_DRAG_EXIT:
          <span class="hljs-keyword">case</span> TOP_DRAG_LEAVE:
          <span class="hljs-keyword">case</span> TOP_DRAG_OVER:
          <span class="hljs-keyword">case</span> TOP_DRAG_START:
          <span class="hljs-keyword">case</span> TOP_DROP:
            EventConstructor = SyntheticDragEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_TOUCH_CANCEL:
          <span class="hljs-keyword">case</span> TOP_TOUCH_END:
          <span class="hljs-keyword">case</span> TOP_TOUCH_MOVE:
          <span class="hljs-keyword">case</span> TOP_TOUCH_START:
            EventConstructor = SyntheticTouchEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_ANIMATION_END:
          <span class="hljs-keyword">case</span> TOP_ANIMATION_ITERATION:
          <span class="hljs-keyword">case</span> TOP_ANIMATION_START:
            EventConstructor = SyntheticAnimationEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_TRANSITION_END:
            EventConstructor = SyntheticTransitionEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_SCROLL:
            EventConstructor = SyntheticUIEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_WHEEL:
            EventConstructor = SyntheticWheelEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_COPY:
          <span class="hljs-keyword">case</span> TOP_CUT:
          <span class="hljs-keyword">case</span> TOP_PASTE:
            EventConstructor = SyntheticClipboardEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> TOP_GOT_POINTER_CAPTURE:
          <span class="hljs-keyword">case</span> TOP_LOST_POINTER_CAPTURE:
          <span class="hljs-keyword">case</span> TOP_POINTER_CANCEL:
          <span class="hljs-keyword">case</span> TOP_POINTER_DOWN:
          <span class="hljs-keyword">case</span> TOP_POINTER_MOVE:
          <span class="hljs-keyword">case</span> TOP_POINTER_OUT:
          <span class="hljs-keyword">case</span> TOP_POINTER_OVER:
          <span class="hljs-keyword">case</span> TOP_POINTER_UP:
            EventConstructor = SyntheticPointerEvent;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
            {
              <span class="hljs-keyword">if</span> (knownHTMLTopLevelTypes.indexOf(topLevelType) === <span class="hljs-number">-1</span>) {
                error(<span class="hljs-string">'SimpleEventPlugin: Unhandled event type, `%s`. This warning '</span> + <span class="hljs-string">'is likely caused by a bug in React. Please file an issue.'</span>, topLevelType);
              }
            } <span class="hljs-comment">// HTML Events</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-648" id="section-648"></a>
</div>
<p>@see http://www.w3.org/TR/html5/index.html#events-0</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            EventConstructor = SyntheticEvent;
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
        accumulateTwoPhaseDispatches(event);
        <span class="hljs-keyword">return</span> event;
      }
    };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-649" id="section-649"></a>
</div>
<div class="dox">
<div class="summary">
<p>Specifies a deterministic ordering of <code>EventPlugin</code>s. A convenient way to
reason about plugins, without having to package every one of them. This
is better than having plugins be ordered in the same order that they
are injected because that ordering would be influenced by the packaging order.
<code>ResponderEventPlugin</code> must occur before <code>SimpleEventPlugin</code> so that
preventing default on events is convenient in <code>SimpleEventPlugin</code> handlers.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> DOMEventPluginOrder = [<span class="hljs-string">'ResponderEventPlugin'</span>, <span class="hljs-string">'SimpleEventPlugin'</span>, <span class="hljs-string">'EnterLeaveEventPlugin'</span>, <span class="hljs-string">'ChangeEventPlugin'</span>, <span class="hljs-string">'SelectEventPlugin'</span>, <span class="hljs-string">'BeforeInputEventPlugin'</span>];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-650" id="section-650"></a>
</div>
<div class="dox">
<div class="summary">
<p>Inject modules for resolving DOM hierarchy and plugin ordering.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    injectEventPluginOrder(DOMEventPluginOrder);
    setComponentTree(getFiberCurrentPropsFromNode$<span class="hljs-number">1</span>, getInstanceFromNode$<span class="hljs-number">1</span>, getNodeFromInstance$<span class="hljs-number">1</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-651" id="section-651"></a>
</div>
<div class="dox">
<div class="summary">
<p>Some important event plugins included by default (without having to require
them).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    injectEventPluginsByName({
      <span class="hljs-attr">SimpleEventPlugin</span>: SimpleEventPlugin,
      <span class="hljs-attr">EnterLeaveEventPlugin</span>: EnterLeaveEventPlugin,
      <span class="hljs-attr">ChangeEventPlugin</span>: ChangeEventPlugin,
      <span class="hljs-attr">SelectEventPlugin</span>: SelectEventPlugin,
      <span class="hljs-attr">BeforeInputEventPlugin</span>: BeforeInputEventPlugin
    }); <span class="hljs-comment">// Prefix measurements so that it's possible to filter them.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-652" id="section-652"></a>
</div>
<p>Longer prefixes are hard to read in DevTools.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> reactEmoji = <span class="hljs-string">"\u269B"</span>;
    <span class="hljs-keyword">var</span> warningEmoji = <span class="hljs-string">"\u26D4"</span>;
    <span class="hljs-keyword">var</span> supportsUserTiming = <span class="hljs-keyword">typeof</span> performance !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> performance.mark === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> performance.clearMarks === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> performance.measure === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> performance.clearMeasures === <span class="hljs-string">'function'</span>; <span class="hljs-comment">// Keep track of current fiber so that we know the path to unwind on pause.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-653" id="section-653"></a>
</div>
<p>TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> currentFiber = <span class="hljs-literal">null</span>; <span class="hljs-comment">// If we're in the middle of user code, which fiber and method is it?</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-654" id="section-654"></a>
</div>
<p>Reusing <code>currentFiber</code> would be confusing for this because user code fiber
can change during commit phase too, but we don't need to unwind it (since
lifecycles in the commit phase don't resemble a tree).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> currentPhase = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> currentPhaseFiber = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Did lifecycle hook schedule an update? This is often a performance problem,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-655" id="section-655"></a>
</div>
<p>so we will keep track of it, and include it in the report.
Track commits caused by cascading updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> isCommitting = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> hasScheduledUpdateInCurrentCommit = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> hasScheduledUpdateInCurrentPhase = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> commitCountInCurrentWorkLoop = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> effectCountInCurrentCommit = <span class="hljs-number">0</span>; <span class="hljs-comment">// to avoid stretch the commit phase with measurement overhead.</span>

    <span class="hljs-keyword">var</span> labelsInCurrentCommit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

    <span class="hljs-keyword">var</span> formatMarkName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">markName</span>) </span>{
      <span class="hljs-keyword">return</span> reactEmoji + <span class="hljs-string">" "</span> + markName;
    };

    <span class="hljs-keyword">var</span> formatLabel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label, warning</span>) </span>{
      <span class="hljs-keyword">var</span> prefix = warning ? warningEmoji + <span class="hljs-string">" "</span> : reactEmoji + <span class="hljs-string">" "</span>;
      <span class="hljs-keyword">var</span> suffix = warning ? <span class="hljs-string">" Warning: "</span> + warning : <span class="hljs-string">''</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> + prefix + label + suffix;
    };

    <span class="hljs-keyword">var</span> beginMark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">markName</span>) </span>{
      performance.mark(formatMarkName(markName));
    };

    <span class="hljs-keyword">var</span> clearMark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">markName</span>) </span>{
      performance.clearMarks(formatMarkName(markName));
    };

    <span class="hljs-keyword">var</span> endMark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label, markName, warning</span>) </span>{
      <span class="hljs-keyword">var</span> formattedMarkName = formatMarkName(markName);
      <span class="hljs-keyword">var</span> formattedLabel = formatLabel(label, warning);

      <span class="hljs-keyword">try</span> {
        performance.measure(formattedLabel, formattedMarkName);
      } <span class="hljs-keyword">catch</span> (err) {} <span class="hljs-comment">// If previous mark was missing for some reason, this will throw.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-656" id="section-656"></a>
</div>
<p>This could only happen if React crashed in an unexpected place earlier.
Don't pile on with more errors.
Clear marks immediately to avoid growing buffer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      performance.clearMarks(formattedMarkName);
      performance.clearMeasures(formattedLabel);
    };

    <span class="hljs-keyword">var</span> getFiberMarkName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">label, debugID</span>) </span>{
      <span class="hljs-keyword">return</span> label + <span class="hljs-string">" (#"</span> + debugID + <span class="hljs-string">")"</span>;
    };

    <span class="hljs-keyword">var</span> getFiberLabel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">componentName, isMounted, phase</span>) </span>{
      <span class="hljs-keyword">if</span> (phase === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-657" id="section-657"></a>
</div>
<p>These are composite component total time measurements.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> componentName + <span class="hljs-string">" ["</span> + (isMounted ? <span class="hljs-string">'update'</span> : <span class="hljs-string">'mount'</span>) + <span class="hljs-string">"]"</span>;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-658" id="section-658"></a>
</div>
<p>Composite component methods.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> componentName + <span class="hljs-string">"."</span> + phase;
      }
    };

    <span class="hljs-keyword">var</span> beginFiberMark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, phase</span>) </span>{
      <span class="hljs-keyword">var</span> componentName = getComponentName(fiber.type) || <span class="hljs-string">'Unknown'</span>;
      <span class="hljs-keyword">var</span> debugID = fiber._debugID;
      <span class="hljs-keyword">var</span> isMounted = fiber.alternate !== <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> label = getFiberLabel(componentName, isMounted, phase);

      <span class="hljs-keyword">if</span> (isCommitting &amp;&amp; labelsInCurrentCommit.has(label)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-659" id="section-659"></a>
</div>
<p>During the commit phase, we don't show duplicate labels because
there is a fixed overhead for every measurement, and we don't
want to stretch the commit phase beyond necessary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      labelsInCurrentCommit.add(label);
      <span class="hljs-keyword">var</span> markName = getFiberMarkName(label, debugID);
      beginMark(markName);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };

    <span class="hljs-keyword">var</span> clearFiberMark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, phase</span>) </span>{
      <span class="hljs-keyword">var</span> componentName = getComponentName(fiber.type) || <span class="hljs-string">'Unknown'</span>;
      <span class="hljs-keyword">var</span> debugID = fiber._debugID;
      <span class="hljs-keyword">var</span> isMounted = fiber.alternate !== <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> label = getFiberLabel(componentName, isMounted, phase);
      <span class="hljs-keyword">var</span> markName = getFiberMarkName(label, debugID);
      clearMark(markName);
    };

    <span class="hljs-keyword">var</span> endFiberMark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, phase, warning</span>) </span>{
      <span class="hljs-keyword">var</span> componentName = getComponentName(fiber.type) || <span class="hljs-string">'Unknown'</span>;
      <span class="hljs-keyword">var</span> debugID = fiber._debugID;
      <span class="hljs-keyword">var</span> isMounted = fiber.alternate !== <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> label = getFiberLabel(componentName, isMounted, phase);
      <span class="hljs-keyword">var</span> markName = getFiberMarkName(label, debugID);
      endMark(label, markName, warning);
    };

    <span class="hljs-keyword">var</span> shouldIgnoreFiber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-660" id="section-660"></a>
</div>
<p>Host components should be skipped in the timeline.
We could check typeof fiber.type, but does this work with RN?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">switch</span> (fiber.tag) {
        <span class="hljs-keyword">case</span> HostRoot:
        <span class="hljs-keyword">case</span> HostComponent:
        <span class="hljs-keyword">case</span> HostText:
        <span class="hljs-keyword">case</span> HostPortal:
        <span class="hljs-keyword">case</span> Fragment:
        <span class="hljs-keyword">case</span> ContextProvider:
        <span class="hljs-keyword">case</span> ContextConsumer:
        <span class="hljs-keyword">case</span> Mode:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    };

    <span class="hljs-keyword">var</span> clearPendingPhaseMeasurement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (currentPhase !== <span class="hljs-literal">null</span> &amp;&amp; currentPhaseFiber !== <span class="hljs-literal">null</span>) {
        clearFiberMark(currentPhaseFiber, currentPhase);
      }

      currentPhaseFiber = <span class="hljs-literal">null</span>;
      currentPhase = <span class="hljs-literal">null</span>;
      hasScheduledUpdateInCurrentPhase = <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">var</span> pauseTimers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-661" id="section-661"></a>
</div>
<p>Stops all currently active measurements so that they can be resumed
if we continue in a later deferred loop from the same unit of work.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> fiber = currentFiber;

      <span class="hljs-keyword">while</span> (fiber) {
        <span class="hljs-keyword">if</span> (fiber._debugIsCurrentlyTiming) {
          endFiberMark(fiber, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
        }

        fiber = fiber.return;
      }
    };

    <span class="hljs-keyword">var</span> resumeTimersRecursively = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (fiber.return !== <span class="hljs-literal">null</span>) {
        resumeTimersRecursively(fiber.return);
      }

      <span class="hljs-keyword">if</span> (fiber._debugIsCurrentlyTiming) {
        beginFiberMark(fiber, <span class="hljs-literal">null</span>);
      }
    };

    <span class="hljs-keyword">var</span> resumeTimers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-662" id="section-662"></a>
</div>
<p>Resumes all measurements that were active during the last deferred loop.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (currentFiber !== <span class="hljs-literal">null</span>) {
        resumeTimersRecursively(currentFiber);
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recordEffect</span>(<span class="hljs-params"></span>) </span>{
      {
        effectCountInCurrentCommit++;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recordScheduleUpdate</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (isCommitting) {
          hasScheduledUpdateInCurrentCommit = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (currentPhase !== <span class="hljs-literal">null</span> &amp;&amp; currentPhase !== <span class="hljs-string">'componentWillMount'</span> &amp;&amp; currentPhase !== <span class="hljs-string">'componentWillReceiveProps'</span>) {
          hasScheduledUpdateInCurrentPhase = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWorkTimer</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// If we pause, this is the fiber to unwind from.</span>


        currentFiber = fiber;

        <span class="hljs-keyword">if</span> (!beginFiberMark(fiber, <span class="hljs-literal">null</span>)) {
          <span class="hljs-keyword">return</span>;
        }

        fiber._debugIsCurrentlyTiming = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancelWorkTimer</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// Remember we shouldn't complete measurement for this fiber.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-663" id="section-663"></a>
</div>
<p>Otherwise flamechart will be deep even for small updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        fiber._debugIsCurrentlyTiming = <span class="hljs-literal">false</span>;
        clearFiberMark(fiber, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopWorkTimer</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// If we pause, its parent is the fiber to unwind from.</span>


        currentFiber = fiber.return;

        <span class="hljs-keyword">if</span> (!fiber._debugIsCurrentlyTiming) {
          <span class="hljs-keyword">return</span>;
        }

        fiber._debugIsCurrentlyTiming = <span class="hljs-literal">false</span>;
        endFiberMark(fiber, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopFailedWorkTimer</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// If we pause, its parent is the fiber to unwind from.</span>


        currentFiber = fiber.return;

        <span class="hljs-keyword">if</span> (!fiber._debugIsCurrentlyTiming) {
          <span class="hljs-keyword">return</span>;
        }

        fiber._debugIsCurrentlyTiming = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> warning = fiber.tag === SuspenseComponent ? <span class="hljs-string">'Rendering was suspended'</span> : <span class="hljs-string">'An error was thrown inside this error boundary'</span>;
        endFiberMark(fiber, <span class="hljs-literal">null</span>, warning);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startPhaseTimer</span>(<span class="hljs-params">fiber, phase</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        clearPendingPhaseMeasurement();

        <span class="hljs-keyword">if</span> (!beginFiberMark(fiber, phase)) {
          <span class="hljs-keyword">return</span>;
        }

        currentPhaseFiber = fiber;
        currentPhase = phase;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopPhaseTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (currentPhase !== <span class="hljs-literal">null</span> &amp;&amp; currentPhaseFiber !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> warning = hasScheduledUpdateInCurrentPhase ? <span class="hljs-string">'Scheduled a cascading update'</span> : <span class="hljs-literal">null</span>;
          endFiberMark(currentPhaseFiber, currentPhase, warning);
        }

        currentPhase = <span class="hljs-literal">null</span>;
        currentPhaseFiber = <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWorkLoopTimer</span>(<span class="hljs-params">nextUnitOfWork</span>) </span>{
      {
        currentFiber = nextUnitOfWork;

        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        commitCountInCurrentWorkLoop = <span class="hljs-number">0</span>; <span class="hljs-comment">// This is top level call.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-664" id="section-664"></a>
</div>
<p>Any other measurements are performed within.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        beginMark(<span class="hljs-string">'(React Tree Reconciliation)'</span>); <span class="hljs-comment">// Resume any measurements that were in progress during the last loop.</span>

        resumeTimers();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopWorkLoopTimer</span>(<span class="hljs-params">interruptedBy, didCompleteRoot</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> warning = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (interruptedBy !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (interruptedBy.tag === HostRoot) {
            warning = <span class="hljs-string">'A top-level update interrupted the previous render'</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> componentName = getComponentName(interruptedBy.type) || <span class="hljs-string">'Unknown'</span>;
            warning = <span class="hljs-string">"An update to "</span> + componentName + <span class="hljs-string">" interrupted the previous render"</span>;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (commitCountInCurrentWorkLoop &gt; <span class="hljs-number">1</span>) {
          warning = <span class="hljs-string">'There were cascading updates'</span>;
        }

        commitCountInCurrentWorkLoop = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> label = didCompleteRoot ? <span class="hljs-string">'(React Tree Reconciliation: Completed Root)'</span> : <span class="hljs-string">'(React Tree Reconciliation: Yielded)'</span>; <span class="hljs-comment">// Pause any measurements until the next loop.</span>

        pauseTimers();
        endMark(label, <span class="hljs-string">'(React Tree Reconciliation)'</span>, warning);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startCommitTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        isCommitting = <span class="hljs-literal">true</span>;
        hasScheduledUpdateInCurrentCommit = <span class="hljs-literal">false</span>;
        labelsInCurrentCommit.clear();
        beginMark(<span class="hljs-string">'(Committing Changes)'</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopCommitTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> warning = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (hasScheduledUpdateInCurrentCommit) {
          warning = <span class="hljs-string">'Lifecycle hook scheduled a cascading update'</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (commitCountInCurrentWorkLoop &gt; <span class="hljs-number">0</span>) {
          warning = <span class="hljs-string">'Caused by a cascading update in earlier commit'</span>;
        }

        hasScheduledUpdateInCurrentCommit = <span class="hljs-literal">false</span>;
        commitCountInCurrentWorkLoop++;
        isCommitting = <span class="hljs-literal">false</span>;
        labelsInCurrentCommit.clear();
        endMark(<span class="hljs-string">'(Committing Changes)'</span>, <span class="hljs-string">'(Committing Changes)'</span>, warning);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startCommitSnapshotEffectsTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        effectCountInCurrentCommit = <span class="hljs-number">0</span>;
        beginMark(<span class="hljs-string">'(Committing Snapshot Effects)'</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopCommitSnapshotEffectsTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = <span class="hljs-number">0</span>;
        endMark(<span class="hljs-string">"(Committing Snapshot Effects: "</span> + count + <span class="hljs-string">" Total)"</span>, <span class="hljs-string">'(Committing Snapshot Effects)'</span>, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startCommitHostEffectsTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        effectCountInCurrentCommit = <span class="hljs-number">0</span>;
        beginMark(<span class="hljs-string">'(Committing Host Effects)'</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopCommitHostEffectsTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = <span class="hljs-number">0</span>;
        endMark(<span class="hljs-string">"(Committing Host Effects: "</span> + count + <span class="hljs-string">" Total)"</span>, <span class="hljs-string">'(Committing Host Effects)'</span>, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startCommitLifeCyclesTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        effectCountInCurrentCommit = <span class="hljs-number">0</span>;
        beginMark(<span class="hljs-string">'(Calling Lifecycle Methods)'</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopCommitLifeCyclesTimer</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!supportsUserTiming) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = <span class="hljs-number">0</span>;
        endMark(<span class="hljs-string">"(Calling Lifecycle Methods: "</span> + count + <span class="hljs-string">" Total)"</span>, <span class="hljs-string">'(Calling Lifecycle Methods)'</span>, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-keyword">var</span> valueStack = [];
    <span class="hljs-keyword">var</span> fiberStack;
    {
      fiberStack = [];
    }
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">-1</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCursor</span>(<span class="hljs-params">defaultValue</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">current</span>: defaultValue
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params">cursor, fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) {
        {
          error(<span class="hljs-string">'Unexpected pop.'</span>);
        }
        <span class="hljs-keyword">return</span>;
      }

      {
        <span class="hljs-keyword">if</span> (fiber !== fiberStack[index]) {
          error(<span class="hljs-string">'Unexpected Fiber popped.'</span>);
        }
      }
      cursor.current = valueStack[index];
      valueStack[index] = <span class="hljs-literal">null</span>;
      {
        fiberStack[index] = <span class="hljs-literal">null</span>;
      }
      index--;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">cursor, value, fiber</span>) </span>{
      index++;
      valueStack[index] = cursor.current;
      {
        fiberStack[index] = fiber;
      }
      cursor.current = value;
    }

    <span class="hljs-keyword">var</span> warnedAboutMissingGetChildContext;
    {
      warnedAboutMissingGetChildContext = {};
    }
    <span class="hljs-keyword">var</span> emptyContextObject = {};
    {
      <span class="hljs-built_in">Object</span>.freeze(emptyContextObject);
    } <span class="hljs-comment">// A cursor to the current merged context object on the stack.</span>

    <span class="hljs-keyword">var</span> contextStackCursor = createCursor(emptyContextObject); <span class="hljs-comment">// A cursor to a boolean indicating whether the context has changed.</span>

    <span class="hljs-keyword">var</span> didPerformWorkStackCursor = createCursor(<span class="hljs-literal">false</span>); <span class="hljs-comment">// Keep track of the previous context object that was on the stack.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-665" id="section-665"></a>
</div>
<p>We use this to get access to the parent context after we have already
pushed the next context provider, and now need to merge their contexts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> previousContext = emptyContextObject;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUnmaskedContext</span>(<span class="hljs-params">workInProgress, Component, didPushOwnContextIfProvider</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (didPushOwnContextIfProvider &amp;&amp; isContextProvider(Component)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-666" id="section-666"></a>
</div>
<p>If the fiber is a context provider itself, when we read its context
we may have already pushed its own child context on the stack. A context
provider should not &quot;see&quot; its own child context. Therefore we read the
previous (parent) context instead for a context provider.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> previousContext;
        }

        <span class="hljs-keyword">return</span> contextStackCursor.current;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cacheContext</span>(<span class="hljs-params">workInProgress, unmaskedContext, maskedContext</span>) </span>{
      {
        <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMaskedContext</span>(<span class="hljs-params">workInProgress, unmaskedContext</span>) </span>{
      {
        <span class="hljs-keyword">var</span> type = workInProgress.type;
        <span class="hljs-keyword">var</span> contextTypes = type.contextTypes;

        <span class="hljs-keyword">if</span> (!contextTypes) {
          <span class="hljs-keyword">return</span> emptyContextObject;
        } <span class="hljs-comment">// Avoid recreating masked context unless unmasked context has changed.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-667" id="section-667"></a>
</div>
<p>Failing to do this will result in unnecessary calls to componentWillReceiveProps.
This may trigger infinite loops if componentWillReceiveProps calls setState.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;

        <span class="hljs-keyword">if</span> (instance &amp;&amp; instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
          <span class="hljs-keyword">return</span> instance.__reactInternalMemoizedMaskedChildContext;
        }

        <span class="hljs-keyword">var</span> context = {};

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> contextTypes) {
          context[key] = unmaskedContext[key];
        }

        {
          <span class="hljs-keyword">var</span> name = getComponentName(type) || <span class="hljs-string">'Unknown'</span>;
          checkPropTypes(contextTypes, context, <span class="hljs-string">'context'</span>, name, getCurrentFiberStackInDev);
        } <span class="hljs-comment">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-668" id="section-668"></a>
</div>
<p>Context is created before the class component is instantiated so check for instance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (instance) {
          cacheContext(workInProgress, unmaskedContext, context);
        }

        <span class="hljs-keyword">return</span> context;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasContextChanged</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">return</span> didPerformWorkStackCursor.current;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isContextProvider</span>(<span class="hljs-params">type</span>) </span>{
      {
        <span class="hljs-keyword">var</span> childContextTypes = type.childContextTypes;
        <span class="hljs-keyword">return</span> childContextTypes !== <span class="hljs-literal">null</span> &amp;&amp; childContextTypes !== <span class="hljs-literal">undefined</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popContext</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popTopLevelContextObject</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushTopLevelContextObject</span>(<span class="hljs-params">fiber, context, didChange</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (!(contextStackCursor.current === emptyContextObject)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }

        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processChildContext</span>(<span class="hljs-params">fiber, type, parentContext</span>) </span>{
      {
        <span class="hljs-keyword">var</span> instance = fiber.stateNode;
        <span class="hljs-keyword">var</span> childContextTypes = type.childContextTypes; <span class="hljs-comment">// TODO (bvaughn) Replace this behavior with an invariant() in the future.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-669" id="section-669"></a>
</div>
<p>It has only been added in Fiber to match the (unintentional) behavior in Stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getChildContext !== <span class="hljs-string">'function'</span>) {
          {
            <span class="hljs-keyword">var</span> componentName = getComponentName(type) || <span class="hljs-string">'Unknown'</span>;

            <span class="hljs-keyword">if</span> (!warnedAboutMissingGetChildContext[componentName]) {
              warnedAboutMissingGetChildContext[componentName] = <span class="hljs-literal">true</span>;
              error(<span class="hljs-string">'%s.childContextTypes is specified but there is no getChildContext() method '</span> + <span class="hljs-string">'on the instance. You can either define getChildContext() on %s or remove '</span> + <span class="hljs-string">'childContextTypes from it.'</span>, componentName, componentName);
            }
          }
          <span class="hljs-keyword">return</span> parentContext;
        }

        <span class="hljs-keyword">var</span> childContext;
        startPhaseTimer(fiber, <span class="hljs-string">'getChildContext'</span>);
        childContext = instance.getChildContext();
        stopPhaseTimer();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> contextKey <span class="hljs-keyword">in</span> childContext) {
          <span class="hljs-keyword">if</span> (!(contextKey <span class="hljs-keyword">in</span> childContextTypes)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>((getComponentName(type) || <span class="hljs-string">'Unknown'</span>) + <span class="hljs-string">".getChildContext(): key \""</span> + contextKey + <span class="hljs-string">"\" is not defined in childContextTypes."</span>);
            }
          }
        }

        {
          <span class="hljs-keyword">var</span> name = getComponentName(type) || <span class="hljs-string">'Unknown'</span>;
          checkPropTypes(childContextTypes, childContext, <span class="hljs-string">'child context'</span>, name, <span class="hljs-comment">// In practice, there is one case in which we won't get a stack. It's when</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-670" id="section-670"></a>
</div>
<p>somebody calls unstable_renderSubtreeIntoContainer() and we process
context from the parent component instance. The stack will be missing
because it's outside of the reconciliation, and so the pointer has not
been set. This is rare and doesn't matter. We'll also remove that API.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          getCurrentFiberStackInDev);
        }
        <span class="hljs-keyword">return</span> _assign({}, parentContext, {}, childContext);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushContextProvider</span>(<span class="hljs-params">workInProgress</span>) </span>{
      {
        <span class="hljs-keyword">var</span> instance = workInProgress.stateNode; <span class="hljs-comment">// We push the context as early as possible to ensure stack integrity.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-671" id="section-671"></a>
</div>
<p>If the instance does not exist yet, we will push null at first,
and replace it on the stack later when invalidating the context.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">var</span> memoizedMergedChildContext = instance &amp;&amp; instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; <span class="hljs-comment">// Remember the parent context so we can merge with it later.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-672" id="section-672"></a>
</div>
<p>Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invalidateContextProvider</span>(<span class="hljs-params">workInProgress, type, didChange</span>) </span>{
      {
        <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;

        <span class="hljs-keyword">if</span> (!instance) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }

        <span class="hljs-keyword">if</span> (didChange) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-673" id="section-673"></a>
</div>
<p>Merge parent and own context.
Skip this if we're not updating due to sCU.
This avoids unnecessarily recomputing memoized values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> mergedContext = processChildContext(workInProgress, type, previousContext);
          instance.__reactInternalMemoizedMergedChildContext = mergedContext; <span class="hljs-comment">// Replace the old (or empty) context with the new one.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-674" id="section-674"></a>
</div>
<p>It is important to unwind the context in the reverse order.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          pop(didPerformWorkStackCursor, workInProgress);
          pop(contextStackCursor, workInProgress); <span class="hljs-comment">// Now push the new context and mark that it has changed.</span>

          push(contextStackCursor, mergedContext, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        } <span class="hljs-keyword">else</span> {
          pop(didPerformWorkStackCursor, workInProgress);
          push(didPerformWorkStackCursor, didChange, workInProgress);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findCurrentUnmaskedContext</span>(<span class="hljs-params">fiber</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-675" id="section-675"></a>
</div>
<p>Currently this is only used with renderSubtreeIntoContainer; not sure if it
makes sense elsewhere</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!(isFiberMounted(fiber) &amp;&amp; fiber.tag === ClassComponent)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }

        <span class="hljs-keyword">var</span> node = fiber;

        <span class="hljs-keyword">do</span> {
          <span class="hljs-keyword">switch</span> (node.tag) {
            <span class="hljs-keyword">case</span> HostRoot:
              <span class="hljs-keyword">return</span> node.stateNode.context;

            <span class="hljs-keyword">case</span> ClassComponent:
              {
                <span class="hljs-keyword">var</span> Component = node.type;

                <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
                  <span class="hljs-keyword">return</span> node.stateNode.__reactInternalMemoizedMergedChildContext;
                }

                <span class="hljs-keyword">break</span>;
              }
          }

          node = node.return;
        } <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>);

        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }
      }
    }

    <span class="hljs-keyword">var</span> LegacyRoot = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> BlockingRoot = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> ConcurrentRoot = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
        Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
        Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
        Scheduler_shouldYield = Scheduler.unstable_shouldYield,
        Scheduler_requestPaint = Scheduler.unstable_requestPaint,
        Scheduler_now = Scheduler.unstable_now,
        Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
        Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
        Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
        Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
        Scheduler_LowPriority = Scheduler.unstable_LowPriority,
        Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
    {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-676" id="section-676"></a>
</div>
<p>Provide explicit error message when production+profiling bundle of e.g.
react-dom is used with production (non-profiling) bundle of
scheduler/tracing</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (!(tracing.__interactionsRef != <span class="hljs-literal">null</span> &amp;&amp; tracing.__interactionsRef.current != <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling"</span>);
        }
      }
    }
    <span class="hljs-keyword">var</span> fakeCallbackNode = {}; <span class="hljs-comment">// Except for NoPriority, these correspond to Scheduler priorities. We use</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-677" id="section-677"></a>
</div>
<p>ascending numbers so we can compare them like numbers. They start at 90 to
avoid clashing with Scheduler's priorities.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> ImmediatePriority = <span class="hljs-number">99</span>;
    <span class="hljs-keyword">var</span> UserBlockingPriority$<span class="hljs-number">1</span> = <span class="hljs-number">98</span>;
    <span class="hljs-keyword">var</span> NormalPriority = <span class="hljs-number">97</span>;
    <span class="hljs-keyword">var</span> LowPriority = <span class="hljs-number">96</span>;
    <span class="hljs-keyword">var</span> IdlePriority = <span class="hljs-number">95</span>; <span class="hljs-comment">// NoPriority is the absence of priority. Also React-only.</span>

    <span class="hljs-keyword">var</span> NoPriority = <span class="hljs-number">90</span>;
    <span class="hljs-keyword">var</span> shouldYield = Scheduler_shouldYield;
    <span class="hljs-keyword">var</span> requestPaint = <span class="hljs-comment">// Fall back gracefully if we're running an older version of Scheduler.</span>
    Scheduler_requestPaint !== <span class="hljs-literal">undefined</span> ? Scheduler_requestPaint : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
    <span class="hljs-keyword">var</span> syncQueue = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> immediateQueueCallbackNode = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> isFlushingSyncQueue = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> initialTimeMs = Scheduler_now(); <span class="hljs-comment">// If the initial timestamp is reasonably small, use Scheduler's `now` directly.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-678" id="section-678"></a>
</div>
<p>This will be the case for modern browsers that support <code>performance.now</code>. In
older browsers, Scheduler falls back to <code>Date.now</code>, which returns a Unix
timestamp. In that case, subtract the module initialization time to simulate
the behavior of performance.now and keep our times small enough to fit
within 32 bits.
TODO: Consider lifting this into Scheduler.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> now = initialTimeMs &lt; <span class="hljs-number">10000</span> ? Scheduler_now : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> Scheduler_now() - initialTimeMs;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrentPriorityLevel</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">switch</span> (Scheduler_getCurrentPriorityLevel()) {
        <span class="hljs-keyword">case</span> Scheduler_ImmediatePriority:
          <span class="hljs-keyword">return</span> ImmediatePriority;

        <span class="hljs-keyword">case</span> Scheduler_UserBlockingPriority:
          <span class="hljs-keyword">return</span> UserBlockingPriority$<span class="hljs-number">1</span>;

        <span class="hljs-keyword">case</span> Scheduler_NormalPriority:
          <span class="hljs-keyword">return</span> NormalPriority;

        <span class="hljs-keyword">case</span> Scheduler_LowPriority:
          <span class="hljs-keyword">return</span> LowPriority;

        <span class="hljs-keyword">case</span> Scheduler_IdlePriority:
          <span class="hljs-keyword">return</span> IdlePriority;

        <span class="hljs-keyword">default</span>:
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown priority level."</span>);
            }
          }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactPriorityToSchedulerPriority</span>(<span class="hljs-params">reactPriorityLevel</span>) </span>{
      <span class="hljs-keyword">switch</span> (reactPriorityLevel) {
        <span class="hljs-keyword">case</span> ImmediatePriority:
          <span class="hljs-keyword">return</span> Scheduler_ImmediatePriority;

        <span class="hljs-keyword">case</span> UserBlockingPriority$<span class="hljs-number">1</span>:
          <span class="hljs-keyword">return</span> Scheduler_UserBlockingPriority;

        <span class="hljs-keyword">case</span> NormalPriority:
          <span class="hljs-keyword">return</span> Scheduler_NormalPriority;

        <span class="hljs-keyword">case</span> LowPriority:
          <span class="hljs-keyword">return</span> Scheduler_LowPriority;

        <span class="hljs-keyword">case</span> IdlePriority:
          <span class="hljs-keyword">return</span> Scheduler_IdlePriority;

        <span class="hljs-keyword">default</span>:
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown priority level."</span>);
            }
          }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runWithPriority$1</span>(<span class="hljs-params">reactPriorityLevel, fn</span>) </span>{
      <span class="hljs-keyword">var</span> priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
      <span class="hljs-keyword">return</span> Scheduler_runWithPriority(priorityLevel, fn);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleCallback</span>(<span class="hljs-params">reactPriorityLevel, callback, options</span>) </span>{
      <span class="hljs-keyword">var</span> priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
      <span class="hljs-keyword">return</span> Scheduler_scheduleCallback(priorityLevel, callback, options);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleSyncCallback</span>(<span class="hljs-params">callback</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-679" id="section-679"></a>
</div>
<p>Push this callback into an internal queue. We'll flush these either in
the next tick, or earlier if something calls <code>flushSyncCallbackQueue</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) {
        syncQueue = [callback]; <span class="hljs-comment">// Flush the queue in the next tick, at the earliest.</span>

        immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-680" id="section-680"></a>
</div>
<p>Push onto existing queue. Don't need to schedule a callback because
we already scheduled one when we created the queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        syncQueue.push(callback);
      }

      <span class="hljs-keyword">return</span> fakeCallbackNode;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancelCallback</span>(<span class="hljs-params">callbackNode</span>) </span>{
      <span class="hljs-keyword">if</span> (callbackNode !== fakeCallbackNode) {
        Scheduler_cancelCallback(callbackNode);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSyncCallbackQueue</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (immediateQueueCallbackNode !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> node = immediateQueueCallbackNode;
        immediateQueueCallbackNode = <span class="hljs-literal">null</span>;
        Scheduler_cancelCallback(node);
      }

      flushSyncCallbackQueueImpl();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSyncCallbackQueueImpl</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!isFlushingSyncQueue &amp;&amp; syncQueue !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-681" id="section-681"></a>
</div>
<p>Prevent re-entrancy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        isFlushingSyncQueue = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> _isSync = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">var</span> queue = syncQueue;
          runWithPriority$<span class="hljs-number">1</span>(ImmediatePriority, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">for</span> (; i &lt; queue.length; i++) {
              <span class="hljs-keyword">var</span> callback = queue[i];

              <span class="hljs-keyword">do</span> {
                callback = callback(_isSync);
              } <span class="hljs-keyword">while</span> (callback !== <span class="hljs-literal">null</span>);
            }
          });
          syncQueue = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">catch</span> (error) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-682" id="section-682"></a>
</div>
<p>If something throws, leave the remaining callbacks on the queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (syncQueue !== <span class="hljs-literal">null</span>) {
            syncQueue = syncQueue.slice(i + <span class="hljs-number">1</span>);
          } <span class="hljs-comment">// Resume flushing in the next tick</span>


          Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
          <span class="hljs-keyword">throw</span> error;
        } <span class="hljs-keyword">finally</span> {
          isFlushingSyncQueue = <span class="hljs-literal">false</span>;
        }
      }
    }

    <span class="hljs-keyword">var</span> NoMode = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> StrictMode = <span class="hljs-number">1</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove BlockingMode and ConcurrentMode by reading from the root</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-683" id="section-683"></a>
</div>
<p>tag instead</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> BlockingMode = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> ConcurrentMode = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> ProfileMode = <span class="hljs-number">8</span>; <span class="hljs-comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-684" id="section-684"></a>
</div>
<p>Math.pow(2, 30) - 1
0b111111111111111111111111111111</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> MAX_SIGNED_31_BIT_INT = <span class="hljs-number">1073741823</span>;
    <span class="hljs-keyword">var</span> NoWork = <span class="hljs-number">0</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think of a better name for Never. The key difference with Idle is that</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-685" id="section-685"></a>
</div>
<p>Never work can be committed in an inconsistent state without tearing the UI.
The main example is offscreen content, like a hidden subtree. So one possible
name is Offscreen. However, it also includes dehydrated Suspense boundaries,
which are inconsistent in the sense that they haven't finished yet, but
aren't visibly inconsistent because the server rendered HTML matches what the
hydrated tree would look like.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> Never = <span class="hljs-number">1</span>; <span class="hljs-comment">// Idle is slightly higher priority than Never. It must completely finish in</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-686" id="section-686"></a>
</div>
<p>order to be consistent.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> Idle = <span class="hljs-number">2</span>; <span class="hljs-comment">// Continuous Hydration is slightly higher than Idle and is used to increase</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-687" id="section-687"></a>
</div>
<p>priority of hover targets.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> ContinuousHydration = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> Sync = MAX_SIGNED_31_BIT_INT;
    <span class="hljs-keyword">var</span> Batched = Sync - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> UNIT_SIZE = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">var</span> MAGIC_NUMBER_OFFSET = Batched - <span class="hljs-number">1</span>; <span class="hljs-comment">// 1 unit of expiration time represents 10ms.</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msToExpirationTime</span>(<span class="hljs-params">ms</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-688" id="section-688"></a>
</div>
<p>Always subtract from the offset so that we don't clash with the magic number for NoWork.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | <span class="hljs-number">0</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expirationTimeToMs</span>(<span class="hljs-params">expirationTime</span>) </span>{
      <span class="hljs-keyword">return</span> (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ceiling</span>(<span class="hljs-params">num, precision</span>) </span>{
      <span class="hljs-keyword">return</span> ((num / precision | <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>) * precision;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeExpirationBucket</span>(<span class="hljs-params">currentTime, expirationInMs, bucketSizeMs</span>) </span>{
      <span class="hljs-keyword">return</span> MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This corresponds to Scheduler's NormalPriority, not LowPriority. Update</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-689" id="section-689"></a>
</div>
<p>the names to reflect.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> LOW_PRIORITY_EXPIRATION = <span class="hljs-number">5000</span>;
    <span class="hljs-keyword">var</span> LOW_PRIORITY_BATCH_SIZE = <span class="hljs-number">250</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeAsyncExpiration</span>(<span class="hljs-params">currentTime</span>) </span>{
      <span class="hljs-keyword">return</span> computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeSuspenseExpiration</span>(<span class="hljs-params">currentTime, timeoutMs</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-690" id="section-690"></a>
</div>
<p>TODO: Should we warn if timeoutMs is lower than the normal pri expiration time?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> computeExpirationBucket(currentTime, timeoutMs, LOW_PRIORITY_BATCH_SIZE);
    } <span class="hljs-comment">// We intentionally set a higher expiration time for interactive updates in</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-691" id="section-691"></a>
</div>
<p>dev than in production.</p>
<p>If the main thread is being blocked so long that you hit the expiration,
it's a problem that could be solved with better scheduling.</p>
<p>People will be more likely to notice this and fix it with the long
expiration time in development.</p>
<p>In production we opt for better UX at the risk of masking scheduling
problems, by expiring fast.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> HIGH_PRIORITY_EXPIRATION = <span class="hljs-number">500</span>;
    <span class="hljs-keyword">var</span> HIGH_PRIORITY_BATCH_SIZE = <span class="hljs-number">100</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeInteractiveExpiration</span>(<span class="hljs-params">currentTime</span>) </span>{
      <span class="hljs-keyword">return</span> computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferPriorityFromExpirationTime</span>(<span class="hljs-params">currentTime, expirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (expirationTime === Sync) {
        <span class="hljs-keyword">return</span> ImmediatePriority;
      }

      <span class="hljs-keyword">if</span> (expirationTime === Never || expirationTime === Idle) {
        <span class="hljs-keyword">return</span> IdlePriority;
      }

      <span class="hljs-keyword">var</span> msUntil = expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);

      <span class="hljs-keyword">if</span> (msUntil &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> ImmediatePriority;
      }

      <span class="hljs-keyword">if</span> (msUntil &lt;= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {
        <span class="hljs-keyword">return</span> UserBlockingPriority$<span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">if</span> (msUntil &lt;= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {
        <span class="hljs-keyword">return</span> NormalPriority;
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Handle LowPriority</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-692" id="section-692"></a>
</div>
<p>Assume anything lower has idle priority</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">return</span> IdlePriority;
    }

    <span class="hljs-keyword">var</span> ReactStrictModeWarnings = {
      <span class="hljs-attr">recordUnsafeLifecycleWarnings</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) </span>{},
      <span class="hljs-attr">flushPendingUnsafeLifecycleWarnings</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
      <span class="hljs-attr">recordLegacyContextWarning</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) </span>{},
      <span class="hljs-attr">flushLegacyContextWarning</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
      <span class="hljs-attr">discardPendingWarnings</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
    };
    {
      <span class="hljs-keyword">var</span> findStrictRoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
        <span class="hljs-keyword">var</span> maybeStrictRoot = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> node = fiber;

        <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.mode &amp; StrictMode) {
            maybeStrictRoot = node;
          }

          node = node.return;
        }

        <span class="hljs-keyword">return</span> maybeStrictRoot;
      };

      <span class="hljs-keyword">var</span> setToSortedString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">set</span>) </span>{
        <span class="hljs-keyword">var</span> array = [];
        <span class="hljs-keyword">set</span>.forEach(function (value) {
          array.push(value);
        });
        <span class="hljs-keyword">return</span> array.sort().join(<span class="hljs-string">', '</span>);
      };

      <span class="hljs-keyword">var</span> pendingComponentWillMountWarnings = [];
      <span class="hljs-keyword">var</span> pendingUNSAFE_ComponentWillMountWarnings = [];
      <span class="hljs-keyword">var</span> pendingComponentWillReceivePropsWarnings = [];
      <span class="hljs-keyword">var</span> pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      <span class="hljs-keyword">var</span> pendingComponentWillUpdateWarnings = [];
      <span class="hljs-keyword">var</span> pendingUNSAFE_ComponentWillUpdateWarnings = []; <span class="hljs-comment">// Tracks components we have already warned about.</span>

      <span class="hljs-keyword">var</span> didWarnAboutUnsafeLifecycles = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-693" id="section-693"></a>
</div>
<p>Dedup strategy: Warn once per component.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillMount === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-comment">// Don't warn about react-lifecycles-compat polyfilled components.</span>
        instance.componentWillMount.__suppressDeprecationWarning !== <span class="hljs-literal">true</span>) {
          pendingComponentWillMountWarnings.push(fiber);
        }

        <span class="hljs-keyword">if</span> (fiber.mode &amp; StrictMode &amp;&amp; <span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="hljs-string">'function'</span>) {
          pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillReceiveProps === <span class="hljs-string">'function'</span> &amp;&amp; instance.componentWillReceiveProps.__suppressDeprecationWarning !== <span class="hljs-literal">true</span>) {
          pendingComponentWillReceivePropsWarnings.push(fiber);
        }

        <span class="hljs-keyword">if</span> (fiber.mode &amp; StrictMode &amp;&amp; <span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillReceiveProps === <span class="hljs-string">'function'</span>) {
          pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillUpdate === <span class="hljs-string">'function'</span> &amp;&amp; instance.componentWillUpdate.__suppressDeprecationWarning !== <span class="hljs-literal">true</span>) {
          pendingComponentWillUpdateWarnings.push(fiber);
        }

        <span class="hljs-keyword">if</span> (fiber.mode &amp; StrictMode &amp;&amp; <span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillUpdate === <span class="hljs-string">'function'</span>) {
          pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
        }
      };

      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-694" id="section-694"></a>
</div>
<p>We do an initial pass to gather component names</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> componentWillMountUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

        <span class="hljs-keyword">if</span> (pendingComponentWillMountWarnings.length &gt; <span class="hljs-number">0</span>) {
          pendingComponentWillMountWarnings.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
            componentWillMountUniqueNames.add(getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>);
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });
          pendingComponentWillMountWarnings = [];
        }

        <span class="hljs-keyword">var</span> UNSAFE_componentWillMountUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

        <span class="hljs-keyword">if</span> (pendingUNSAFE_ComponentWillMountWarnings.length &gt; <span class="hljs-number">0</span>) {
          pendingUNSAFE_ComponentWillMountWarnings.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
            UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>);
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });
          pendingUNSAFE_ComponentWillMountWarnings = [];
        }

        <span class="hljs-keyword">var</span> componentWillReceivePropsUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

        <span class="hljs-keyword">if</span> (pendingComponentWillReceivePropsWarnings.length &gt; <span class="hljs-number">0</span>) {
          pendingComponentWillReceivePropsWarnings.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
            componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>);
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });
          pendingComponentWillReceivePropsWarnings = [];
        }

        <span class="hljs-keyword">var</span> UNSAFE_componentWillReceivePropsUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

        <span class="hljs-keyword">if</span> (pendingUNSAFE_ComponentWillReceivePropsWarnings.length &gt; <span class="hljs-number">0</span>) {
          pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>);
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        }

        <span class="hljs-keyword">var</span> componentWillUpdateUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

        <span class="hljs-keyword">if</span> (pendingComponentWillUpdateWarnings.length &gt; <span class="hljs-number">0</span>) {
          pendingComponentWillUpdateWarnings.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
            componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>);
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });
          pendingComponentWillUpdateWarnings = [];
        }

        <span class="hljs-keyword">var</span> UNSAFE_componentWillUpdateUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

        <span class="hljs-keyword">if</span> (pendingUNSAFE_ComponentWillUpdateWarnings.length &gt; <span class="hljs-number">0</span>) {
          pendingUNSAFE_ComponentWillUpdateWarnings.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
            UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>);
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
        } <span class="hljs-comment">// Finally, we flush all the warnings</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-695" id="section-695"></a>
</div>
<p>UNSAFE_ ones before the deprecated ones, since they'll be 'louder'</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (UNSAFE_componentWillMountUniqueNames.size &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
          error(<span class="hljs-string">'Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '</span> + <span class="hljs-string">'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'</span> + <span class="hljs-string">'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'</span> + <span class="hljs-string">'\nPlease update the following components: %s'</span>, sortedNames);
        }

        <span class="hljs-keyword">if</span> (UNSAFE_componentWillReceivePropsUniqueNames.size &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);

          error(<span class="hljs-string">'Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '</span> + <span class="hljs-string">'and may indicate bugs in your code. '</span> + <span class="hljs-string">'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'</span> + <span class="hljs-string">'* Move data fetching code or side effects to componentDidUpdate.\n'</span> + <span class="hljs-string">"* If you're updating state whenever props change, "</span> + <span class="hljs-string">'refactor your code to use memoization techniques or move it to '</span> + <span class="hljs-string">'static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n'</span> + <span class="hljs-string">'\nPlease update the following components: %s'</span>, _sortedNames);
        }

        <span class="hljs-keyword">if</span> (UNSAFE_componentWillUpdateUniqueNames.size &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);

          error(<span class="hljs-string">'Using UNSAFE_componentWillUpdate in strict mode is not recommended '</span> + <span class="hljs-string">'and may indicate bugs in your code. '</span> + <span class="hljs-string">'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'</span> + <span class="hljs-string">'* Move data fetching code or side effects to componentDidUpdate.\n'</span> + <span class="hljs-string">'\nPlease update the following components: %s'</span>, _sortedNames2);
        }

        <span class="hljs-keyword">if</span> (componentWillMountUniqueNames.size &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> _sortedNames3 = setToSortedString(componentWillMountUniqueNames);

          warn(<span class="hljs-string">'componentWillMount has been renamed, and is not recommended for use. '</span> + <span class="hljs-string">'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'</span> + <span class="hljs-string">'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'</span> + <span class="hljs-string">'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '</span> + <span class="hljs-string">'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. '</span> + <span class="hljs-string">'To rename all deprecated lifecycles to their new names, you can run '</span> + <span class="hljs-string">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'</span> + <span class="hljs-string">'\nPlease update the following components: %s'</span>, _sortedNames3);
        }

        <span class="hljs-keyword">if</span> (componentWillReceivePropsUniqueNames.size &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);

          warn(<span class="hljs-string">'componentWillReceiveProps has been renamed, and is not recommended for use. '</span> + <span class="hljs-string">'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'</span> + <span class="hljs-string">'* Move data fetching code or side effects to componentDidUpdate.\n'</span> + <span class="hljs-string">"* If you're updating state whenever props change, refactor your "</span> + <span class="hljs-string">'code to use memoization techniques or move it to '</span> + <span class="hljs-string">'static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n'</span> + <span class="hljs-string">'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '</span> + <span class="hljs-string">'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. '</span> + <span class="hljs-string">'To rename all deprecated lifecycles to their new names, you can run '</span> + <span class="hljs-string">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'</span> + <span class="hljs-string">'\nPlease update the following components: %s'</span>, _sortedNames4);
        }

        <span class="hljs-keyword">if</span> (componentWillUpdateUniqueNames.size &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);

          warn(<span class="hljs-string">'componentWillUpdate has been renamed, and is not recommended for use. '</span> + <span class="hljs-string">'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'</span> + <span class="hljs-string">'* Move data fetching code or side effects to componentDidUpdate.\n'</span> + <span class="hljs-string">'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '</span> + <span class="hljs-string">'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. '</span> + <span class="hljs-string">'To rename all deprecated lifecycles to their new names, you can run '</span> + <span class="hljs-string">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'</span> + <span class="hljs-string">'\nPlease update the following components: %s'</span>, _sortedNames5);
        }
      };

      <span class="hljs-keyword">var</span> pendingLegacyContextWarning = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// Tracks components we have already warned about.</span>

      <span class="hljs-keyword">var</span> didWarnAboutLegacyContext = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

      ReactStrictModeWarnings.recordLegacyContextWarning = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) </span>{
        <span class="hljs-keyword">var</span> strictRoot = findStrictRoot(fiber);

        <span class="hljs-keyword">if</span> (strictRoot === <span class="hljs-literal">null</span>) {
          error(<span class="hljs-string">'Expected to find a StrictMode component in a strict mode tree. '</span> + <span class="hljs-string">'This error is likely caused by a bug in React. Please file an issue.'</span>);
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// Dedup strategy: Warn once per component.</span>


        <span class="hljs-keyword">if</span> (didWarnAboutLegacyContext.has(fiber.type)) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

        <span class="hljs-keyword">if</span> (fiber.type.contextTypes != <span class="hljs-literal">null</span> || fiber.type.childContextTypes != <span class="hljs-literal">null</span> || instance !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.getChildContext === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">if</span> (warningsForRoot === <span class="hljs-literal">undefined</span>) {
            warningsForRoot = [];
            pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
          }

          warningsForRoot.push(fiber);
        }
      };

      ReactStrictModeWarnings.flushLegacyContextWarning = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        pendingLegacyContextWarning.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiberArray, strictRoot</span>) </span>{
          <span class="hljs-keyword">if</span> (fiberArray.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">var</span> firstFiber = fiberArray[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">var</span> uniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
          fiberArray.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
            uniqueNames.add(getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>);
            didWarnAboutLegacyContext.add(fiber.type);
          });
          <span class="hljs-keyword">var</span> sortedNames = setToSortedString(uniqueNames);
          <span class="hljs-keyword">var</span> firstComponentStack = getStackByFiberInDevAndProd(firstFiber);
          error(<span class="hljs-string">'Legacy context API has been detected within a strict-mode tree.'</span> + <span class="hljs-string">'\n\nThe old API will be supported in all 16.x releases, but applications '</span> + <span class="hljs-string">'using it should migrate to the new version.'</span> + <span class="hljs-string">'\n\nPlease update the following components: %s'</span> + <span class="hljs-string">'\n\nLearn more about this warning here: https://fb.me/react-legacy-context'</span> + <span class="hljs-string">'%s'</span>, sortedNames, firstComponentStack);
        });
      };

      ReactStrictModeWarnings.discardPendingWarnings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        pendingComponentWillMountWarnings = [];
        pendingUNSAFE_ComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUNSAFE_ComponentWillUpdateWarnings = [];
        pendingLegacyContextWarning = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
      };
    }
    <span class="hljs-keyword">var</span> resolveFamily = <span class="hljs-literal">null</span>; <span class="hljs-comment">// $FlowFixMe Flow gets confused by a WeakSet feature check below.</span>

    <span class="hljs-keyword">var</span> failedBoundaries = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">var</span> setRefreshHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handler</span>) </span>{
      {
        resolveFamily = handler;
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveFunctionForHotReloading</span>(<span class="hljs-params">type</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-696" id="section-696"></a>
</div>
<p>Hot reloading is disabled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> type;
        }

        <span class="hljs-keyword">var</span> family = resolveFamily(type);

        <span class="hljs-keyword">if</span> (family === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">return</span> type;
        } <span class="hljs-comment">// Use the latest known implementation.</span>


        <span class="hljs-keyword">return</span> family.current;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveClassForHotReloading</span>(<span class="hljs-params">type</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-697" id="section-697"></a>
</div>
<p>No implementation differences.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> resolveFunctionForHotReloading(type);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveForwardRefForHotReloading</span>(<span class="hljs-params">type</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-698" id="section-698"></a>
</div>
<p>Hot reloading is disabled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> type;
        }

        <span class="hljs-keyword">var</span> family = resolveFamily(type);

        <span class="hljs-keyword">if</span> (family === <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-699" id="section-699"></a>
</div>
<p>Check if we're dealing with a real forwardRef. Don't want to crash early.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (type !== <span class="hljs-literal">null</span> &amp;&amp; type !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> type.render === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-700" id="section-700"></a>
</div>
<p>ForwardRef is special because its resolved .type is an object,
but it's possible that we only have its inner render function in the map.
If that inner render function is different, we'll build a new forwardRef type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> currentRender = resolveFunctionForHotReloading(type.render);

            <span class="hljs-keyword">if</span> (type.render !== currentRender) {
              <span class="hljs-keyword">var</span> syntheticType = {
                <span class="hljs-attr">$$typeof</span>: REACT_FORWARD_REF_TYPE,
                <span class="hljs-attr">render</span>: currentRender
              };

              <span class="hljs-keyword">if</span> (type.displayName !== <span class="hljs-literal">undefined</span>) {
                syntheticType.displayName = type.displayName;
              }

              <span class="hljs-keyword">return</span> syntheticType;
            }
          }

          <span class="hljs-keyword">return</span> type;
        } <span class="hljs-comment">// Use the latest known implementation.</span>


        <span class="hljs-keyword">return</span> family.current;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCompatibleFamilyForHotReloading</span>(<span class="hljs-params">fiber, element</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-701" id="section-701"></a>
</div>
<p>Hot reloading is disabled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">var</span> prevType = fiber.elementType;
        <span class="hljs-keyword">var</span> nextType = element.type; <span class="hljs-comment">// If we got here, we know types aren't === equal.</span>

        <span class="hljs-keyword">var</span> needsCompareFamilies = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> $$typeofNextType = <span class="hljs-keyword">typeof</span> nextType === <span class="hljs-string">'object'</span> &amp;&amp; nextType !== <span class="hljs-literal">null</span> ? nextType.$$<span class="hljs-keyword">typeof</span> : <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">switch</span> (fiber.tag) {
          <span class="hljs-keyword">case</span> ClassComponent:
            {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextType === <span class="hljs-string">'function'</span>) {
                needsCompareFamilies = <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> FunctionComponent:
            {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextType === <span class="hljs-string">'function'</span>) {
                needsCompareFamilies = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($$typeofNextType === REACT_LAZY_TYPE) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-702" id="section-702"></a>
</div>
<p>We don't know the inner type yet.
We're going to assume that the lazy inner type is stable,
and so it is sufficient to avoid reconciling it away.
We're not going to unwrap or actually use the new lazy type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                needsCompareFamilies = <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> ForwardRef:
            {
              <span class="hljs-keyword">if</span> ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                needsCompareFamilies = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> MemoComponent:
          <span class="hljs-keyword">case</span> SimpleMemoComponent:
            {
              <span class="hljs-keyword">if</span> ($$typeofNextType === REACT_MEMO_TYPE) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-703" id="section-703"></a>
</div>
<p>TODO: if it was but can no longer be simple,
we shouldn't set this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                needsCompareFamilies = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-attr">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-comment">// Check if both types have a family and it's the same one.</span>


        <span class="hljs-keyword">if</span> (needsCompareFamilies) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-704" id="section-704"></a>
</div>
<p>Note: memo() and forwardRef() we'll compare outer rather than inner type.
This means both of them need to be registered to preserve state.
If we unwrapped and compared the inner types for wrappers instead,
then we would risk falsely saying two separate memo(Foo)
calls are equivalent because they wrap the same Foo function.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> prevFamily = resolveFamily(prevType);

          <span class="hljs-keyword">if</span> (prevFamily !== <span class="hljs-literal">undefined</span> &amp;&amp; prevFamily === resolveFamily(nextType)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markFailedErrorBoundaryForHotReloading</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-705" id="section-705"></a>
</div>
<p>Hot reloading is disabled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">WeakSet</span> !== <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (failedBoundaries === <span class="hljs-literal">null</span>) {
          failedBoundaries = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();
        }

        failedBoundaries.add(fiber);
      }
    }

    <span class="hljs-keyword">var</span> scheduleRefresh = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, update</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-706" id="section-706"></a>
</div>
<p>Hot reloading is disabled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> staleFamilies = update.staleFamilies,
            updatedFamilies = update.updatedFamilies;
        flushPassiveEffects();
        flushSync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
        });
      }
    };

    <span class="hljs-keyword">var</span> scheduleRoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, element</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (root.context !== emptyContextObject) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-707" id="section-707"></a>
</div>
<p>Super edge case: root has a legacy _renderSubtree context
but we don't know the parentComponent so we can't pass it.
Just ignore. We'll delete this with _renderSubtree code path later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        }

        flushPassiveEffects();
        syncUpdates(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          updateContainer(element, root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
        });
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleFibersWithFamiliesRecursively</span>(<span class="hljs-params">fiber, updatedFamilies, staleFamilies</span>) </span>{
      {
        <span class="hljs-keyword">var</span> alternate = fiber.alternate,
            child = fiber.child,
            sibling = fiber.sibling,
            tag = fiber.tag,
            type = fiber.type;
        <span class="hljs-keyword">var</span> candidateType = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">switch</span> (tag) {
          <span class="hljs-keyword">case</span> FunctionComponent:
          <span class="hljs-keyword">case</span> SimpleMemoComponent:
          <span class="hljs-keyword">case</span> ClassComponent:
            candidateType = type;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> ForwardRef:
            candidateType = type.render;
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected resolveFamily to be set during hot reload.'</span>);
        }

        <span class="hljs-keyword">var</span> needsRender = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> needsRemount = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (candidateType !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> family = resolveFamily(candidateType);

          <span class="hljs-keyword">if</span> (family !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">if</span> (staleFamilies.has(family)) {
              needsRemount = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (updatedFamilies.has(family)) {
              <span class="hljs-keyword">if</span> (tag === ClassComponent) {
                needsRemount = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                needsRender = <span class="hljs-literal">true</span>;
              }
            }
          }
        }

        <span class="hljs-keyword">if</span> (failedBoundaries !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (failedBoundaries.has(fiber) || alternate !== <span class="hljs-literal">null</span> &amp;&amp; failedBoundaries.has(alternate)) {
            needsRemount = <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">if</span> (needsRemount) {
          fiber._debugNeedsRemount = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (needsRemount || needsRender) {
          scheduleWork(fiber, Sync);
        }

        <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span> &amp;&amp; !needsRemount) {
          scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
        }

        <span class="hljs-keyword">if</span> (sibling !== <span class="hljs-literal">null</span>) {
          scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
        }
      }
    }

    <span class="hljs-keyword">var</span> findHostInstancesForRefresh = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, families</span>) </span>{
      {
        <span class="hljs-keyword">var</span> hostInstances = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
        <span class="hljs-keyword">var</span> types = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(families.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">family</span>) </span>{
          <span class="hljs-keyword">return</span> family.current;
        }));
        findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
        <span class="hljs-keyword">return</span> hostInstances;
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findHostInstancesForMatchingFibersRecursively</span>(<span class="hljs-params">fiber, types, hostInstances</span>) </span>{
      {
        <span class="hljs-keyword">var</span> child = fiber.child,
            sibling = fiber.sibling,
            tag = fiber.tag,
            type = fiber.type;
        <span class="hljs-keyword">var</span> candidateType = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">switch</span> (tag) {
          <span class="hljs-keyword">case</span> FunctionComponent:
          <span class="hljs-keyword">case</span> SimpleMemoComponent:
          <span class="hljs-keyword">case</span> ClassComponent:
            candidateType = type;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> ForwardRef:
            candidateType = type.render;
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">var</span> didMatch = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (candidateType !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (types.has(candidateType)) {
            didMatch = <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">if</span> (didMatch) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-708" id="section-708"></a>
</div>
<p>We have a match. This only drills down to the closest host components.
There's no need to search deeper because for the purpose of giving
visual feedback, &quot;flashing&quot; outermost parent rectangles is sufficient.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          findHostInstancesForFiberShallowly(fiber, hostInstances);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-709" id="section-709"></a>
</div>
<p>If there's no match, maybe there will be one further down in the child tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
            findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
          }
        }

        <span class="hljs-keyword">if</span> (sibling !== <span class="hljs-literal">null</span>) {
          findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findHostInstancesForFiberShallowly</span>(<span class="hljs-params">fiber, hostInstances</span>) </span>{
      {
        <span class="hljs-keyword">var</span> foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);

        <span class="hljs-keyword">if</span> (foundHostInstances) {
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// If we didn't find any host children, fallback to closest host parent.</span>


        <span class="hljs-keyword">var</span> node = fiber;

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">switch</span> (node.tag) {
            <span class="hljs-keyword">case</span> HostComponent:
              hostInstances.add(node.stateNode);
              <span class="hljs-keyword">return</span>;

            <span class="hljs-keyword">case</span> HostPortal:
              hostInstances.add(node.stateNode.containerInfo);
              <span class="hljs-keyword">return</span>;

            <span class="hljs-keyword">case</span> HostRoot:
              hostInstances.add(node.stateNode.containerInfo);
              <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected to reach root first.'</span>);
          }

          node = node.return;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findChildHostInstancesForFiberShallowly</span>(<span class="hljs-params">fiber, hostInstances</span>) </span>{
      {
        <span class="hljs-keyword">var</span> node = fiber;
        <span class="hljs-keyword">var</span> foundHostInstances = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">if</span> (node.tag === HostComponent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-710" id="section-710"></a>
</div>
<p>We got a match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            foundHostInstances = <span class="hljs-literal">true</span>;
            hostInstances.add(node.stateNode); <span class="hljs-comment">// There may still be more, so keep searching.</span>
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
            node.child.return = node;
            node = node.child;
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (node === fiber) {
            <span class="hljs-keyword">return</span> foundHostInstances;
          }

          <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === fiber) {
              <span class="hljs-keyword">return</span> foundHostInstances;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveDefaultProps</span>(<span class="hljs-params">Component, baseProps</span>) </span>{
      <span class="hljs-keyword">if</span> (Component &amp;&amp; Component.defaultProps) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-711" id="section-711"></a>
</div>
<p>Resolve default props. Taken from ReactElement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> props = _assign({}, baseProps);

        <span class="hljs-keyword">var</span> defaultProps = Component.defaultProps;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propName <span class="hljs-keyword">in</span> defaultProps) {
          <span class="hljs-keyword">if</span> (props[propName] === <span class="hljs-literal">undefined</span>) {
            props[propName] = defaultProps[propName];
          }
        }

        <span class="hljs-keyword">return</span> props;
      }

      <span class="hljs-keyword">return</span> baseProps;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readLazyComponentType</span>(<span class="hljs-params">lazyComponent</span>) </span>{
      initializeLazyComponentType(lazyComponent);

      <span class="hljs-keyword">if</span> (lazyComponent._status !== Resolved) {
        <span class="hljs-keyword">throw</span> lazyComponent._result;
      }

      <span class="hljs-keyword">return</span> lazyComponent._result;
    }

    <span class="hljs-keyword">var</span> valueCursor = createCursor(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> rendererSigil;
    {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-712" id="section-712"></a>
</div>
<p>Use this to detect multiple renderers using the same context</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      rendererSigil = {};
    }
    <span class="hljs-keyword">var</span> currentlyRenderingFiber = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> lastContextDependency = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> lastContextWithAllBitsObserved = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> isDisallowedContextReadInDEV = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetContextDependencies</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-713" id="section-713"></a>
</div>
<p>This is called right before React yields execution, to ensure <code>readContext</code>
cannot be called outside the render phase.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      currentlyRenderingFiber = <span class="hljs-literal">null</span>;
      lastContextDependency = <span class="hljs-literal">null</span>;
      lastContextWithAllBitsObserved = <span class="hljs-literal">null</span>;
      {
        isDisallowedContextReadInDEV = <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterDisallowedContextReadInDEV</span>(<span class="hljs-params"></span>) </span>{
      {
        isDisallowedContextReadInDEV = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exitDisallowedContextReadInDEV</span>(<span class="hljs-params"></span>) </span>{
      {
        isDisallowedContextReadInDEV = <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushProvider</span>(<span class="hljs-params">providerFiber, nextValue</span>) </span>{
      <span class="hljs-keyword">var</span> context = providerFiber.type._context;
      {
        push(valueCursor, context._currentValue, providerFiber);
        context._currentValue = nextValue;
        {
          <span class="hljs-keyword">if</span> (context._currentRenderer !== <span class="hljs-literal">undefined</span> &amp;&amp; context._currentRenderer !== <span class="hljs-literal">null</span> &amp;&amp; context._currentRenderer !== rendererSigil) {
            error(<span class="hljs-string">'Detected multiple renderers concurrently rendering the '</span> + <span class="hljs-string">'same context provider. This is currently unsupported.'</span>);
          }

          context._currentRenderer = rendererSigil;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popProvider</span>(<span class="hljs-params">providerFiber</span>) </span>{
      <span class="hljs-keyword">var</span> currentValue = valueCursor.current;
      pop(valueCursor, providerFiber);
      <span class="hljs-keyword">var</span> context = providerFiber.type._context;
      {
        context._currentValue = currentValue;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateChangedBits</span>(<span class="hljs-params">context, newValue, oldValue</span>) </span>{
      <span class="hljs-keyword">if</span> (objectIs(oldValue, newValue)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-714" id="section-714"></a>
</div>
<p>No change</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> changedBits = <span class="hljs-keyword">typeof</span> context._calculateChangedBits === <span class="hljs-string">'function'</span> ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
        {
          <span class="hljs-keyword">if</span> ((changedBits &amp; MAX_SIGNED_31_BIT_INT) !== changedBits) {
            error(<span class="hljs-string">'calculateChangedBits: Expected the return value to be a '</span> + <span class="hljs-string">'31-bit integer. Instead received: %s'</span>, changedBits);
          }
        }
        <span class="hljs-keyword">return</span> changedBits | <span class="hljs-number">0</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleWorkOnParentPath</span>(<span class="hljs-params">parent, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-715" id="section-715"></a>
</div>
<p>Update the child expiration time of all the ancestors, including
the alternates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> node = parent;

      <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> alternate = node.alternate;

        <span class="hljs-keyword">if</span> (node.childExpirationTime &lt; renderExpirationTime) {
          node.childExpirationTime = renderExpirationTime;

          <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.childExpirationTime &lt; renderExpirationTime) {
            alternate.childExpirationTime = renderExpirationTime;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.childExpirationTime &lt; renderExpirationTime) {
          alternate.childExpirationTime = renderExpirationTime;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-716" id="section-716"></a>
</div>
<p>Neither alternate was updated, which means the rest of the
ancestor path already has sufficient priority.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">break</span>;
        }

        node = node.return;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propagateContextChange</span>(<span class="hljs-params">workInProgress, context, changedBits, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> fiber = workInProgress.child;

      <span class="hljs-keyword">if</span> (fiber !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-717" id="section-717"></a>
</div>
<p>Set the return pointer of the child to the work-in-progress fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        fiber.return = workInProgress;
      }

      <span class="hljs-keyword">while</span> (fiber !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> nextFiber = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Visit this fiber.</span>

        <span class="hljs-keyword">var</span> list = fiber.dependencies;

        <span class="hljs-keyword">if</span> (list !== <span class="hljs-literal">null</span>) {
          nextFiber = fiber.child;
          <span class="hljs-keyword">var</span> dependency = list.firstContext;

          <span class="hljs-keyword">while</span> (dependency !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-718" id="section-718"></a>
</div>
<p>Check if the context matches.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (dependency.context === context &amp;&amp; (dependency.observedBits &amp; changedBits) !== <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-719" id="section-719"></a>
</div>
<p>Match! Schedule an update on this fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (fiber.tag === ClassComponent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-720" id="section-720"></a>
</div>
<p>Schedule a force update on the work-in-progress.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> update = createUpdate(renderExpirationTime, <span class="hljs-literal">null</span>);
                update.tag = ForceUpdate; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Because we don't have a work-in-progress, this will add the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-721" id="section-721"></a>
</div>
<p>update to the current fiber, too, which means it will persist even if
this render is thrown away. Since it's a race condition, not sure it's
worth fixing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                enqueueUpdate(fiber, update);
              }

              <span class="hljs-keyword">if</span> (fiber.expirationTime &lt; renderExpirationTime) {
                fiber.expirationTime = renderExpirationTime;
              }

              <span class="hljs-keyword">var</span> alternate = fiber.alternate;

              <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.expirationTime &lt; renderExpirationTime) {
                alternate.expirationTime = renderExpirationTime;
              }

              scheduleWorkOnParentPath(fiber.return, renderExpirationTime); <span class="hljs-comment">// Mark the expiration time on the list, too.</span>

              <span class="hljs-keyword">if</span> (list.expirationTime &lt; renderExpirationTime) {
                list.expirationTime = renderExpirationTime;
              } <span class="hljs-comment">// Since we already found a match, we can stop traversing the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-722" id="section-722"></a>
</div>
<p>dependency list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

              <span class="hljs-keyword">break</span>;
            }

            dependency = dependency.next;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fiber.tag === ContextProvider) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-723" id="section-723"></a>
</div>
<p>Don't scan deeper if this is a matching provider</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          nextFiber = fiber.type === workInProgress.type ? <span class="hljs-literal">null</span> : fiber.child;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-724" id="section-724"></a>
</div>
<p>Traverse down.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          nextFiber = fiber.child;
        }

        <span class="hljs-keyword">if</span> (nextFiber !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-725" id="section-725"></a>
</div>
<p>Set the return pointer of the child to the work-in-progress fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          nextFiber.return = fiber;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-726" id="section-726"></a>
</div>
<p>No child. Traverse to next sibling.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          nextFiber = fiber;

          <span class="hljs-keyword">while</span> (nextFiber !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (nextFiber === workInProgress) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-727" id="section-727"></a>
</div>
<p>We're back to the root of this subtree. Exit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              nextFiber = <span class="hljs-literal">null</span>;
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">var</span> sibling = nextFiber.sibling;

            <span class="hljs-keyword">if</span> (sibling !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-728" id="section-728"></a>
</div>
<p>Set the return pointer of the sibling to the work-in-progress fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              sibling.return = nextFiber.return;
              nextFiber = sibling;
              <span class="hljs-keyword">break</span>;
            } <span class="hljs-comment">// No more siblings. Traverse up.</span>


            nextFiber = nextFiber.return;
          }
        }

        fiber = nextFiber;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareToReadContext</span>(<span class="hljs-params">workInProgress, renderExpirationTime</span>) </span>{
      currentlyRenderingFiber = workInProgress;
      lastContextDependency = <span class="hljs-literal">null</span>;
      lastContextWithAllBitsObserved = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> dependencies = workInProgress.dependencies;

      <span class="hljs-keyword">if</span> (dependencies !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> firstContext = dependencies.firstContext;

        <span class="hljs-keyword">if</span> (firstContext !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (dependencies.expirationTime &gt;= renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-729" id="section-729"></a>
</div>
<p>Context list has a pending update. Mark that this fiber performed work.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            markWorkInProgressReceivedUpdate();
          } <span class="hljs-comment">// Reset the work-in-progress list</span>


          dependencies.firstContext = <span class="hljs-literal">null</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readContext</span>(<span class="hljs-params">context, observedBits</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-730" id="section-730"></a>
</div>
<p>This warning would fire if you read context inside a Hook like useMemo.
Unlike the class check below, it's not enforced in production for perf.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (isDisallowedContextReadInDEV) {
          error(<span class="hljs-string">'Context can only be read while React is rendering. '</span> + <span class="hljs-string">'In classes, you can read it in the render method or getDerivedStateFromProps. '</span> + <span class="hljs-string">'In function components, you can read it directly in the function body, but not '</span> + <span class="hljs-string">'inside Hooks like useReducer() or useMemo().'</span>);
        }
      }
      <span class="hljs-keyword">if</span> (lastContextWithAllBitsObserved === context) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (observedBits === <span class="hljs-literal">false</span> || observedBits === <span class="hljs-number">0</span>) ;<span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> resolvedObservedBits; <span class="hljs-comment">// Avoid deopting on observable arguments or heterogeneous types.</span>

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> observedBits !== <span class="hljs-string">'number'</span> || observedBits === MAX_SIGNED_31_BIT_INT) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-731" id="section-731"></a>
</div>
<p>Observe all updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          lastContextWithAllBitsObserved = context;
          resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
        } <span class="hljs-keyword">else</span> {
          resolvedObservedBits = observedBits;
        }

        <span class="hljs-keyword">var</span> contextItem = {
          <span class="hljs-attr">context</span>: context,
          <span class="hljs-attr">observedBits</span>: resolvedObservedBits,
          <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
        };

        <span class="hljs-keyword">if</span> (lastContextDependency === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (!(currentlyRenderingFiber !== <span class="hljs-literal">null</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."</span>);
            }
          } <span class="hljs-comment">// This is the first dependency for this component. Create a new list.</span>


          lastContextDependency = contextItem;
          currentlyRenderingFiber.dependencies = {
            <span class="hljs-attr">expirationTime</span>: NoWork,
            <span class="hljs-attr">firstContext</span>: contextItem,
            <span class="hljs-attr">responders</span>: <span class="hljs-literal">null</span>
          };
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-732" id="section-732"></a>
</div>
<p>Append a new context item.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          lastContextDependency = lastContextDependency.next = contextItem;
        }
      }
      <span class="hljs-keyword">return</span> context._currentValue;
    }

    <span class="hljs-keyword">var</span> UpdateState = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> ReplaceState = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> ForceUpdate = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> CaptureUpdate = <span class="hljs-number">3</span>; <span class="hljs-comment">// Global state that is reset at the beginning of calling `processUpdateQueue`.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-733" id="section-733"></a>
</div>
<p>It should only be read right after calling <code>processUpdateQueue</code>, via
<code>checkHasForceUpdateAfterProcessing</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> hasForceUpdate = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didWarnUpdateInsideUpdate;
    <span class="hljs-keyword">var</span> currentlyProcessingQueue;
    {
      didWarnUpdateInsideUpdate = <span class="hljs-literal">false</span>;
      currentlyProcessingQueue = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> queue = {
        <span class="hljs-attr">baseState</span>: fiber.memoizedState,
        <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">shared</span>: {
          <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>
        },
        <span class="hljs-attr">effects</span>: <span class="hljs-literal">null</span>
      };
      fiber.updateQueue = queue;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneUpdateQueue</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-734" id="section-734"></a>
</div>
<p>Clone the update queue from current. Unless it's already a clone.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> queue = workInProgress.updateQueue;
      <span class="hljs-keyword">var</span> currentQueue = current.updateQueue;

      <span class="hljs-keyword">if</span> (queue === currentQueue) {
        <span class="hljs-keyword">var</span> clone = {
          <span class="hljs-attr">baseState</span>: currentQueue.baseState,
          <span class="hljs-attr">baseQueue</span>: currentQueue.baseQueue,
          <span class="hljs-attr">shared</span>: currentQueue.shared,
          <span class="hljs-attr">effects</span>: currentQueue.effects
        };
        workInProgress.updateQueue = clone;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUpdate</span>(<span class="hljs-params">expirationTime, suspenseConfig</span>) </span>{
      <span class="hljs-keyword">var</span> update = {
        <span class="hljs-attr">expirationTime</span>: expirationTime,
        <span class="hljs-attr">suspenseConfig</span>: suspenseConfig,
        <span class="hljs-attr">tag</span>: UpdateState,
        <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      };
      update.next = update;
      {
        update.priority = getCurrentPriorityLevel();
      }
      <span class="hljs-keyword">return</span> update;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueUpdate</span>(<span class="hljs-params">fiber, update</span>) </span>{
      <span class="hljs-keyword">var</span> updateQueue = fiber.updateQueue;

      <span class="hljs-keyword">if</span> (updateQueue === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-735" id="section-735"></a>
</div>
<p>Only occurs if the fiber has been unmounted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> sharedQueue = updateQueue.shared;
      <span class="hljs-keyword">var</span> pending = sharedQueue.pending;

      <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-736" id="section-736"></a>
</div>
<p>This is the first update. Create a circular list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        update.next = update;
      } <span class="hljs-keyword">else</span> {
        update.next = pending.next;
        pending.next = update;
      }

      sharedQueue.pending = update;
      {
        <span class="hljs-keyword">if</span> (currentlyProcessingQueue === sharedQueue &amp;&amp; !didWarnUpdateInsideUpdate) {
          error(<span class="hljs-string">'An update (setState, replaceState, or forceUpdate) was scheduled '</span> + <span class="hljs-string">'from inside an update function. Update functions should be pure, '</span> + <span class="hljs-string">'with zero side-effects. Consider using componentDidUpdate or a '</span> + <span class="hljs-string">'callback.'</span>);
          didWarnUpdateInsideUpdate = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueCapturedUpdate</span>(<span class="hljs-params">workInProgress, update</span>) </span>{
      <span class="hljs-keyword">var</span> current = workInProgress.alternate;

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-737" id="section-737"></a>
</div>
<p>Ensure the work-in-progress queue is a clone</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        cloneUpdateQueue(current, workInProgress);
      } <span class="hljs-comment">// Captured updates go only on the work-in-progress queue.</span>


      <span class="hljs-keyword">var</span> queue = workInProgress.updateQueue; <span class="hljs-comment">// Append the update to the end of the list.</span>

      <span class="hljs-keyword">var</span> last = queue.baseQueue;

      <span class="hljs-keyword">if</span> (last === <span class="hljs-literal">null</span>) {
        queue.baseQueue = update.next = update;
        update.next = update;
      } <span class="hljs-keyword">else</span> {
        update.next = last.next;
        last.next = update;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStateFromUpdate</span>(<span class="hljs-params">workInProgress, queue, update, prevState, nextProps, instance</span>) </span>{
      <span class="hljs-keyword">switch</span> (update.tag) {
        <span class="hljs-keyword">case</span> ReplaceState:
          {
            <span class="hljs-keyword">var</span> payload = update.payload;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> payload === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-738" id="section-738"></a>
</div>
<p>Updater function</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              {
                enterDisallowedContextReadInDEV();

                <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
                  payload.call(instance, prevState, nextProps);
                }
              }
              <span class="hljs-keyword">var</span> nextState = payload.call(instance, prevState, nextProps);
              {
                exitDisallowedContextReadInDEV();
              }
              <span class="hljs-keyword">return</span> nextState;
            } <span class="hljs-comment">// State object</span>


            <span class="hljs-keyword">return</span> payload;
          }

        <span class="hljs-keyword">case</span> CaptureUpdate:
          {
            workInProgress.effectTag = workInProgress.effectTag &amp; ~ShouldCapture | DidCapture;
          }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-739" id="section-739"></a>
</div>
<p>Intentional fallthrough</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">case</span> UpdateState:
          {
            <span class="hljs-keyword">var</span> _payload = update.payload;
            <span class="hljs-keyword">var</span> partialState;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> _payload === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-740" id="section-740"></a>
</div>
<p>Updater function</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              {
                enterDisallowedContextReadInDEV();

                <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
                  _payload.call(instance, prevState, nextProps);
                }
              }
              partialState = _payload.call(instance, prevState, nextProps);
              {
                exitDisallowedContextReadInDEV();
              }
            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-741" id="section-741"></a>
</div>
<p>Partial state object</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              partialState = _payload;
            }

            <span class="hljs-keyword">if</span> (partialState === <span class="hljs-literal">null</span> || partialState === <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-742" id="section-742"></a>
</div>
<p>Null and undefined are treated as no-ops.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">return</span> prevState;
            } <span class="hljs-comment">// Merge the partial state and the previous state.</span>


            <span class="hljs-keyword">return</span> _assign({}, prevState, partialState);
          }

        <span class="hljs-keyword">case</span> ForceUpdate:
          {
            hasForceUpdate = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> prevState;
          }
      }

      <span class="hljs-keyword">return</span> prevState;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processUpdateQueue</span>(<span class="hljs-params">workInProgress, props, instance, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-743" id="section-743"></a>
</div>
<p>This is always non-null on a ClassComponent or HostRoot</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> queue = workInProgress.updateQueue;
      hasForceUpdate = <span class="hljs-literal">false</span>;
      {
        currentlyProcessingQueue = queue.shared;
      } <span class="hljs-comment">// The last rebase update that is NOT part of the base state.</span>

      <span class="hljs-keyword">var</span> baseQueue = queue.baseQueue; <span class="hljs-comment">// The last pending update that hasn't been processed yet.</span>

      <span class="hljs-keyword">var</span> pendingQueue = queue.shared.pending;

      <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-744" id="section-744"></a>
</div>
<p>We have new updates that haven't been processed yet.
We'll add them to the base queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-745" id="section-745"></a>
</div>
<p>Merge the pending queue and the base queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> baseFirst = baseQueue.next;
          <span class="hljs-keyword">var</span> pendingFirst = pendingQueue.next;
          baseQueue.next = pendingFirst;
          pendingQueue.next = baseFirst;
        }

        baseQueue = pendingQueue;
        queue.shared.pending = <span class="hljs-literal">null</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Pass `current` as argument</span>

        <span class="hljs-keyword">var</span> current = workInProgress.alternate;

        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> currentQueue = current.updateQueue;

          <span class="hljs-keyword">if</span> (currentQueue !== <span class="hljs-literal">null</span>) {
            currentQueue.baseQueue = pendingQueue;
          }
        }
      } <span class="hljs-comment">// These values may change as we process the queue.</span>


      <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> first = baseQueue.next; <span class="hljs-comment">// Iterate through the list of updates to compute the result.</span>

        <span class="hljs-keyword">var</span> newState = queue.baseState;
        <span class="hljs-keyword">var</span> newExpirationTime = NoWork;
        <span class="hljs-keyword">var</span> newBaseState = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> newBaseQueueFirst = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> newBaseQueueLast = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (first !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> update = first;

          <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">var</span> updateExpirationTime = update.expirationTime;

            <span class="hljs-keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-746" id="section-746"></a>
</div>
<p>Priority is insufficient. Skip this update. If this is the first
skipped update, the previous update/state is the new base
update/state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> clone = {
                <span class="hljs-attr">expirationTime</span>: update.expirationTime,
                <span class="hljs-attr">suspenseConfig</span>: update.suspenseConfig,
                <span class="hljs-attr">tag</span>: update.tag,
                <span class="hljs-attr">payload</span>: update.payload,
                <span class="hljs-attr">callback</span>: update.callback,
                <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
              };

              <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) {
                newBaseQueueFirst = newBaseQueueLast = clone;
                newBaseState = newState;
              } <span class="hljs-keyword">else</span> {
                newBaseQueueLast = newBaseQueueLast.next = clone;
              } <span class="hljs-comment">// Update the remaining priority in the queue.</span>


              <span class="hljs-keyword">if</span> (updateExpirationTime &gt; newExpirationTime) {
                newExpirationTime = updateExpirationTime;
              }
            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-747" id="section-747"></a>
</div>
<p>This update does have sufficient priority.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (newBaseQueueLast !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">var</span> _clone = {
                  <span class="hljs-attr">expirationTime</span>: Sync,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-748" id="section-748"></a>
</div>
<p>This update is going to be committed so we never want uncommit it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  suspenseConfig: update.suspenseConfig,
                  <span class="hljs-attr">tag</span>: update.tag,
                  <span class="hljs-attr">payload</span>: update.payload,
                  <span class="hljs-attr">callback</span>: update.callback,
                  <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
                };
                newBaseQueueLast = newBaseQueueLast.next = _clone;
              } <span class="hljs-comment">// Mark the event time of this update as relevant to this render pass.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-749" id="section-749"></a>
</div>
<p>TODO: This should ideally use the true event time of this update rather than
its priority which is a derived and not reverseable value.
TODO: We should skip this update if it was already committed but currently
we have no way of detecting the difference between a committed and suspended
update here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

              markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); <span class="hljs-comment">// Process this update.</span>

              newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
              <span class="hljs-keyword">var</span> callback = update.callback;

              <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
                workInProgress.effectTag |= Callback;
                <span class="hljs-keyword">var</span> effects = queue.effects;

                <span class="hljs-keyword">if</span> (effects === <span class="hljs-literal">null</span>) {
                  queue.effects = [update];
                } <span class="hljs-keyword">else</span> {
                  effects.push(update);
                }
              }
            }

            update = update.next;

            <span class="hljs-keyword">if</span> (update === <span class="hljs-literal">null</span> || update === first) {
              pendingQueue = queue.shared.pending;

              <span class="hljs-keyword">if</span> (pendingQueue === <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">break</span>;
              } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-750" id="section-750"></a>
</div>
<p>An update was scheduled from inside a reducer. Add the new
pending updates to the end of the list and keep processing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                update = baseQueue.next = pendingQueue.next;
                pendingQueue.next = first;
                queue.baseQueue = baseQueue = pendingQueue;
                queue.shared.pending = <span class="hljs-literal">null</span>;
              }
            }
          } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);
        }

        <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) {
          newBaseState = newState;
        } <span class="hljs-keyword">else</span> {
          newBaseQueueLast.next = newBaseQueueFirst;
        }

        queue.baseState = newBaseState;
        queue.baseQueue = newBaseQueueLast; <span class="hljs-comment">// Set the remaining expiration time to be whatever is remaining in the queue.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-751" id="section-751"></a>
</div>
<p>This should be fine because the only two other things that contribute to
expiration time are props and context. We're already in the middle of the
begin phase by the time we start processing the queue, so we've already
dealt with the props. Context in components that specify
shouldComponentUpdate is tricky; but we'll have to account for
that regardless.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        markUnprocessedUpdateTime(newExpirationTime);
        workInProgress.expirationTime = newExpirationTime;
        workInProgress.memoizedState = newState;
      }

      {
        currentlyProcessingQueue = <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callCallback</span>(<span class="hljs-params">callback, context</span>) </span>{
      <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid argument passed as callback. Expected a function. Instead received: "</span> + callback);
        }
      }

      callback.call(context);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetHasForceUpdateBeforeProcessing</span>(<span class="hljs-params"></span>) </span>{
      hasForceUpdate = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkHasForceUpdateAfterProcessing</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> hasForceUpdate;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitUpdateQueue</span>(<span class="hljs-params">finishedWork, finishedQueue, instance</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-752" id="section-752"></a>
</div>
<p>Commit the effects</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> effects = finishedQueue.effects;
      finishedQueue.effects = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (effects !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; effects.length; i++) {
          <span class="hljs-keyword">var</span> effect = effects[i];
          <span class="hljs-keyword">var</span> callback = effect.callback;

          <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
            effect.callback = <span class="hljs-literal">null</span>;
            callCallback(callback, instance);
          }
        }
      }
    }

    <span class="hljs-keyword">var</span> ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestCurrentSuspenseConfig</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> ReactCurrentBatchConfig.suspense;
    }

    <span class="hljs-keyword">var</span> fakeInternalInstance = {};
    <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray; <span class="hljs-comment">// React.Component uses a shared frozen object by default.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-753" id="section-753"></a>
</div>
<p>We'll use it to determine whether we need to initialize legacy refs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> emptyRefsObject = <span class="hljs-keyword">new</span> React.Component().refs;
    <span class="hljs-keyword">var</span> didWarnAboutStateAssignmentForComponent;
    <span class="hljs-keyword">var</span> didWarnAboutUninitializedState;
    <span class="hljs-keyword">var</span> didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
    <span class="hljs-keyword">var</span> didWarnAboutLegacyLifecyclesAndDerivedState;
    <span class="hljs-keyword">var</span> didWarnAboutUndefinedDerivedState;
    <span class="hljs-keyword">var</span> warnOnUndefinedDerivedState;
    <span class="hljs-keyword">var</span> warnOnInvalidCallback;
    <span class="hljs-keyword">var</span> didWarnAboutDirectlyAssigningPropsToState;
    <span class="hljs-keyword">var</span> didWarnAboutContextTypeAndContextTypes;
    <span class="hljs-keyword">var</span> didWarnAboutInvalidateContextType;
    {
      didWarnAboutStateAssignmentForComponent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      didWarnAboutUninitializedState = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      didWarnAboutLegacyLifecyclesAndDerivedState = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      didWarnAboutDirectlyAssigningPropsToState = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      didWarnAboutUndefinedDerivedState = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      didWarnAboutContextTypeAndContextTypes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      didWarnAboutInvalidateContextType = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      <span class="hljs-keyword">var</span> didWarnOnInvalidCallback = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

      warnOnInvalidCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, callerName</span>) </span>{
        <span class="hljs-keyword">if</span> (callback === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> key = callerName + <span class="hljs-string">"_"</span> + callback;

        <span class="hljs-keyword">if</span> (!didWarnOnInvalidCallback.has(key)) {
          didWarnOnInvalidCallback.add(key);
          error(<span class="hljs-string">'%s(...): Expected the last optional `callback` argument to be a '</span> + <span class="hljs-string">'function. Instead received: %s.'</span>, callerName, callback);
        }
      };

      warnOnUndefinedDerivedState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, partialState</span>) </span>{
        <span class="hljs-keyword">if</span> (partialState === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">var</span> componentName = getComponentName(type) || <span class="hljs-string">'Component'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutUndefinedDerivedState.has(componentName)) {
            didWarnAboutUndefinedDerivedState.add(componentName);
            error(<span class="hljs-string">'%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '</span> + <span class="hljs-string">'You have returned undefined.'</span>, componentName);
          }
        }
      }; <span class="hljs-comment">// This is so gross but it's at least non-critical and can be removed if</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-754" id="section-754"></a>
</div>
<p>it causes problems. This is meant to give a nicer error message for
ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
...)) which otherwise throws a &quot;_processChildContext is not a function&quot;
exception.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-built_in">Object</span>.defineProperty(fakeInternalInstance, <span class="hljs-string">'_processChildContext'</span>, {
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)."</span>);
            }
          }
        }
      });
      <span class="hljs-built_in">Object</span>.freeze(fakeInternalInstance);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyDerivedStateFromProps</span>(<span class="hljs-params">workInProgress, ctor, getDerivedStateFromProps, nextProps</span>) </span>{
      <span class="hljs-keyword">var</span> prevState = workInProgress.memoizedState;
      {
        <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-755" id="section-755"></a>
</div>
<p>Invoke the function an extra time to help detect side-effects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          getDerivedStateFromProps(nextProps, prevState);
        }
      }
      <span class="hljs-keyword">var</span> partialState = getDerivedStateFromProps(nextProps, prevState);
      {
        warnOnUndefinedDerivedState(ctor, partialState);
      } <span class="hljs-comment">// Merge the partial state and the previous state.</span>

      <span class="hljs-keyword">var</span> memoizedState = partialState === <span class="hljs-literal">null</span> || partialState === <span class="hljs-literal">undefined</span> ? prevState : _assign({}, prevState, partialState);
      workInProgress.memoizedState = memoizedState; <span class="hljs-comment">// Once the update queue is empty, persist the derived state onto the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-756" id="section-756"></a>
</div>
<p>base state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (workInProgress.expirationTime === NoWork) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-757" id="section-757"></a>
</div>
<p>Queue is always non-null for classes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> updateQueue = workInProgress.updateQueue;
        updateQueue.baseState = memoizedState;
      }
    }

    <span class="hljs-keyword">var</span> classComponentUpdater = {
      <span class="hljs-attr">isMounted</span>: isMounted,
      <span class="hljs-attr">enqueueSetState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inst, payload, callback</span>) </span>{
        <span class="hljs-keyword">var</span> fiber = <span class="hljs-keyword">get</span>(inst);
        var currentTime = requestCurrentTimeForUpdate();
        var suspenseConfig = requestCurrentSuspenseConfig();
        var expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
        var update = createUpdate(expirationTime, suspenseConfig);
        update.payload = payload;

        if (callback !== undefined &amp;&amp; callback !== null) {
          {
            warnOnInvalidCallback(callback, <span class="hljs-string">'setState'</span>);
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      <span class="hljs-attr">enqueueReplaceState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inst, payload, callback</span>) </span>{
        <span class="hljs-keyword">var</span> fiber = <span class="hljs-keyword">get</span>(inst);
        var currentTime = requestCurrentTimeForUpdate();
        var suspenseConfig = requestCurrentSuspenseConfig();
        var expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
        var update = createUpdate(expirationTime, suspenseConfig);
        update.tag = ReplaceState;
        update.payload = payload;

        if (callback !== undefined &amp;&amp; callback !== null) {
          {
            warnOnInvalidCallback(callback, <span class="hljs-string">'replaceState'</span>);
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      <span class="hljs-attr">enqueueForceUpdate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inst, callback</span>) </span>{
        <span class="hljs-keyword">var</span> fiber = <span class="hljs-keyword">get</span>(inst);
        var currentTime = requestCurrentTimeForUpdate();
        var suspenseConfig = requestCurrentSuspenseConfig();
        var expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
        var update = createUpdate(expirationTime, suspenseConfig);
        update.tag = ForceUpdate;

        if (callback !== undefined &amp;&amp; callback !== null) {
          {
            warnOnInvalidCallback(callback, <span class="hljs-string">'forceUpdate'</span>);
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkShouldComponentUpdate</span>(<span class="hljs-params">workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext</span>) </span>{
      <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.shouldComponentUpdate === <span class="hljs-string">'function'</span>) {
        {
          <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-758" id="section-758"></a>
</div>
<p>Invoke the function an extra time to help detect side-effects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            instance.shouldComponentUpdate(newProps, newState, nextContext);
          }
        }
        startPhaseTimer(workInProgress, <span class="hljs-string">'shouldComponentUpdate'</span>);
        <span class="hljs-keyword">var</span> shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
        stopPhaseTimer();
        {
          <span class="hljs-keyword">if</span> (shouldUpdate === <span class="hljs-literal">undefined</span>) {
            error(<span class="hljs-string">'%s.shouldComponentUpdate(): Returned undefined instead of a '</span> + <span class="hljs-string">'boolean value. Make sure to return true or false.'</span>, getComponentName(ctor) || <span class="hljs-string">'Component'</span>);
          }
        }
        <span class="hljs-keyword">return</span> shouldUpdate;
      }

      <span class="hljs-keyword">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {
        <span class="hljs-keyword">return</span> !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkClassInstance</span>(<span class="hljs-params">workInProgress, ctor, newProps</span>) </span>{
      <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;
      {
        <span class="hljs-keyword">var</span> name = getComponentName(ctor) || <span class="hljs-string">'Component'</span>;
        <span class="hljs-keyword">var</span> renderPresent = instance.render;

        <span class="hljs-keyword">if</span> (!renderPresent) {
          <span class="hljs-keyword">if</span> (ctor.prototype &amp;&amp; <span class="hljs-keyword">typeof</span> ctor.prototype.render === <span class="hljs-string">'function'</span>) {
            error(<span class="hljs-string">'%s(...): No `render` method found on the returned component '</span> + <span class="hljs-string">'instance: did you accidentally return an object from the constructor?'</span>, name);
          } <span class="hljs-keyword">else</span> {
            error(<span class="hljs-string">'%s(...): No `render` method found on the returned component '</span> + <span class="hljs-string">'instance: you may have forgotten to define `render`.'</span>, name);
          }
        }

        <span class="hljs-keyword">if</span> (instance.getInitialState &amp;&amp; !instance.getInitialState.isReactClassApproved &amp;&amp; !instance.state) {
          error(<span class="hljs-string">'getInitialState was defined on %s, a plain JavaScript class. '</span> + <span class="hljs-string">'This is only supported for classes created using React.createClass. '</span> + <span class="hljs-string">'Did you mean to define a state property instead?'</span>, name);
        }

        <span class="hljs-keyword">if</span> (instance.getDefaultProps &amp;&amp; !instance.getDefaultProps.isReactClassApproved) {
          error(<span class="hljs-string">'getDefaultProps was defined on %s, a plain JavaScript class. '</span> + <span class="hljs-string">'This is only supported for classes created using React.createClass. '</span> + <span class="hljs-string">'Use a static property to define defaultProps instead.'</span>, name);
        }

        <span class="hljs-keyword">if</span> (instance.propTypes) {
          error(<span class="hljs-string">'propTypes was defined as an instance property on %s. Use a static '</span> + <span class="hljs-string">'property to define propTypes instead.'</span>, name);
        }

        <span class="hljs-keyword">if</span> (instance.contextType) {
          error(<span class="hljs-string">'contextType was defined as an instance property on %s. Use a static '</span> + <span class="hljs-string">'property to define contextType instead.'</span>, name);
        }

        {
          <span class="hljs-keyword">if</span> (instance.contextTypes) {
            error(<span class="hljs-string">'contextTypes was defined as an instance property on %s. Use a static '</span> + <span class="hljs-string">'property to define contextTypes instead.'</span>, name);
          }

          <span class="hljs-keyword">if</span> (ctor.contextType &amp;&amp; ctor.contextTypes &amp;&amp; !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            error(<span class="hljs-string">'%s declares both contextTypes and contextType static properties. '</span> + <span class="hljs-string">'The legacy contextTypes property will be ignored.'</span>, name);
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentShouldUpdate === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s has a method called '</span> + <span class="hljs-string">'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '</span> + <span class="hljs-string">'The name is phrased as a question because the function is '</span> + <span class="hljs-string">'expected to return a value.'</span>, name);
        }

        <span class="hljs-keyword">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent &amp;&amp; <span class="hljs-keyword">typeof</span> instance.shouldComponentUpdate !== <span class="hljs-string">'undefined'</span>) {
          error(<span class="hljs-string">'%s has a method called shouldComponentUpdate(). '</span> + <span class="hljs-string">'shouldComponentUpdate should not be used when extending React.PureComponent. '</span> + <span class="hljs-string">'Please extend React.Component if shouldComponentUpdate is used.'</span>, getComponentName(ctor) || <span class="hljs-string">'A pure component'</span>);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidUnmount === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s has a method called '</span> + <span class="hljs-string">'componentDidUnmount(). But there is no such lifecycle method. '</span> + <span class="hljs-string">'Did you mean componentWillUnmount()?'</span>, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidReceiveProps === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s has a method called '</span> + <span class="hljs-string">'componentDidReceiveProps(). But there is no such lifecycle method. '</span> + <span class="hljs-string">'If you meant to update the state in response to changing props, '</span> + <span class="hljs-string">'use componentWillReceiveProps(). If you meant to fetch data or '</span> + <span class="hljs-string">'run side-effects or mutations after React has updated the UI, use componentDidUpdate().'</span>, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillRecieveProps === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s has a method called '</span> + <span class="hljs-string">'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?'</span>, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillRecieveProps === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s has a method called '</span> + <span class="hljs-string">'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?'</span>, name);
        }

        <span class="hljs-keyword">var</span> hasMutatedProps = instance.props !== newProps;

        <span class="hljs-keyword">if</span> (instance.props !== <span class="hljs-literal">undefined</span> &amp;&amp; hasMutatedProps) {
          error(<span class="hljs-string">'%s(...): When calling super() in `%s`, make sure to pass '</span> + <span class="hljs-string">"up the same props that your component's constructor was passed."</span>, name, name);
        }

        <span class="hljs-keyword">if</span> (instance.defaultProps) {
          error(<span class="hljs-string">'Setting defaultProps as an instance property on %s is not supported and will be ignored.'</span> + <span class="hljs-string">' Instead, define defaultProps as a static property on %s.'</span>, name, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.componentDidUpdate !== <span class="hljs-string">'function'</span> &amp;&amp; !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
          error(<span class="hljs-string">'%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '</span> + <span class="hljs-string">'This component defines getSnapshotBeforeUpdate() only.'</span>, getComponentName(ctor));
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getDerivedStateFromProps === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s: getDerivedStateFromProps() is defined as an instance method '</span> + <span class="hljs-string">'and will be ignored. Instead, declare it as a static method.'</span>, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getDerivedStateFromError === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s: getDerivedStateFromError() is defined as an instance method '</span> + <span class="hljs-string">'and will be ignored. Instead, declare it as a static method.'</span>, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s: getSnapshotBeforeUpdate() is defined as a static method '</span> + <span class="hljs-string">'and will be ignored. Instead, declare it as an instance method.'</span>, name);
        }

        <span class="hljs-keyword">var</span> _state = instance.state;

        <span class="hljs-keyword">if</span> (_state &amp;&amp; (<span class="hljs-keyword">typeof</span> _state !== <span class="hljs-string">'object'</span> || isArray(_state))) {
          error(<span class="hljs-string">'%s.state: must be set to an object or null'</span>, name);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getChildContext === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> ctor.childContextTypes !== <span class="hljs-string">'object'</span>) {
          error(<span class="hljs-string">'%s.getChildContext(): childContextTypes must be defined in order to '</span> + <span class="hljs-string">'use getChildContext().'</span>, name);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adoptClassInstance</span>(<span class="hljs-params">workInProgress, instance</span>) </span>{
      instance.updater = classComponentUpdater;
      workInProgress.stateNode = instance; <span class="hljs-comment">// The instance needs access to the fiber so that it can schedule updates</span>

      <span class="hljs-keyword">set</span>(instance, workInProgress);
      {
        instance._reactInternalInstance = fakeInternalInstance;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructClassInstance</span>(<span class="hljs-params">workInProgress, ctor, props</span>) </span>{
      <span class="hljs-keyword">var</span> isLegacyContextConsumer = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> unmaskedContext = emptyContextObject;
      <span class="hljs-keyword">var</span> context = emptyContextObject;
      <span class="hljs-keyword">var</span> contextType = ctor.contextType;
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-string">'contextType'</span> <span class="hljs-keyword">in</span> ctor) {
          <span class="hljs-keyword">var</span> isValid = <span class="hljs-comment">// Allow null for conditional declaration</span>
          contextType === <span class="hljs-literal">null</span> || contextType !== <span class="hljs-literal">undefined</span> &amp;&amp; contextType.$$<span class="hljs-keyword">typeof</span> === REACT_CONTEXT_TYPE &amp;&amp; contextType._context === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Not a &lt;Context.Consumer&gt;</span>

          <span class="hljs-keyword">if</span> (!isValid &amp;&amp; !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            <span class="hljs-keyword">var</span> addendum = <span class="hljs-string">''</span>;

            <span class="hljs-keyword">if</span> (contextType === <span class="hljs-literal">undefined</span>) {
              addendum = <span class="hljs-string">' However, it is set to undefined. '</span> + <span class="hljs-string">'This can be caused by a typo or by mixing up named and default imports. '</span> + <span class="hljs-string">'This can also happen due to a circular dependency, so '</span> + <span class="hljs-string">'try moving the createContext() call to a separate file.'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType !== <span class="hljs-string">'object'</span>) {
              addendum = <span class="hljs-string">' However, it is set to a '</span> + <span class="hljs-keyword">typeof</span> contextType + <span class="hljs-string">'.'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType.$$<span class="hljs-keyword">typeof</span> === REACT_PROVIDER_TYPE) {
              addendum = <span class="hljs-string">' Did you accidentally pass the Context.Provider instead?'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType._context !== <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-759" id="section-759"></a>
</div>
<p>&lt;Context.Consumer&gt;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              addendum = <span class="hljs-string">' Did you accidentally pass the Context.Consumer instead?'</span>;
            } <span class="hljs-keyword">else</span> {
              addendum = <span class="hljs-string">' However, it is set to an object with keys {'</span> + <span class="hljs-built_in">Object</span>.keys(contextType).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'}.'</span>;
            }

            error(<span class="hljs-string">'%s defines an invalid contextType. '</span> + <span class="hljs-string">'contextType should point to the Context object returned by React.createContext().%s'</span>, getComponentName(ctor) || <span class="hljs-string">'Component'</span>, addendum);
          }
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">'object'</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
        context = readContext(contextType);
      } <span class="hljs-keyword">else</span> {
        unmaskedContext = getUnmaskedContext(workInProgress, ctor, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">var</span> contextTypes = ctor.contextTypes;
        isLegacyContextConsumer = contextTypes !== <span class="hljs-literal">null</span> &amp;&amp; contextTypes !== <span class="hljs-literal">undefined</span>;
        context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
      } <span class="hljs-comment">// Instantiate twice to help detect side-effects.</span>


      {
        <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
          <span class="hljs-keyword">new</span> ctor(props, context); <span class="hljs-comment">// eslint-disable-line no-new</span>
        }
      }
      <span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> ctor(props, context);
      <span class="hljs-keyword">var</span> state = workInProgress.memoizedState = instance.state !== <span class="hljs-literal">null</span> &amp;&amp; instance.state !== <span class="hljs-literal">undefined</span> ? instance.state : <span class="hljs-literal">null</span>;
      adoptClassInstance(workInProgress, instance);
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.getDerivedStateFromProps === <span class="hljs-string">'function'</span> &amp;&amp; state === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> componentName = getComponentName(ctor) || <span class="hljs-string">'Component'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutUninitializedState.has(componentName)) {
            didWarnAboutUninitializedState.add(componentName);
            error(<span class="hljs-string">'`%s` uses `getDerivedStateFromProps` but its initial state is '</span> + <span class="hljs-string">'%s. This is not recommended. Instead, define the initial state by '</span> + <span class="hljs-string">'assigning an object to `this.state` in the constructor of `%s`. '</span> + <span class="hljs-string">'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.'</span>, componentName, instance.state === <span class="hljs-literal">null</span> ? <span class="hljs-string">'null'</span> : <span class="hljs-string">'undefined'</span>, componentName);
          }
        } <span class="hljs-comment">// If new component APIs are defined, "unsafe" lifecycles won't be called.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-760" id="section-760"></a>
</div>
<p>Warn about these lifecycles if they are present.
Don't warn about react-lifecycles-compat polyfilled methods though.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.getDerivedStateFromProps === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">var</span> foundWillMountName = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">var</span> foundWillReceivePropsName = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">var</span> foundWillUpdateName = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillMount === <span class="hljs-string">'function'</span> &amp;&amp; instance.componentWillMount.__suppressDeprecationWarning !== <span class="hljs-literal">true</span>) {
            foundWillMountName = <span class="hljs-string">'componentWillMount'</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="hljs-string">'function'</span>) {
            foundWillMountName = <span class="hljs-string">'UNSAFE_componentWillMount'</span>;
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillReceiveProps === <span class="hljs-string">'function'</span> &amp;&amp; instance.componentWillReceiveProps.__suppressDeprecationWarning !== <span class="hljs-literal">true</span>) {
            foundWillReceivePropsName = <span class="hljs-string">'componentWillReceiveProps'</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillReceiveProps === <span class="hljs-string">'function'</span>) {
            foundWillReceivePropsName = <span class="hljs-string">'UNSAFE_componentWillReceiveProps'</span>;
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillUpdate === <span class="hljs-string">'function'</span> &amp;&amp; instance.componentWillUpdate.__suppressDeprecationWarning !== <span class="hljs-literal">true</span>) {
            foundWillUpdateName = <span class="hljs-string">'componentWillUpdate'</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillUpdate === <span class="hljs-string">'function'</span>) {
            foundWillUpdateName = <span class="hljs-string">'UNSAFE_componentWillUpdate'</span>;
          }

          <span class="hljs-keyword">if</span> (foundWillMountName !== <span class="hljs-literal">null</span> || foundWillReceivePropsName !== <span class="hljs-literal">null</span> || foundWillUpdateName !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> _componentName = getComponentName(ctor) || <span class="hljs-string">'Component'</span>;

            <span class="hljs-keyword">var</span> newApiName = <span class="hljs-keyword">typeof</span> ctor.getDerivedStateFromProps === <span class="hljs-string">'function'</span> ? <span class="hljs-string">'getDerivedStateFromProps()'</span> : <span class="hljs-string">'getSnapshotBeforeUpdate()'</span>;

            <span class="hljs-keyword">if</span> (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
              didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
              error(<span class="hljs-string">'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'</span> + <span class="hljs-string">'%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n'</span> + <span class="hljs-string">'The above lifecycles should be removed. Learn more about this warning here:\n'</span> + <span class="hljs-string">'https://fb.me/react-unsafe-component-lifecycles'</span>, _componentName, newApiName, foundWillMountName !== <span class="hljs-literal">null</span> ? <span class="hljs-string">"\n  "</span> + foundWillMountName : <span class="hljs-string">''</span>, foundWillReceivePropsName !== <span class="hljs-literal">null</span> ? <span class="hljs-string">"\n  "</span> + foundWillReceivePropsName : <span class="hljs-string">''</span>, foundWillUpdateName !== <span class="hljs-literal">null</span> ? <span class="hljs-string">"\n  "</span> + foundWillUpdateName : <span class="hljs-string">''</span>);
            }
          }
        }
      } <span class="hljs-comment">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-761" id="section-761"></a>
</div>
<p>ReactFiberContext usually updates this cache but can't for newly-created instances.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (isLegacyContextConsumer) {
        cacheContext(workInProgress, unmaskedContext, context);
      }

      <span class="hljs-keyword">return</span> instance;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callComponentWillMount</span>(<span class="hljs-params">workInProgress, instance</span>) </span>{
      startPhaseTimer(workInProgress, <span class="hljs-string">'componentWillMount'</span>);
      <span class="hljs-keyword">var</span> oldState = instance.state;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillMount === <span class="hljs-string">'function'</span>) {
        instance.componentWillMount();
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="hljs-string">'function'</span>) {
        instance.UNSAFE_componentWillMount();
      }

      stopPhaseTimer();

      <span class="hljs-keyword">if</span> (oldState !== instance.state) {
        {
          error(<span class="hljs-string">'%s.componentWillMount(): Assigning directly to this.state is '</span> + <span class="hljs-string">"deprecated (except inside a component's "</span> + <span class="hljs-string">'constructor). Use setState instead.'</span>, getComponentName(workInProgress.type) || <span class="hljs-string">'Component'</span>);
        }
        classComponentUpdater.enqueueReplaceState(instance, instance.state, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callComponentWillReceiveProps</span>(<span class="hljs-params">workInProgress, instance, newProps, nextContext</span>) </span>{
      <span class="hljs-keyword">var</span> oldState = instance.state;
      startPhaseTimer(workInProgress, <span class="hljs-string">'componentWillReceiveProps'</span>);

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillReceiveProps === <span class="hljs-string">'function'</span>) {
        instance.componentWillReceiveProps(newProps, nextContext);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillReceiveProps === <span class="hljs-string">'function'</span>) {
        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      }

      stopPhaseTimer();

      <span class="hljs-keyword">if</span> (instance.state !== oldState) {
        {
          <span class="hljs-keyword">var</span> componentName = getComponentName(workInProgress.type) || <span class="hljs-string">'Component'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
            didWarnAboutStateAssignmentForComponent.add(componentName);
            error(<span class="hljs-string">'%s.componentWillReceiveProps(): Assigning directly to '</span> + <span class="hljs-string">"this.state is deprecated (except inside a component's "</span> + <span class="hljs-string">'constructor). Use setState instead.'</span>, componentName);
          }
        }
        classComponentUpdater.enqueueReplaceState(instance, instance.state, <span class="hljs-literal">null</span>);
      }
    } <span class="hljs-comment">// Invokes the mount life-cycles on a previously never rendered instance.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountClassInstance</span>(<span class="hljs-params">workInProgress, ctor, newProps, renderExpirationTime</span>) </span>{
      {
        checkClassInstance(workInProgress, ctor, newProps);
      }
      <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;
      instance.props = newProps;
      instance.state = workInProgress.memoizedState;
      instance.refs = emptyRefsObject;
      initializeUpdateQueue(workInProgress);
      <span class="hljs-keyword">var</span> contextType = ctor.contextType;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">'object'</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
        instance.context = readContext(contextType);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> unmaskedContext = getUnmaskedContext(workInProgress, ctor, <span class="hljs-literal">true</span>);
        instance.context = getMaskedContext(workInProgress, unmaskedContext);
      }

      {
        <span class="hljs-keyword">if</span> (instance.state === newProps) {
          <span class="hljs-keyword">var</span> componentName = getComponentName(ctor) || <span class="hljs-string">'Component'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
            didWarnAboutDirectlyAssigningPropsToState.add(componentName);
            error(<span class="hljs-string">'%s: It is not recommended to assign props directly to state '</span> + <span class="hljs-string">"because updates to props won't be reflected in state. "</span> + <span class="hljs-string">'In most cases, it is better to use props directly.'</span>, componentName);
          }
        }

        <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
          ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
        }

        {
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
        }
      }
      processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
      instance.state = workInProgress.memoizedState;
      <span class="hljs-keyword">var</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span>) {
        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
        instance.state = workInProgress.memoizedState;
      } <span class="hljs-comment">// In order to support react-lifecycles-compat polyfilled components,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-762" id="section-762"></a>
</div>
<p>Unsafe lifecycles should not be invoked for components using the new APIs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.getDerivedStateFromProps !== <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate !== <span class="hljs-string">'function'</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.componentWillMount === <span class="hljs-string">'function'</span>)) {
        callComponentWillMount(workInProgress, instance); <span class="hljs-comment">// If we had additional state updates during this life-cycle, let's</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-763" id="section-763"></a>
</div>
<p>process them now.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
        instance.state = workInProgress.memoizedState;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidMount === <span class="hljs-string">'function'</span>) {
        workInProgress.effectTag |= Update;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resumeMountClassInstance</span>(<span class="hljs-params">workInProgress, ctor, newProps, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;
      <span class="hljs-keyword">var</span> oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;
      <span class="hljs-keyword">var</span> oldContext = instance.context;
      <span class="hljs-keyword">var</span> contextType = ctor.contextType;
      <span class="hljs-keyword">var</span> nextContext = emptyContextObject;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">'object'</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
        nextContext = readContext(contextType);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, <span class="hljs-literal">true</span>);
        nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
      }

      <span class="hljs-keyword">var</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      <span class="hljs-keyword">var</span> hasNewLifecycles = <span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>; <span class="hljs-comment">// Note: During these life-cycles, instance.props/instance.state are what</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-764" id="section-764"></a>
</div>
<p>ever the previously attempted to render - not the &quot;current&quot;. However,
during componentDidUpdate we pass the &quot;current&quot; props.
In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillReceiveProps === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.componentWillReceiveProps === <span class="hljs-string">'function'</span>)) {
        <span class="hljs-keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) {
          callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
      }

      resetHasForceUpdateBeforeProcessing();
      <span class="hljs-keyword">var</span> oldState = workInProgress.memoizedState;
      <span class="hljs-keyword">var</span> newState = instance.state = oldState;
      processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
      newState = workInProgress.memoizedState;

      <span class="hljs-keyword">if</span> (oldProps === newProps &amp;&amp; oldState === newState &amp;&amp; !hasContextChanged() &amp;&amp; !checkHasForceUpdateAfterProcessing()) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-765" id="section-765"></a>
</div>
<p>If an update was already in progress, we should schedule an Update
effect even though we're bailing out, so that cWU/cDU are called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidMount === <span class="hljs-string">'function'</span>) {
          workInProgress.effectTag |= Update;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span>) {
        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
        newState = workInProgress.memoizedState;
      }

      <span class="hljs-keyword">var</span> shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

      <span class="hljs-keyword">if</span> (shouldUpdate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-766" id="section-766"></a>
</div>
<p>In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.componentWillMount === <span class="hljs-string">'function'</span>)) {
          startPhaseTimer(workInProgress, <span class="hljs-string">'componentWillMount'</span>);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillMount === <span class="hljs-string">'function'</span>) {
            instance.componentWillMount();
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillMount === <span class="hljs-string">'function'</span>) {
            instance.UNSAFE_componentWillMount();
          }

          stopPhaseTimer();
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidMount === <span class="hljs-string">'function'</span>) {
          workInProgress.effectTag |= Update;
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-767" id="section-767"></a>
</div>
<p>If an update was already in progress, we should schedule an Update
effect even though we're bailing out, so that cWU/cDU are called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidMount === <span class="hljs-string">'function'</span>) {
          workInProgress.effectTag |= Update;
        } <span class="hljs-comment">// If shouldComponentUpdate returned false, we should still update the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-768" id="section-768"></a>
</div>
<p>memoized state to indicate that this work can be reused.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        workInProgress.memoizedProps = newProps;
        workInProgress.memoizedState = newState;
      } <span class="hljs-comment">// Update the existing instance's state, props, and context pointers even</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-769" id="section-769"></a>
</div>
<p>if shouldComponentUpdate returns false.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      instance.props = newProps;
      instance.state = newState;
      instance.context = nextContext;
      <span class="hljs-keyword">return</span> shouldUpdate;
    } <span class="hljs-comment">// Invokes the update life-cycles and returns false if it shouldn't rerender.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassInstance</span>(<span class="hljs-params">current, workInProgress, ctor, newProps, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;
      cloneUpdateQueue(current, workInProgress);
      <span class="hljs-keyword">var</span> oldProps = workInProgress.memoizedProps;
      instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);
      <span class="hljs-keyword">var</span> oldContext = instance.context;
      <span class="hljs-keyword">var</span> contextType = ctor.contextType;
      <span class="hljs-keyword">var</span> nextContext = emptyContextObject;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">'object'</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
        nextContext = readContext(contextType);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, <span class="hljs-literal">true</span>);
        nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
      }

      <span class="hljs-keyword">var</span> getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      <span class="hljs-keyword">var</span> hasNewLifecycles = <span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>; <span class="hljs-comment">// Note: During these life-cycles, instance.props/instance.state are what</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-770" id="section-770"></a>
</div>
<p>ever the previously attempted to render - not the &quot;current&quot;. However,
during componentDidUpdate we pass the &quot;current&quot; props.
In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillReceiveProps === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.componentWillReceiveProps === <span class="hljs-string">'function'</span>)) {
        <span class="hljs-keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) {
          callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
      }

      resetHasForceUpdateBeforeProcessing();
      <span class="hljs-keyword">var</span> oldState = workInProgress.memoizedState;
      <span class="hljs-keyword">var</span> newState = instance.state = oldState;
      processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
      newState = workInProgress.memoizedState;

      <span class="hljs-keyword">if</span> (oldProps === newProps &amp;&amp; oldState === newState &amp;&amp; !hasContextChanged() &amp;&amp; !checkHasForceUpdateAfterProcessing()) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-771" id="section-771"></a>
</div>
<p>If an update was already in progress, we should schedule an Update
effect even though we're bailing out, so that cWU/cDU are called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidUpdate === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">if</span> (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Update;
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">if</span> (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Snapshot;
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span>) {
        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
        newState = workInProgress.memoizedState;
      }

      <span class="hljs-keyword">var</span> shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

      <span class="hljs-keyword">if</span> (shouldUpdate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-772" id="section-772"></a>
</div>
<p>In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillUpdate === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.componentWillUpdate === <span class="hljs-string">'function'</span>)) {
          startPhaseTimer(workInProgress, <span class="hljs-string">'componentWillUpdate'</span>);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillUpdate === <span class="hljs-string">'function'</span>) {
            instance.componentWillUpdate(newProps, newState, nextContext);
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.UNSAFE_componentWillUpdate === <span class="hljs-string">'function'</span>) {
            instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
          }

          stopPhaseTimer();
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidUpdate === <span class="hljs-string">'function'</span>) {
          workInProgress.effectTag |= Update;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>) {
          workInProgress.effectTag |= Snapshot;
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-773" id="section-773"></a>
</div>
<p>If an update was already in progress, we should schedule an Update
effect even though we're bailing out, so that cWU/cDU are called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentDidUpdate === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">if</span> (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Update;
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.getSnapshotBeforeUpdate === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">if</span> (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Snapshot;
          }
        } <span class="hljs-comment">// If shouldComponentUpdate returned false, we should still update the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-774" id="section-774"></a>
</div>
<p>memoized props/state to indicate that this work can be reused.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        workInProgress.memoizedProps = newProps;
        workInProgress.memoizedState = newState;
      } <span class="hljs-comment">// Update the existing instance's state, props, and context pointers even</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-775" id="section-775"></a>
</div>
<p>if shouldComponentUpdate returns false.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      instance.props = newProps;
      instance.state = newState;
      instance.context = nextContext;
      <span class="hljs-keyword">return</span> shouldUpdate;
    }

    <span class="hljs-keyword">var</span> didWarnAboutMaps;
    <span class="hljs-keyword">var</span> didWarnAboutGenerators;
    <span class="hljs-keyword">var</span> didWarnAboutStringRefs;
    <span class="hljs-keyword">var</span> ownerHasKeyUseWarning;
    <span class="hljs-keyword">var</span> ownerHasFunctionTypeWarning;

    <span class="hljs-keyword">var</span> warnForMissingKey = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{};

    {
      didWarnAboutMaps = <span class="hljs-literal">false</span>;
      didWarnAboutGenerators = <span class="hljs-literal">false</span>;
      didWarnAboutStringRefs = {};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-776" id="section-776"></a>
</div>
<div class="dox">
<div class="summary">
<p>Warn if there's no key explicitly set on dynamic arrays of children or
object keys are not valid. This allows us to keep track of children between
updates.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      ownerHasKeyUseWarning = {};
      ownerHasFunctionTypeWarning = {};

      warnForMissingKey = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
        <span class="hljs-keyword">if</span> (child === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> child !== <span class="hljs-string">'object'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!child._store || child._store.validated || child.key != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> child._store === <span class="hljs-string">'object'</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }

        child._store.validated = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> currentComponentErrorInfo = <span class="hljs-string">'Each child in a list should have a unique '</span> + <span class="hljs-string">'"key" prop. See https://fb.me/react-warning-keys for '</span> + <span class="hljs-string">'more information.'</span> + getCurrentFiberStackInDev();

        <span class="hljs-keyword">if</span> (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          <span class="hljs-keyword">return</span>;
        }

        ownerHasKeyUseWarning[currentComponentErrorInfo] = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Each child in a list should have a unique '</span> + <span class="hljs-string">'"key" prop. See https://fb.me/react-warning-keys for '</span> + <span class="hljs-string">'more information.'</span>);
      };
    }
    <span class="hljs-keyword">var</span> isArray$<span class="hljs-number">1</span> = <span class="hljs-built_in">Array</span>.isArray;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coerceRef</span>(<span class="hljs-params">returnFiber, current, element</span>) </span>{
      <span class="hljs-keyword">var</span> mixedRef = element.ref;

      <span class="hljs-keyword">if</span> (mixedRef !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> mixedRef !== <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> mixedRef !== <span class="hljs-string">'object'</span>) {
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-777" id="section-777"></a>
</div>
<p>TODO: Clean this up once we turn on the string ref warning for
everyone, because the strict mode case will no longer be relevant</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> ((returnFiber.mode &amp; StrictMode || warnAboutStringRefs) &amp;&amp; <span class="hljs-comment">// We warn in ReactElement.js if owner and self are equal for string refs</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-778" id="section-778"></a>
</div>
<p>because these cannot be automatically converted to an arrow function
using a codemod. Therefore, we don't have to warn about string refs again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          !(element._owner &amp;&amp; element._self &amp;&amp; element._owner.stateNode !== element._self)) {
            <span class="hljs-keyword">var</span> componentName = getComponentName(returnFiber.type) || <span class="hljs-string">'Component'</span>;

            <span class="hljs-keyword">if</span> (!didWarnAboutStringRefs[componentName]) {
              {
                error(<span class="hljs-string">'A string ref, "%s", has been found within a strict mode tree. '</span> + <span class="hljs-string">'String refs are a source of potential bugs and should be avoided. '</span> + <span class="hljs-string">'We recommend using useRef() or createRef() instead. '</span> + <span class="hljs-string">'Learn more about using refs safely here: '</span> + <span class="hljs-string">'https://fb.me/react-strict-mode-string-ref%s'</span>, mixedRef, getStackByFiberInDevAndProd(returnFiber));
              }
              didWarnAboutStringRefs[componentName] = <span class="hljs-literal">true</span>;
            }
          }
        }

        <span class="hljs-keyword">if</span> (element._owner) {
          <span class="hljs-keyword">var</span> owner = element._owner;
          <span class="hljs-keyword">var</span> inst;

          <span class="hljs-keyword">if</span> (owner) {
            <span class="hljs-keyword">var</span> ownerFiber = owner;

            <span class="hljs-keyword">if</span> (!(ownerFiber.tag === ClassComponent)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref"</span>);
              }
            }

            inst = ownerFiber.stateNode;
          }

          <span class="hljs-keyword">if</span> (!inst) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Missing owner for string ref "</span> + mixedRef + <span class="hljs-string">". This error is likely caused by a bug in React. Please file an issue."</span>);
            }
          }

          <span class="hljs-keyword">var</span> stringRef = <span class="hljs-string">''</span> + mixedRef; <span class="hljs-comment">// Check if previous string ref matches new string ref</span>

          <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; current.ref !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> current.ref === <span class="hljs-string">'function'</span> &amp;&amp; current.ref._stringRef === stringRef) {
            <span class="hljs-keyword">return</span> current.ref;
          }

          <span class="hljs-keyword">var</span> ref = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">var</span> refs = inst.refs;

            <span class="hljs-keyword">if</span> (refs === emptyRefsObject) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-779" id="section-779"></a>
</div>
<p>This is a lazy pooled frozen object, so we need to initialize.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              refs = inst.refs = {};
            }

            <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">delete</span> refs[stringRef];
            } <span class="hljs-keyword">else</span> {
              refs[stringRef] = value;
            }
          };

          ref._stringRef = stringRef;
          <span class="hljs-keyword">return</span> ref;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> mixedRef === <span class="hljs-string">'string'</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected ref to be a function, a string, an object returned by React.createRef(), or null."</span>);
            }
          }

          <span class="hljs-keyword">if</span> (!element._owner) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Element ref was specified as a string ("</span> + mixedRef + <span class="hljs-string">") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information."</span>);
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> mixedRef;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwOnInvalidObjectType</span>(<span class="hljs-params">returnFiber, newChild</span>) </span>{
      <span class="hljs-keyword">if</span> (returnFiber.type !== <span class="hljs-string">'textarea'</span>) {
        <span class="hljs-keyword">var</span> addendum = <span class="hljs-string">''</span>;
        {
          addendum = <span class="hljs-string">' If you meant to render a collection of children, use an array '</span> + <span class="hljs-string">'instead.'</span> + getCurrentFiberStackInDev();
        }
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Objects are not valid as a React child (found: "</span> + (<span class="hljs-built_in">Object</span>.prototype.toString.call(newChild) === <span class="hljs-string">'[object Object]'</span> ? <span class="hljs-string">'object with keys {'</span> + <span class="hljs-built_in">Object</span>.keys(newChild).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'}'</span> : newChild) + <span class="hljs-string">")."</span> + addendum);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnOnFunctionType</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">var</span> currentComponentErrorInfo = <span class="hljs-string">'Functions are not valid as a React child. This may happen if '</span> + <span class="hljs-string">'you return a Component instead of &lt;Component /&gt; from render. '</span> + <span class="hljs-string">'Or maybe you meant to call this function rather than return it.'</span> + getCurrentFiberStackInDev();

        <span class="hljs-keyword">if</span> (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
          <span class="hljs-keyword">return</span>;
        }

        ownerHasFunctionTypeWarning[currentComponentErrorInfo] = <span class="hljs-literal">true</span>;
        error(<span class="hljs-string">'Functions are not valid as a React child. This may happen if '</span> + <span class="hljs-string">'you return a Component instead of &lt;Component /&gt; from render. '</span> + <span class="hljs-string">'Or maybe you meant to call this function rather than return it.'</span>);
      }
    } <span class="hljs-comment">// This wrapper function exists because I expect to clone the code in each path</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-780" id="section-780"></a>
</div>
<p>to be able to optimize each path individually by branching early. This needs
a compiler or we can do it manually. Helpers that don't need this branching
live outside of this function.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChildReconciler</span>(<span class="hljs-params">shouldTrackSideEffects</span>) </span>{
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteChild</span>(<span class="hljs-params">returnFiber, childToDelete</span>) </span>{
        <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-781" id="section-781"></a>
</div>
<p>Noop.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// Deletions are added in reversed order so we add it to the front.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-782" id="section-782"></a>
</div>
<p>At this point, the return fiber's effect list is empty except for
deletions, so we can just append the deletion to the list. The remaining
effects aren't added until the complete phase. Once we implement
resuming, this may not be true.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">var</span> last = returnFiber.lastEffect;

        <span class="hljs-keyword">if</span> (last !== <span class="hljs-literal">null</span>) {
          last.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } <span class="hljs-keyword">else</span> {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }

        childToDelete.nextEffect = <span class="hljs-literal">null</span>;
        childToDelete.effectTag = Deletion;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteRemainingChildren</span>(<span class="hljs-params">returnFiber, currentFirstChild</span>) </span>{
        <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-783" id="section-783"></a>
</div>
<p>Noop.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> For the shouldClone case, this could be micro-optimized a bit by</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-784" id="section-784"></a>
</div>
<p>assuming that after the first child we've already added everything.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">var</span> childToDelete = currentFirstChild;

        <span class="hljs-keyword">while</span> (childToDelete !== <span class="hljs-literal">null</span>) {
          deleteChild(returnFiber, childToDelete);
          childToDelete = childToDelete.sibling;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapRemainingChildren</span>(<span class="hljs-params">returnFiber, currentFirstChild</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-785" id="section-785"></a>
</div>
<p>Add the remaining children to a temporary map so that we can find them by
keys quickly. Implicit (null) keys get added to this set with their index
instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> existingChildren = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
        <span class="hljs-keyword">var</span> existingChild = currentFirstChild;

        <span class="hljs-keyword">while</span> (existingChild !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (existingChild.key !== <span class="hljs-literal">null</span>) {
            existingChildren.set(existingChild.key, existingChild);
          } <span class="hljs-keyword">else</span> {
            existingChildren.set(existingChild.index, existingChild);
          }

          existingChild = existingChild.sibling;
        }

        <span class="hljs-keyword">return</span> existingChildren;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFiber</span>(<span class="hljs-params">fiber, pendingProps</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-786" id="section-786"></a>
</div>
<p>We currently set sibling to null and index to 0 here because it is easy
to forget to do before returning it. E.g. for the single child case.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> clone = createWorkInProgress(fiber, pendingProps);
        clone.index = <span class="hljs-number">0</span>;
        clone.sibling = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> clone;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeChild</span>(<span class="hljs-params">newFiber, lastPlacedIndex, newIndex</span>) </span>{
        newFiber.index = newIndex;

        <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-787" id="section-787"></a>
</div>
<p>Noop.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> lastPlacedIndex;
        }

        <span class="hljs-keyword">var</span> current = newFiber.alternate;

        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> oldIndex = current.index;

          <span class="hljs-keyword">if</span> (oldIndex &lt; lastPlacedIndex) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-788" id="section-788"></a>
</div>
<p>This is a move.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            newFiber.effectTag = Placement;
            <span class="hljs-keyword">return</span> lastPlacedIndex;
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-789" id="section-789"></a>
</div>
<p>This item can stay in place.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> oldIndex;
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-790" id="section-790"></a>
</div>
<p>This is an insertion.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          newFiber.effectTag = Placement;
          <span class="hljs-keyword">return</span> lastPlacedIndex;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">placeSingleChild</span>(<span class="hljs-params">newFiber</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-791" id="section-791"></a>
</div>
<p>This is simpler for the single child case. We only need to do a
placement for inserting new children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.alternate === <span class="hljs-literal">null</span>) {
          newFiber.effectTag = Placement;
        }

        <span class="hljs-keyword">return</span> newFiber;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTextNode</span>(<span class="hljs-params">returnFiber, current, textContent, expirationTime</span>) </span>{
        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.tag !== HostText) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-792" id="section-792"></a>
</div>
<p>Insert</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          <span class="hljs-keyword">return</span> created;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-793" id="section-793"></a>
</div>
<p>Update</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> existing = useFiber(current, textContent);
          existing.return = returnFiber;
          <span class="hljs-keyword">return</span> existing;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateElement</span>(<span class="hljs-params">returnFiber, current, element, expirationTime</span>) </span>{
        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (current.elementType === element.type || <span class="hljs-comment">// Keep this check inline so it only runs on the false path:</span>
          isCompatibleFamilyForHotReloading(current, element)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-794" id="section-794"></a>
</div>
<p>Move based on index</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> existing = useFiber(current, element.props);
            existing.ref = coerceRef(returnFiber, current, element);
            existing.return = returnFiber;
            {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            <span class="hljs-keyword">return</span> existing;
          }
        } <span class="hljs-comment">// Insert</span>


        <span class="hljs-keyword">var</span> created = createFiberFromElement(element, returnFiber.mode, expirationTime);
        created.ref = coerceRef(returnFiber, current, element);
        created.return = returnFiber;
        <span class="hljs-keyword">return</span> created;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePortal</span>(<span class="hljs-params">returnFiber, current, portal, expirationTime</span>) </span>{
        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-795" id="section-795"></a>
</div>
<p>Insert</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          <span class="hljs-keyword">return</span> created;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-796" id="section-796"></a>
</div>
<p>Update</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> existing = useFiber(current, portal.children || []);
          existing.return = returnFiber;
          <span class="hljs-keyword">return</span> existing;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFragment</span>(<span class="hljs-params">returnFiber, current, fragment, expirationTime, key</span>) </span>{
        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.tag !== Fragment) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-797" id="section-797"></a>
</div>
<p>Insert</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
          created.return = returnFiber;
          <span class="hljs-keyword">return</span> created;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-798" id="section-798"></a>
</div>
<p>Update</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> existing = useFiber(current, fragment);
          existing.return = returnFiber;
          <span class="hljs-keyword">return</span> existing;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChild</span>(<span class="hljs-params">returnFiber, newChild, expirationTime</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'number'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-799" id="section-799"></a>
</div>
<p>Text nodes don't have keys. If the previous node is implicitly keyed
we can continue to replace it without aborting even if it is not a text
node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> created = createFiberFromText(<span class="hljs-string">''</span> + newChild, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          <span class="hljs-keyword">return</span> created;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
            <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
              {
                <span class="hljs-keyword">var</span> _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);

                _created.ref = coerceRef(returnFiber, <span class="hljs-literal">null</span>, newChild);
                _created.return = returnFiber;
                <span class="hljs-keyword">return</span> _created;
              }

            <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
              {
                <span class="hljs-keyword">var</span> _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);

                _created2.return = returnFiber;
                <span class="hljs-keyword">return</span> _created2;
              }
          }

          <span class="hljs-keyword">if</span> (isArray$<span class="hljs-number">1</span>(newChild) || getIteratorFn(newChild)) {
            <span class="hljs-keyword">var</span> _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, <span class="hljs-literal">null</span>);

            _created3.return = returnFiber;
            <span class="hljs-keyword">return</span> _created3;
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'function'</span>) {
            warnOnFunctionType();
          }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSlot</span>(<span class="hljs-params">returnFiber, oldFiber, newChild, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-800" id="section-800"></a>
</div>
<p>Update the fiber if the keys match, otherwise return null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> key = oldFiber !== <span class="hljs-literal">null</span> ? oldFiber.key : <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'number'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-801" id="section-801"></a>
</div>
<p>Text nodes don't have keys. If the previous node is implicitly keyed
we can continue to replace it without aborting even if it is not a text
node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> updateTextNode(returnFiber, oldFiber, <span class="hljs-string">''</span> + newChild, expirationTime);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
            <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
              {
                <span class="hljs-keyword">if</span> (newChild.key === key) {
                  <span class="hljs-keyword">if</span> (newChild.type === REACT_FRAGMENT_TYPE) {
                    <span class="hljs-keyword">return</span> updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                  }

                  <span class="hljs-keyword">return</span> updateElement(returnFiber, oldFiber, newChild, expirationTime);
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                }
              }

            <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
              {
                <span class="hljs-keyword">if</span> (newChild.key === key) {
                  <span class="hljs-keyword">return</span> updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                }
              }
          }

          <span class="hljs-keyword">if</span> (isArray$<span class="hljs-number">1</span>(newChild) || getIteratorFn(newChild)) {
            <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">return</span> updateFragment(returnFiber, oldFiber, newChild, expirationTime, <span class="hljs-literal">null</span>);
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'function'</span>) {
            warnOnFunctionType();
          }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFromMap</span>(<span class="hljs-params">existingChildren, returnFiber, newIdx, newChild, expirationTime</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'number'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-802" id="section-802"></a>
</div>
<p>Text nodes don't have keys, so we neither have to check the old nor
new node for the key. If both are text nodes, they match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> matchedFiber = existingChildren.get(newIdx) || <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">return</span> updateTextNode(returnFiber, matchedFiber, <span class="hljs-string">''</span> + newChild, expirationTime);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
            <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
              {
                <span class="hljs-keyword">var</span> _matchedFiber = existingChildren.get(newChild.key === <span class="hljs-literal">null</span> ? newIdx : newChild.key) || <span class="hljs-literal">null</span>;

                <span class="hljs-keyword">if</span> (newChild.type === REACT_FRAGMENT_TYPE) {
                  <span class="hljs-keyword">return</span> updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                }

                <span class="hljs-keyword">return</span> updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
              }

            <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
              {
                <span class="hljs-keyword">var</span> _matchedFiber2 = existingChildren.get(newChild.key === <span class="hljs-literal">null</span> ? newIdx : newChild.key) || <span class="hljs-literal">null</span>;

                <span class="hljs-keyword">return</span> updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
              }
          }

          <span class="hljs-keyword">if</span> (isArray$<span class="hljs-number">1</span>(newChild) || getIteratorFn(newChild)) {
            <span class="hljs-keyword">var</span> _matchedFiber3 = existingChildren.get(newIdx) || <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">return</span> updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, <span class="hljs-literal">null</span>);
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'function'</span>) {
            warnOnFunctionType();
          }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-803" id="section-803"></a>
</div>
<div class="dox">
<div class="summary">
<p>Warns if there is a duplicate or missing key</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnOnInvalidKey</span>(<span class="hljs-params">child, knownKeys</span>) </span>{
        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child !== <span class="hljs-string">'object'</span> || child === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> knownKeys;
          }

          <span class="hljs-keyword">switch</span> (child.$$<span class="hljs-keyword">typeof</span>) {
            <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
            <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
              warnForMissingKey(child);
              <span class="hljs-keyword">var</span> key = child.key;

              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">'string'</span>) {
                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">if</span> (knownKeys === <span class="hljs-literal">null</span>) {
                knownKeys = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
                knownKeys.add(key);
                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">if</span> (!knownKeys.has(key)) {
                knownKeys.add(key);
                <span class="hljs-keyword">break</span>;
              }

              error(<span class="hljs-string">'Encountered two children with the same key, `%s`. '</span> + <span class="hljs-string">'Keys should be unique so that components maintain their identity '</span> + <span class="hljs-string">'across updates. Non-unique keys may cause children to be '</span> + <span class="hljs-string">'duplicated and/or omitted — the behavior is unsupported and '</span> + <span class="hljs-string">'could change in a future version.'</span>, key);
              <span class="hljs-keyword">break</span>;
          }
        }
        <span class="hljs-keyword">return</span> knownKeys;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildrenArray</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChildren, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-804" id="section-804"></a>
</div>
<p>This algorithm can't optimize by searching from both ends since we
don't have backpointers on fibers. I'm trying to see how far we can get
with that model. If it ends up not being worth the tradeoffs, we can
add it later.
Even with a two ended optimization, we'd want to optimize for the case
where there are few changes and brute force the comparison instead of
going for the Map. It'd like to explore hitting that path first in
forward-only mode and only go for the Map once we notice that we need
lots of look ahead. This doesn't handle reversal as well as two ended
search but that's unusual. Besides, for the two ended optimization to
work on Iterables, we'd need to copy the whole set.
In this first iteration, we'll just live with hitting the bad case
(adding everything to a Map) in for every insert/move.
If you change this code, also update reconcileChildrenIterator() which
uses the same algorithm.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-805" id="section-805"></a>
</div>
<p>First, validate keys.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> knownKeys = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; newChildren.length; i++) {
            <span class="hljs-keyword">var</span> child = newChildren[i];
            knownKeys = warnOnInvalidKey(child, knownKeys);
          }
        }
        <span class="hljs-keyword">var</span> resultingFirstChild = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> previousNewFiber = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> oldFiber = currentFirstChild;
        <span class="hljs-keyword">var</span> lastPlacedIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> newIdx = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> nextOldFiber = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) {
          <span class="hljs-keyword">if</span> (oldFiber.index &gt; newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">else</span> {
            nextOldFiber = oldFiber.sibling;
          }

          <span class="hljs-keyword">var</span> newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

          <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-806" id="section-806"></a>
</div>
<p>TODO: This breaks on empty slots like null children. That's
unfortunate because it triggers the slow path all the time. We need
a better way to communicate whether this was a miss or null,
boolean, undefined, etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {
              oldFiber = nextOldFiber;
            }

            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
            <span class="hljs-keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-807" id="section-807"></a>
</div>
<p>We matched the slot, but we didn't reuse the existing fiber, so we
need to delete the existing child.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              deleteChild(returnFiber, oldFiber);
            }
          }

          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

          <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-808" id="section-808"></a>
</div>
<p>TODO: Move out of the loop. This only happens for the first run.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            resultingFirstChild = newFiber;
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-809" id="section-809"></a>
</div>
<p>TODO: Defer siblings if we're not at the right index for this slot.
I.e. if we had null values before, then we want to defer this
for each null value. However, we also don't want to call updateSlot
with the previous one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            previousNewFiber.sibling = newFiber;
          }

          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        <span class="hljs-keyword">if</span> (newIdx === newChildren.length) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-810" id="section-810"></a>
</div>
<p>We've reached the end of the new children. We can delete the rest.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          deleteRemainingChildren(returnFiber, oldFiber);
          <span class="hljs-keyword">return</span> resultingFirstChild;
        }

        <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-811" id="section-811"></a>
</div>
<p>If we don't have any more existing children we can choose a fast path
since the rest will all be insertions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) {
            <span class="hljs-keyword">var</span> _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);

            <span class="hljs-keyword">if</span> (_newFiber === <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">continue</span>;
            }

            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

            <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-812" id="section-812"></a>
</div>
<p>TODO: Move out of the loop. This only happens for the first run.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              resultingFirstChild = _newFiber;
            } <span class="hljs-keyword">else</span> {
              previousNewFiber.sibling = _newFiber;
            }

            previousNewFiber = _newFiber;
          }

          <span class="hljs-keyword">return</span> resultingFirstChild;
        } <span class="hljs-comment">// Add all children to a key map for quick lookups.</span>


        <span class="hljs-keyword">var</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber); <span class="hljs-comment">// Keep scanning and use the map to restore deleted items as moves.</span>

        <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) {
          <span class="hljs-keyword">var</span> _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);

          <span class="hljs-keyword">if</span> (_newFiber2 !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
              <span class="hljs-keyword">if</span> (_newFiber2.alternate !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-813" id="section-813"></a>
</div>
<p>The new fiber is a work in progress, but if there exists a
current, that means that we reused the fiber. We need to delete
it from the child list so that we don't add it to the deletion
list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                existingChildren.delete(_newFiber2.key === <span class="hljs-literal">null</span> ? newIdx : _newFiber2.key);
              }
            }

            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

            <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
              resultingFirstChild = _newFiber2;
            } <span class="hljs-keyword">else</span> {
              previousNewFiber.sibling = _newFiber2;
            }

            previousNewFiber = _newFiber2;
          }
        }

        <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-814" id="section-814"></a>
</div>
<p>Any existing children that weren't consumed above were deleted. We need
to add them to the deletion list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          existingChildren.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
            <span class="hljs-keyword">return</span> deleteChild(returnFiber, child);
          });
        }

        <span class="hljs-keyword">return</span> resultingFirstChild;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildrenIterator</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChildrenIterable, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-815" id="section-815"></a>
</div>
<p>This is the same implementation as reconcileChildrenArray(),
but using the iterator instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> iteratorFn = getIteratorFn(newChildrenIterable);

        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> iteratorFn === <span class="hljs-string">'function'</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."</span>);
          }
        }

        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-816" id="section-816"></a>
</div>
<p>We don't support rendering Generators because it's a mutation.
See https://github.com/facebook/react/issues/12995</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-comment">// $FlowFixMe Flow doesn't know about toStringTag</span>
          newChildrenIterable[<span class="hljs-built_in">Symbol</span>.toStringTag] === <span class="hljs-string">'Generator'</span>) {
            <span class="hljs-keyword">if</span> (!didWarnAboutGenerators) {
              error(<span class="hljs-string">'Using Generators as children is unsupported and will likely yield '</span> + <span class="hljs-string">'unexpected results because enumerating a generator mutates it. '</span> + <span class="hljs-string">'You may convert it to an array with `Array.from()` or the '</span> + <span class="hljs-string">'`[...spread]` operator before rendering. Keep in mind '</span> + <span class="hljs-string">'you might need to polyfill these features for older browsers.'</span>);
            }

            didWarnAboutGenerators = <span class="hljs-literal">true</span>;
          } <span class="hljs-comment">// Warn about using Maps as children</span>


          <span class="hljs-keyword">if</span> (newChildrenIterable.entries === iteratorFn) {
            <span class="hljs-keyword">if</span> (!didWarnAboutMaps) {
              error(<span class="hljs-string">'Using Maps as children is unsupported and will likely yield '</span> + <span class="hljs-string">'unexpected results. Convert it to a sequence/iterable of keyed '</span> + <span class="hljs-string">'ReactElements instead.'</span>);
            }

            didWarnAboutMaps = <span class="hljs-literal">true</span>;
          } <span class="hljs-comment">// First, validate keys.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-817" id="section-817"></a>
</div>
<p>We'll get a different iterator later for the main pass.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          <span class="hljs-keyword">var</span> _newChildren = iteratorFn.call(newChildrenIterable);

          <span class="hljs-keyword">if</span> (_newChildren) {
            <span class="hljs-keyword">var</span> knownKeys = <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">var</span> _step = _newChildren.next();

            <span class="hljs-keyword">for</span> (; !_step.done; _step = _newChildren.next()) {
              <span class="hljs-keyword">var</span> child = _step.value;
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
        }
        <span class="hljs-keyword">var</span> newChildren = iteratorFn.call(newChildrenIterable);

        <span class="hljs-keyword">if</span> (!(newChildren != <span class="hljs-literal">null</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"An iterable object provided no iterator."</span>);
          }
        }

        <span class="hljs-keyword">var</span> resultingFirstChild = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> previousNewFiber = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> oldFiber = currentFirstChild;
        <span class="hljs-keyword">var</span> lastPlacedIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> newIdx = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> nextOldFiber = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> step = newChildren.next();

        <span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; !step.done; newIdx++, step = newChildren.next()) {
          <span class="hljs-keyword">if</span> (oldFiber.index &gt; newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">else</span> {
            nextOldFiber = oldFiber.sibling;
          }

          <span class="hljs-keyword">var</span> newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);

          <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-818" id="section-818"></a>
</div>
<p>TODO: This breaks on empty slots like null children. That's
unfortunate because it triggers the slow path all the time. We need
a better way to communicate whether this was a miss or null,
boolean, undefined, etc.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {
              oldFiber = nextOldFiber;
            }

            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
            <span class="hljs-keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-819" id="section-819"></a>
</div>
<p>We matched the slot, but we didn't reuse the existing fiber, so we
need to delete the existing child.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              deleteChild(returnFiber, oldFiber);
            }
          }

          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

          <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-820" id="section-820"></a>
</div>
<p>TODO: Move out of the loop. This only happens for the first run.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            resultingFirstChild = newFiber;
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-821" id="section-821"></a>
</div>
<p>TODO: Defer siblings if we're not at the right index for this slot.
I.e. if we had null values before, then we want to defer this
for each null value. However, we also don't want to call updateSlot
with the previous one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            previousNewFiber.sibling = newFiber;
          }

          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        <span class="hljs-keyword">if</span> (step.done) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-822" id="section-822"></a>
</div>
<p>We've reached the end of the new children. We can delete the rest.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          deleteRemainingChildren(returnFiber, oldFiber);
          <span class="hljs-keyword">return</span> resultingFirstChild;
        }

        <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-823" id="section-823"></a>
</div>
<p>If we don't have any more existing children we can choose a fast path
since the rest will all be insertions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">for</span> (; !step.done; newIdx++, step = newChildren.next()) {
            <span class="hljs-keyword">var</span> _newFiber3 = createChild(returnFiber, step.value, expirationTime);

            <span class="hljs-keyword">if</span> (_newFiber3 === <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">continue</span>;
            }

            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

            <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-824" id="section-824"></a>
</div>
<p>TODO: Move out of the loop. This only happens for the first run.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              resultingFirstChild = _newFiber3;
            } <span class="hljs-keyword">else</span> {
              previousNewFiber.sibling = _newFiber3;
            }

            previousNewFiber = _newFiber3;
          }

          <span class="hljs-keyword">return</span> resultingFirstChild;
        } <span class="hljs-comment">// Add all children to a key map for quick lookups.</span>


        <span class="hljs-keyword">var</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber); <span class="hljs-comment">// Keep scanning and use the map to restore deleted items as moves.</span>

        <span class="hljs-keyword">for</span> (; !step.done; newIdx++, step = newChildren.next()) {
          <span class="hljs-keyword">var</span> _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);

          <span class="hljs-keyword">if</span> (_newFiber4 !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
              <span class="hljs-keyword">if</span> (_newFiber4.alternate !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-825" id="section-825"></a>
</div>
<p>The new fiber is a work in progress, but if there exists a
current, that means that we reused the fiber. We need to delete
it from the child list so that we don't add it to the deletion
list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                existingChildren.delete(_newFiber4.key === <span class="hljs-literal">null</span> ? newIdx : _newFiber4.key);
              }
            }

            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

            <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
              resultingFirstChild = _newFiber4;
            } <span class="hljs-keyword">else</span> {
              previousNewFiber.sibling = _newFiber4;
            }

            previousNewFiber = _newFiber4;
          }
        }

        <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-826" id="section-826"></a>
</div>
<p>Any existing children that weren't consumed above were deleted. We need
to add them to the deletion list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          existingChildren.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{
            <span class="hljs-keyword">return</span> deleteChild(returnFiber, child);
          });
        }

        <span class="hljs-keyword">return</span> resultingFirstChild;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleTextNode</span>(<span class="hljs-params">returnFiber, currentFirstChild, textContent, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-827" id="section-827"></a>
</div>
<p>There's no need to check for keys on text nodes since we don't have a
way to define them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (currentFirstChild !== <span class="hljs-literal">null</span> &amp;&amp; currentFirstChild.tag === HostText) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-828" id="section-828"></a>
</div>
<p>We already have an existing node so let's just update it and delete
the rest.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
          <span class="hljs-keyword">var</span> existing = useFiber(currentFirstChild, textContent);
          existing.return = returnFiber;
          <span class="hljs-keyword">return</span> existing;
        } <span class="hljs-comment">// The existing first child is not a text node so we need to create one</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-829" id="section-829"></a>
</div>
<p>and delete the existing ones.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        deleteRemainingChildren(returnFiber, currentFirstChild);
        <span class="hljs-keyword">var</span> created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
        created.return = returnFiber;
        <span class="hljs-keyword">return</span> created;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSingleElement</span>(<span class="hljs-params">returnFiber, currentFirstChild, element, expirationTime</span>) </span>{
        <span class="hljs-keyword">var</span> key = element.key;
        <span class="hljs-keyword">var</span> child = currentFirstChild;

        <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-830" id="section-830"></a>
</div>
<p>TODO: If key === null and child.key === null, then this only applies to
the first item in the list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (child.key === key) {
            <span class="hljs-keyword">switch</span> (child.tag) {
              <span class="hljs-keyword">case</span> Fragment:
                {
                  <span class="hljs-keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    <span class="hljs-keyword">var</span> existing = useFiber(child, element.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element._source;
                      existing._debugOwner = element._owner;
                    }
                    <span class="hljs-keyword">return</span> existing;
                  }

                  <span class="hljs-keyword">break</span>;
                }

              <span class="hljs-keyword">case</span> Block: <span class="hljs-comment">// We intentionally fallthrough here if enableBlocksAPI is not on.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-831" id="section-831"></a>
</div>
<p>eslint-disable-next-lined no-fallthrough</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              <span class="hljs-attr">default</span>:
                {
                  <span class="hljs-keyword">if</span> (child.elementType === element.type || <span class="hljs-comment">// Keep this check inline so it only runs on the false path:</span>
                  isCompatibleFamilyForHotReloading(child, element)) {
                    deleteRemainingChildren(returnFiber, child.sibling);

                    <span class="hljs-keyword">var</span> _existing3 = useFiber(child, element.props);

                    _existing3.ref = coerceRef(returnFiber, child, element);
                    _existing3.return = returnFiber;
                    {
                      _existing3._debugSource = element._source;
                      _existing3._debugOwner = element._owner;
                    }
                    <span class="hljs-keyword">return</span> _existing3;
                  }

                  <span class="hljs-keyword">break</span>;
                }
            } <span class="hljs-comment">// Didn't match.</span>


            deleteRemainingChildren(returnFiber, child);
            <span class="hljs-keyword">break</span>;
          } <span class="hljs-keyword">else</span> {
            deleteChild(returnFiber, child);
          }

          child = child.sibling;
        }

        <span class="hljs-keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) {
          <span class="hljs-keyword">var</span> created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
          created.return = returnFiber;
          <span class="hljs-keyword">return</span> created;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);

          _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
          _created4.return = returnFiber;
          <span class="hljs-keyword">return</span> _created4;
        }
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileSinglePortal</span>(<span class="hljs-params">returnFiber, currentFirstChild, portal, expirationTime</span>) </span>{
        <span class="hljs-keyword">var</span> key = portal.key;
        <span class="hljs-keyword">var</span> child = currentFirstChild;

        <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-832" id="section-832"></a>
</div>
<p>TODO: If key === null and child.key === null, then this only applies to
the first item in the list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (child.key === key) {
            <span class="hljs-keyword">if</span> (child.tag === HostPortal &amp;&amp; child.stateNode.containerInfo === portal.containerInfo &amp;&amp; child.stateNode.implementation === portal.implementation) {
              deleteRemainingChildren(returnFiber, child.sibling);
              <span class="hljs-keyword">var</span> existing = useFiber(child, portal.children || []);
              existing.return = returnFiber;
              <span class="hljs-keyword">return</span> existing;
            } <span class="hljs-keyword">else</span> {
              deleteRemainingChildren(returnFiber, child);
              <span class="hljs-keyword">break</span>;
            }
          } <span class="hljs-keyword">else</span> {
            deleteChild(returnFiber, child);
          }

          child = child.sibling;
        }

        <span class="hljs-keyword">var</span> created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
        created.return = returnFiber;
        <span class="hljs-keyword">return</span> created;
      } <span class="hljs-comment">// This API will tag the children with the side-effect of the reconciliation</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-833" id="section-833"></a>
</div>
<p>itself. They will be added to the side-effect list as we pass through the
children and the parent.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildFibers</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChild, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-834" id="section-834"></a>
</div>
<p>This function is not recursive.
If the top level item is an array, we treat it as a set of children,
not as a fragment. Nested arrays on the other hand will be treated as
fragment nodes. Recursion happens at the normal flow.
Handle top level unkeyed fragments as if they were arrays.
This leads to an ambiguity between &lt;&gt;{[...]}&lt;/&gt; and &lt;&gt;...&lt;/&gt;.
We treat the ambiguous cases above the same.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> isUnkeyedTopLevelFragment = <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span> &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (isUnkeyedTopLevelFragment) {
          newChild = newChild.props.children;
        } <span class="hljs-comment">// Handle object types</span>


        <span class="hljs-keyword">var</span> isObject = <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'object'</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (isObject) {
          <span class="hljs-keyword">switch</span> (newChild.$$<span class="hljs-keyword">typeof</span>) {
            <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE:
              <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

            <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE:
              <span class="hljs-keyword">return</span> placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'number'</span>) {
          <span class="hljs-keyword">return</span> placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, <span class="hljs-string">''</span> + newChild, expirationTime));
        }

        <span class="hljs-keyword">if</span> (isArray$<span class="hljs-number">1</span>(newChild)) {
          <span class="hljs-keyword">return</span> reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
        }

        <span class="hljs-keyword">if</span> (getIteratorFn(newChild)) {
          <span class="hljs-keyword">return</span> reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
        }

        <span class="hljs-keyword">if</span> (isObject) {
          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'function'</span>) {
            warnOnFunctionType();
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">'undefined'</span> &amp;&amp; !isUnkeyedTopLevelFragment) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-835" id="section-835"></a>
</div>
<p>If the new child is undefined, and the return fiber is a composite
component, throw an error. If Fiber return types are disabled,
we already threw above.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">switch</span> (returnFiber.tag) {
            <span class="hljs-keyword">case</span> ClassComponent:
              {
                {
                  <span class="hljs-keyword">var</span> instance = returnFiber.stateNode;

                  <span class="hljs-keyword">if</span> (instance.render._isMockFunction) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-836" id="section-836"></a>
</div>
<p>We allow auto-mocks to proceed as if they're returning null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    <span class="hljs-keyword">break</span>;
                  }
                }
              }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-837" id="section-837"></a>
</div>
<p>Intentionally fall through to the next case, which handles both
functions and classes
eslint-disable-next-lined no-fallthrough</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">case</span> FunctionComponent:
              {
                <span class="hljs-keyword">var</span> Component = returnFiber.type;
                {
                  {
                    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>((Component.displayName || Component.name || <span class="hljs-string">'Component'</span>) + <span class="hljs-string">"(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null."</span>);
                  }
                }
              }
          }
        } <span class="hljs-comment">// Remaining cases are all treated as empty.</span>


        <span class="hljs-keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);
      }

      <span class="hljs-keyword">return</span> reconcileChildFibers;
    }

    <span class="hljs-keyword">var</span> reconcileChildFibers = ChildReconciler(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">var</span> mountChildFibers = ChildReconciler(<span class="hljs-literal">false</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneChildFibers</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
      <span class="hljs-keyword">if</span> (!(current === <span class="hljs-literal">null</span> || workInProgress.child === current.child)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Resuming work not yet implemented."</span>);
        }
      }

      <span class="hljs-keyword">if</span> (workInProgress.child === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> currentChild = workInProgress.child;
      <span class="hljs-keyword">var</span> newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
      workInProgress.child = newChild;
      newChild.return = workInProgress;

      <span class="hljs-keyword">while</span> (currentChild.sibling !== <span class="hljs-literal">null</span>) {
        currentChild = currentChild.sibling;
        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
        newChild.return = workInProgress;
      }

      newChild.sibling = <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// Reset a workInProgress child set to prepare it for a second pass.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetChildFibers</span>(<span class="hljs-params">workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> child = workInProgress.child;

      <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
        resetWorkInProgress(child, renderExpirationTime);
        child = child.sibling;
      }
    }

    <span class="hljs-keyword">var</span> NO_CONTEXT = {};
    <span class="hljs-keyword">var</span> contextStackCursor$<span class="hljs-number">1</span> = createCursor(NO_CONTEXT);
    <span class="hljs-keyword">var</span> contextFiberStackCursor = createCursor(NO_CONTEXT);
    <span class="hljs-keyword">var</span> rootInstanceStackCursor = createCursor(NO_CONTEXT);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requiredContext</span>(<span class="hljs-params">c</span>) </span>{
      <span class="hljs-keyword">if</span> (!(c !== NO_CONTEXT)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }

      <span class="hljs-keyword">return</span> c;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRootHostContainer</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> rootInstance = requiredContext(rootInstanceStackCursor.current);
      <span class="hljs-keyword">return</span> rootInstance;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushHostContainer</span>(<span class="hljs-params">fiber, nextRootInstance</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-838" id="section-838"></a>
</div>
<p>Push current root instance onto the stack;
This allows us to reset root when portals are popped.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      push(rootInstanceStackCursor, nextRootInstance, fiber); <span class="hljs-comment">// Track the context and the Fiber that provided it.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-839" id="section-839"></a>
</div>
<p>This enables us to pop only Fibers that provide unique contexts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      push(contextFiberStackCursor, fiber, fiber); <span class="hljs-comment">// Finally, we need to push the host context to the stack.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-840" id="section-840"></a>
</div>
<p>However, we can't just call getRootHostContext() and push it because
we'd have a different number of entries on the stack depending on
whether getRootHostContext() throws somewhere in renderer code or not.
So we push an empty value first. This lets us safely unwind on errors.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      push(contextStackCursor$<span class="hljs-number">1</span>, NO_CONTEXT, fiber);
      <span class="hljs-keyword">var</span> nextRootContext = getRootHostContext(nextRootInstance); <span class="hljs-comment">// Now that we know this function doesn't throw, replace it.</span>

      pop(contextStackCursor$<span class="hljs-number">1</span>, fiber);
      push(contextStackCursor$<span class="hljs-number">1</span>, nextRootContext, fiber);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popHostContainer</span>(<span class="hljs-params">fiber</span>) </span>{
      pop(contextStackCursor$<span class="hljs-number">1</span>, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHostContext</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> context = requiredContext(contextStackCursor$<span class="hljs-number">1.</span>current);
      <span class="hljs-keyword">return</span> context;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushHostContext</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> rootInstance = requiredContext(rootInstanceStackCursor.current);
      <span class="hljs-keyword">var</span> context = requiredContext(contextStackCursor$<span class="hljs-number">1.</span>current);
      <span class="hljs-keyword">var</span> nextContext = getChildHostContext(context, fiber.type); <span class="hljs-comment">// Don't push this Fiber's context unless it's unique.</span>

      <span class="hljs-keyword">if</span> (context === nextContext) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// Track the context and the Fiber that provided it.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-841" id="section-841"></a>
</div>
<p>This enables us to pop only Fibers that provide unique contexts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor$<span class="hljs-number">1</span>, nextContext, fiber);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popHostContext</span>(<span class="hljs-params">fiber</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-842" id="section-842"></a>
</div>
<p>Do not pop unless this Fiber provided the current context.
pushHostContext() only pushes Fibers that provide unique contexts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (contextFiberStackCursor.current !== fiber) {
        <span class="hljs-keyword">return</span>;
      }

      pop(contextStackCursor$<span class="hljs-number">1</span>, fiber);
      pop(contextFiberStackCursor, fiber);
    }

    <span class="hljs-keyword">var</span> DefaultSuspenseContext = <span class="hljs-number">0</span>; <span class="hljs-comment">// The Suspense Context is split into two parts. The lower bits is</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-843" id="section-843"></a>
</div>
<p>inherited deeply down the subtree. The upper bits only affect
this immediate suspense boundary and gets reset each new
boundary or suspense list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> SubtreeSuspenseContextMask = <span class="hljs-number">1</span>; <span class="hljs-comment">// Subtree Flags:</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-844" id="section-844"></a>
</div>
<p>InvisibleParentSuspenseContext indicates that one of our parent Suspense
boundaries is not currently showing visible main content.
Either because it is already showing a fallback or is not mounted at all.
We can use this to determine if it is desirable to trigger a fallback at
the parent. If not, then we might need to trigger undesirable boundaries
and/or suspend the commit to avoid hiding the parent content.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> InvisibleParentSuspenseContext = <span class="hljs-number">1</span>; <span class="hljs-comment">// Shallow Flags:</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-845" id="section-845"></a>
</div>
<p>ForceSuspenseFallback can be used by SuspenseList to force newly added
items into their fallback state during one of the render passes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> ForceSuspenseFallback = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> suspenseStackCursor = createCursor(DefaultSuspenseContext);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasSuspenseContext</span>(<span class="hljs-params">parentContext, flag</span>) </span>{
      <span class="hljs-keyword">return</span> (parentContext &amp; flag) !== <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDefaultShallowSuspenseContext</span>(<span class="hljs-params">parentContext</span>) </span>{
      <span class="hljs-keyword">return</span> parentContext &amp; SubtreeSuspenseContextMask;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setShallowSuspenseContext</span>(<span class="hljs-params">parentContext, shallowContext</span>) </span>{
      <span class="hljs-keyword">return</span> parentContext &amp; SubtreeSuspenseContextMask | shallowContext;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSubtreeSuspenseContext</span>(<span class="hljs-params">parentContext, subtreeContext</span>) </span>{
      <span class="hljs-keyword">return</span> parentContext | subtreeContext;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushSuspenseContext</span>(<span class="hljs-params">fiber, newContext</span>) </span>{
      push(suspenseStackCursor, newContext, fiber);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popSuspenseContext</span>(<span class="hljs-params">fiber</span>) </span>{
      pop(suspenseStackCursor, fiber);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldCaptureSuspense</span>(<span class="hljs-params">workInProgress, hasInvisibleParent</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-846" id="section-846"></a>
</div>
<p>If it was the primary children that just suspended, capture and render the
fallback. Otherwise, don't capture and bubble to the next boundary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> nextState = workInProgress.memoizedState;

      <span class="hljs-keyword">if</span> (nextState !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (nextState.dehydrated !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-847" id="section-847"></a>
</div>
<p>A dehydrated boundary always captures.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> props = workInProgress.memoizedProps; <span class="hljs-comment">// In order to capture, the Suspense component must have a fallback prop.</span>

      <span class="hljs-keyword">if</span> (props.fallback === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-comment">// Regular boundaries always capture.</span>


      <span class="hljs-keyword">if</span> (props.unstable_avoidThisFallback !== <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-comment">// If it's a boundary we should avoid, then we prefer to bubble up to the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-848" id="section-848"></a>
</div>
<p>parent boundary if it is currently invisible.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (hasInvisibleParent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-comment">// If the parent is not able to handle it, we must handle it.</span>


      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFirstSuspended</span>(<span class="hljs-params">row</span>) </span>{
      <span class="hljs-keyword">var</span> node = row;

      <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.tag === SuspenseComponent) {
          <span class="hljs-keyword">var</span> state = node.memoizedState;

          <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> dehydrated = state.dehydrated;

            <span class="hljs-keyword">if</span> (dehydrated === <span class="hljs-literal">null</span> || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
              <span class="hljs-keyword">return</span> node;
            }
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.tag === SuspenseListComponent &amp;&amp; <span class="hljs-comment">// revealOrder undefined can't be trusted because it don't</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-849" id="section-849"></a>
</div>
<p>keep track of whether it suspended or not.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        node.memoizedProps.revealOrder !== <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">var</span> didSuspend = (node.effectTag &amp; DidCapture) !== NoEffect;

          <span class="hljs-keyword">if</span> (didSuspend) {
            <span class="hljs-keyword">return</span> node;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
          node.child.return = node;
          node = node.child;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === row) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === row) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDeprecatedResponderListener</span>(<span class="hljs-params">responder, props</span>) </span>{
      <span class="hljs-keyword">var</span> eventResponderListener = {
        <span class="hljs-attr">responder</span>: responder,
        <span class="hljs-attr">props</span>: props
      };
      {
        <span class="hljs-built_in">Object</span>.freeze(eventResponderListener);
      }
      <span class="hljs-keyword">return</span> eventResponderListener;
    }

    <span class="hljs-keyword">var</span> HasEffect =
    <span class="hljs-comment">/* */</span>
    <span class="hljs-number">1</span>; <span class="hljs-comment">// Represents the phase in which the effect (not the clean-up) fires.</span>

    <span class="hljs-keyword">var</span> Layout =
    <span class="hljs-comment">/*    */</span>
    <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> Passive$<span class="hljs-number">1</span> =
    <span class="hljs-comment">/*   */</span>
    <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
        ReactCurrentBatchConfig$<span class="hljs-number">1</span> = ReactSharedInternals.ReactCurrentBatchConfig;
    <span class="hljs-keyword">var</span> didWarnAboutMismatchedHooksForComponent;
    {
      didWarnAboutMismatchedHooksForComponent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    } <span class="hljs-comment">// These are set right before calling the component.</span>

    <span class="hljs-keyword">var</span> renderExpirationTime = NoWork; <span class="hljs-comment">// The work-in-progress fiber. I've named it differently to distinguish it from</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-850" id="section-850"></a>
</div>
<p>the work-in-progress hook.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> currentlyRenderingFiber$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Hooks are stored as a linked list on the fiber's memoizedState field. The</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-851" id="section-851"></a>
</div>
<p>current hook list is the list that belongs to the current fiber. The
work-in-progress hook list is a new list that will be added to the
work-in-progress fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> currentHook = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> workInProgressHook = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Whether an update was scheduled at any point during the render phase. This</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-852" id="section-852"></a>
</div>
<p>does not get reset if we do another render pass; only when we're completely
finished evaluating this component. This is an optimization so we know
whether we need to clear render phase updates after a throw.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> didScheduleRenderPhaseUpdate = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> RE_RENDER_LIMIT = <span class="hljs-number">25</span>; <span class="hljs-comment">// In DEV, this is the name of the currently executing primitive hook</span>

    <span class="hljs-keyword">var</span> currentHookNameInDev = <span class="hljs-literal">null</span>; <span class="hljs-comment">// In DEV, this list ensures that hooks are called in the same order between renders.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-853" id="section-853"></a>
</div>
<p>The list stores the order of hooks used during the initial render (mount).
Subsequent renders (updates) reference this list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> hookTypesDev = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> hookTypesUpdateIndexDev = <span class="hljs-number">-1</span>; <span class="hljs-comment">// In DEV, this tracks whether currently rendering component needs to ignore</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-854" id="section-854"></a>
</div>
<p>the dependencies for Hooks that need them (e.g. useEffect or useMemo).
When true, such Hooks will always be &quot;remounted&quot;. Only used during hot reload.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> ignorePreviousDependencies = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountHookTypesDev</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">var</span> hookName = currentHookNameInDev;

        <span class="hljs-keyword">if</span> (hookTypesDev === <span class="hljs-literal">null</span>) {
          hookTypesDev = [hookName];
        } <span class="hljs-keyword">else</span> {
          hookTypesDev.push(hookName);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHookTypesDev</span>(<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">var</span> hookName = currentHookNameInDev;

        <span class="hljs-keyword">if</span> (hookTypesDev !== <span class="hljs-literal">null</span>) {
          hookTypesUpdateIndexDev++;

          <span class="hljs-keyword">if</span> (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
            warnOnHookMismatchInDev(hookName);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkDepsAreArrayDev</span>(<span class="hljs-params">deps</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (deps !== <span class="hljs-literal">undefined</span> &amp;&amp; deps !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">Array</span>.isArray(deps)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-855" id="section-855"></a>
</div>
<p>Verify deps, but only on mount to avoid extra checks.
It's unlikely their type would change as usually you define them inline.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          error(<span class="hljs-string">'%s received a final argument that is not an array (instead, received `%s`). When '</span> + <span class="hljs-string">'specified, the final argument must be an array.'</span>, currentHookNameInDev, <span class="hljs-keyword">typeof</span> deps);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnOnHookMismatchInDev</span>(<span class="hljs-params">currentHookName</span>) </span>{
      {
        <span class="hljs-keyword">var</span> componentName = getComponentName(currentlyRenderingFiber$<span class="hljs-number">1.</span>type);

        <span class="hljs-keyword">if</span> (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
          didWarnAboutMismatchedHooksForComponent.add(componentName);

          <span class="hljs-keyword">if</span> (hookTypesDev !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> table = <span class="hljs-string">''</span>;
            <span class="hljs-keyword">var</span> secondColumnStart = <span class="hljs-number">30</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= hookTypesUpdateIndexDev; i++) {
              <span class="hljs-keyword">var</span> oldHookName = hookTypesDev[i];
              <span class="hljs-keyword">var</span> newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
              <span class="hljs-keyword">var</span> row = i + <span class="hljs-number">1</span> + <span class="hljs-string">". "</span> + oldHookName; <span class="hljs-comment">// Extra space so second column lines up</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-856" id="section-856"></a>
</div>
<p>lol @ IE not supporting String#repeat</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              <span class="hljs-keyword">while</span> (row.length &lt; secondColumnStart) {
                row += <span class="hljs-string">' '</span>;
              }

              row += newHookName + <span class="hljs-string">'\n'</span>;
              table += row;
            }

            error(<span class="hljs-string">'React has detected a change in the order of Hooks called by %s. '</span> + <span class="hljs-string">'This will lead to bugs and errors if not fixed. '</span> + <span class="hljs-string">'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n'</span> + <span class="hljs-string">'   Previous render            Next render\n'</span> + <span class="hljs-string">'   ------------------------------------------------------\n'</span> + <span class="hljs-string">'%s'</span> + <span class="hljs-string">'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n'</span>, componentName, table);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwInvalidHookError</span>(<span class="hljs-params"></span>) </span>{
      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areHookInputsEqual</span>(<span class="hljs-params">nextDeps, prevDeps</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (ignorePreviousDependencies) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-857" id="section-857"></a>
</div>
<p>Only true when this component is being hot reloaded.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }

      <span class="hljs-keyword">if</span> (prevDeps === <span class="hljs-literal">null</span>) {
        {
          error(<span class="hljs-string">'%s received a final argument during this render, but not during '</span> + <span class="hljs-string">'the previous render. Even though the final argument is optional, '</span> + <span class="hljs-string">'its type cannot change between renders.'</span>, currentHookNameInDev);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-858" id="section-858"></a>
</div>
<p>Don't bother comparing lengths in prod because these arrays should be
passed inline.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (nextDeps.length !== prevDeps.length) {
          error(<span class="hljs-string">'The final argument passed to %s changed size between renders. The '</span> + <span class="hljs-string">'order and size of this array must remain constant.\n\n'</span> + <span class="hljs-string">'Previous: %s\n'</span> + <span class="hljs-string">'Incoming: %s'</span>, currentHookNameInDev, <span class="hljs-string">"["</span> + prevDeps.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">"]"</span>, <span class="hljs-string">"["</span> + nextDeps.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">"]"</span>);
        }
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {
        <span class="hljs-keyword">if</span> (objectIs(nextDeps[i], prevDeps[i])) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderWithHooks</span>(<span class="hljs-params">current, workInProgress, Component, props, secondArg, nextRenderExpirationTime</span>) </span>{
      renderExpirationTime = nextRenderExpirationTime;
      currentlyRenderingFiber$<span class="hljs-number">1</span> = workInProgress;
      {
        hookTypesDev = current !== <span class="hljs-literal">null</span> ? current._debugHookTypes : <span class="hljs-literal">null</span>;
        hookTypesUpdateIndexDev = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Used for hot reloading:</span>

        ignorePreviousDependencies = current !== <span class="hljs-literal">null</span> &amp;&amp; current.type !== workInProgress.type;
      }
      workInProgress.memoizedState = <span class="hljs-literal">null</span>;
      workInProgress.updateQueue = <span class="hljs-literal">null</span>;
      workInProgress.expirationTime = NoWork; <span class="hljs-comment">// The following should have already been reset</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-859" id="section-859"></a>
</div>
<p>currentHook = null;
workInProgressHook = null;
didScheduleRenderPhaseUpdate = false;
TODO Warn if no hooks are used at all during mount, then some are used during update.
Currently we will identify the update render as a mount because memoizedState === null.
This is tricky because it's valid for certain types of components (e.g. React.lazy)
Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
Non-stateful hooks (e.g. context) don't get added to memoizedState,
so memoizedState would be null during updates and mounts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      {
        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; current.memoizedState !== <span class="hljs-literal">null</span>) {
          ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hookTypesDev !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-860" id="section-860"></a>
</div>
<p>This dispatcher handles an edge case where a component is updating,
but no stateful hooks have been used.
We want to match the production code behavior (which will use HooksDispatcherOnMount),
but with the extra DEV validation to ensure hooks ordering hasn't changed.
This dispatcher does that.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;
        } <span class="hljs-keyword">else</span> {
          ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
        }
      }
      <span class="hljs-keyword">var</span> children = Component(props, secondArg); <span class="hljs-comment">// Check if there was a render phase update</span>

      <span class="hljs-keyword">if</span> (workInProgress.expirationTime === renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-861" id="section-861"></a>
</div>
<p>Keep rendering in a loop for as long as render phase updates continue to
be scheduled. Use a counter to prevent infinite loops.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> numberOfReRenders = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">do</span> {
          workInProgress.expirationTime = NoWork;

          <span class="hljs-keyword">if</span> (!(numberOfReRenders &lt; RE_RENDER_LIMIT)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Too many re-renders. React limits the number of renders to prevent an infinite loop."</span>);
            }
          }

          numberOfReRenders += <span class="hljs-number">1</span>;
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-862" id="section-862"></a>
</div>
<p>Even when hot reloading, allow dependencies to stabilize
after first render to prevent infinite render phase updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            ignorePreviousDependencies = <span class="hljs-literal">false</span>;
          } <span class="hljs-comment">// Start over from the beginning of the list</span>

          currentHook = <span class="hljs-literal">null</span>;
          workInProgressHook = <span class="hljs-literal">null</span>;
          workInProgress.updateQueue = <span class="hljs-literal">null</span>;
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-863" id="section-863"></a>
</div>
<p>Also validate hook order for cascading updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            hookTypesUpdateIndexDev = <span class="hljs-number">-1</span>;
          }
          ReactCurrentDispatcher.current = HooksDispatcherOnRerenderInDEV;
          children = Component(props, secondArg);
        } <span class="hljs-keyword">while</span> (workInProgress.expirationTime === renderExpirationTime);
      } <span class="hljs-comment">// We can assume the previous dispatcher is always this one, since we set it</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-864" id="section-864"></a>
</div>
<p>at the beginning of the render phase and there's no re-entrancy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      ReactCurrentDispatcher.current = ContextOnlyDispatcher;
      {
        workInProgress._debugHookTypes = hookTypesDev;
      } <span class="hljs-comment">// This check uses currentHook so that it works the same in DEV and prod bundles.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-865" id="section-865"></a>
</div>
<p>hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> didRenderTooFewHooks = currentHook !== <span class="hljs-literal">null</span> &amp;&amp; currentHook.next !== <span class="hljs-literal">null</span>;
      renderExpirationTime = NoWork;
      currentlyRenderingFiber$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
      currentHook = <span class="hljs-literal">null</span>;
      workInProgressHook = <span class="hljs-literal">null</span>;
      {
        currentHookNameInDev = <span class="hljs-literal">null</span>;
        hookTypesDev = <span class="hljs-literal">null</span>;
        hookTypesUpdateIndexDev = <span class="hljs-number">-1</span>;
      }
      didScheduleRenderPhaseUpdate = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (!!didRenderTooFewHooks) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Rendered fewer hooks than expected. This may be caused by an accidental early return statement."</span>);
        }
      }

      <span class="hljs-keyword">return</span> children;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bailoutHooks</span>(<span class="hljs-params">current, workInProgress, expirationTime</span>) </span>{
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.effectTag &amp;= ~(Passive | Update);

      <span class="hljs-keyword">if</span> (current.expirationTime &lt;= expirationTime) {
        current.expirationTime = NoWork;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetHooksAfterThrow</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-866" id="section-866"></a>
</div>
<p>We can assume the previous dispatcher is always this one, since we set it
at the beginning of the render phase and there's no re-entrancy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      ReactCurrentDispatcher.current = ContextOnlyDispatcher;

      <span class="hljs-keyword">if</span> (didScheduleRenderPhaseUpdate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-867" id="section-867"></a>
</div>
<p>There were render phase updates. These are only valid for this render
phase, which we are now aborting. Remove the updates from the queues so
they do not persist to the next render. Do not remove updates from hooks
that weren't processed.</p>
<p>Only reset the updates from the queue if it has a clone. If it does
not have a clone, that means it wasn't processed, and the updates were
scheduled before we entered the render phase.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> hook = currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState;

        <span class="hljs-keyword">while</span> (hook !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> queue = hook.queue;

          <span class="hljs-keyword">if</span> (queue !== <span class="hljs-literal">null</span>) {
            queue.pending = <span class="hljs-literal">null</span>;
          }

          hook = hook.next;
        }
      }

      renderExpirationTime = NoWork;
      currentlyRenderingFiber$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
      currentHook = <span class="hljs-literal">null</span>;
      workInProgressHook = <span class="hljs-literal">null</span>;
      {
        hookTypesDev = <span class="hljs-literal">null</span>;
        hookTypesUpdateIndexDev = <span class="hljs-number">-1</span>;
        currentHookNameInDev = <span class="hljs-literal">null</span>;
      }
      didScheduleRenderPhaseUpdate = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountWorkInProgressHook</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> hook = {
        <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">baseState</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">queue</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      };

      <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-868" id="section-868"></a>
</div>
<p>This is the first hook in the list</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState = workInProgressHook = hook;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-869" id="section-869"></a>
</div>
<p>Append to the end of the list</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgressHook = workInProgressHook.next = hook;
      }

      <span class="hljs-keyword">return</span> workInProgressHook;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateWorkInProgressHook</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-870" id="section-870"></a>
</div>
<p>This function is used both for updates and for re-renders triggered by a
render phase update. It assumes there is either a current hook we can
clone, or a work-in-progress hook from a previous render pass that we can
use as a base. When we reach the end of the base list, we must switch to
the dispatcher used for mounts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> nextCurrentHook;

      <span class="hljs-keyword">if</span> (currentHook === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> current = currentlyRenderingFiber$<span class="hljs-number">1.</span>alternate;

        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
          nextCurrentHook = current.memoizedState;
        } <span class="hljs-keyword">else</span> {
          nextCurrentHook = <span class="hljs-literal">null</span>;
        }
      } <span class="hljs-keyword">else</span> {
        nextCurrentHook = currentHook.next;
      }

      <span class="hljs-keyword">var</span> nextWorkInProgressHook;

      <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) {
        nextWorkInProgressHook = currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState;
      } <span class="hljs-keyword">else</span> {
        nextWorkInProgressHook = workInProgressHook.next;
      }

      <span class="hljs-keyword">if</span> (nextWorkInProgressHook !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-871" id="section-871"></a>
</div>
<p>There's already a work-in-progress. Reuse it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgressHook = nextWorkInProgressHook;
        nextWorkInProgressHook = workInProgressHook.next;
        currentHook = nextCurrentHook;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-872" id="section-872"></a>
</div>
<p>Clone from the current hook.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!(nextCurrentHook !== <span class="hljs-literal">null</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Rendered more hooks than during the previous render."</span>);
          }
        }

        currentHook = nextCurrentHook;
        <span class="hljs-keyword">var</span> newHook = {
          <span class="hljs-attr">memoizedState</span>: currentHook.memoizedState,
          <span class="hljs-attr">baseState</span>: currentHook.baseState,
          <span class="hljs-attr">baseQueue</span>: currentHook.baseQueue,
          <span class="hljs-attr">queue</span>: currentHook.queue,
          <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
        };

        <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-873" id="section-873"></a>
</div>
<p>This is the first hook in the list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState = workInProgressHook = newHook;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-874" id="section-874"></a>
</div>
<p>Append to the end of the list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          workInProgressHook = workInProgressHook.next = newHook;
        }
      }

      <span class="hljs-keyword">return</span> workInProgressHook;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFunctionComponentUpdateQueue</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">lastEffect</span>: <span class="hljs-literal">null</span>
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">basicStateReducer</span>(<span class="hljs-params">state, action</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-875" id="section-875"></a>
</div>
<p>$FlowFixMe: Flow doesn't like mixed types</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> action === <span class="hljs-string">'function'</span> ? action(state) : action;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) </span>{
      <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();
      <span class="hljs-keyword">var</span> initialState;

      <span class="hljs-keyword">if</span> (init !== <span class="hljs-literal">undefined</span>) {
        initialState = init(initialArg);
      } <span class="hljs-keyword">else</span> {
        initialState = initialArg;
      }

      hook.memoizedState = hook.baseState = initialState;
      <span class="hljs-keyword">var</span> queue = hook.queue = {
        <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">lastRenderedReducer</span>: reducer,
        <span class="hljs-attr">lastRenderedState</span>: initialState
      };
      <span class="hljs-keyword">var</span> dispatch = queue.dispatch = dispatchAction.bind(<span class="hljs-literal">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, queue);
      <span class="hljs-keyword">return</span> [hook.memoizedState, dispatch];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) </span>{
      <span class="hljs-keyword">var</span> hook = updateWorkInProgressHook();
      <span class="hljs-keyword">var</span> queue = hook.queue;

      <span class="hljs-keyword">if</span> (!(queue !== <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should have a queue. This is likely a bug in React. Please file an issue."</span>);
        }
      }

      queue.lastRenderedReducer = reducer;
      <span class="hljs-keyword">var</span> current = currentHook; <span class="hljs-comment">// The last rebase update that is NOT part of the base state.</span>

      <span class="hljs-keyword">var</span> baseQueue = current.baseQueue; <span class="hljs-comment">// The last pending update that hasn't been processed yet.</span>

      <span class="hljs-keyword">var</span> pendingQueue = queue.pending;

      <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-876" id="section-876"></a>
</div>
<p>We have new updates that haven't been processed yet.
We'll add them to the base queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-877" id="section-877"></a>
</div>
<p>Merge the pending queue and the base queue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> baseFirst = baseQueue.next;
          <span class="hljs-keyword">var</span> pendingFirst = pendingQueue.next;
          baseQueue.next = pendingFirst;
          pendingQueue.next = baseFirst;
        }

        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-878" id="section-878"></a>
</div>
<p>We have a queue to process.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> first = baseQueue.next;
        <span class="hljs-keyword">var</span> newState = current.baseState;
        <span class="hljs-keyword">var</span> newBaseState = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> newBaseQueueFirst = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> newBaseQueueLast = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> update = first;

        <span class="hljs-keyword">do</span> {
          <span class="hljs-keyword">var</span> updateExpirationTime = update.expirationTime;

          <span class="hljs-keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-879" id="section-879"></a>
</div>
<p>Priority is insufficient. Skip this update. If this is the first
skipped update, the previous update/state is the new base
update/state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> clone = {
              <span class="hljs-attr">expirationTime</span>: update.expirationTime,
              <span class="hljs-attr">suspenseConfig</span>: update.suspenseConfig,
              <span class="hljs-attr">action</span>: update.action,
              <span class="hljs-attr">eagerReducer</span>: update.eagerReducer,
              <span class="hljs-attr">eagerState</span>: update.eagerState,
              <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
            };

            <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) {
              newBaseQueueFirst = newBaseQueueLast = clone;
              newBaseState = newState;
            } <span class="hljs-keyword">else</span> {
              newBaseQueueLast = newBaseQueueLast.next = clone;
            } <span class="hljs-comment">// Update the remaining priority in the queue.</span>


            <span class="hljs-keyword">if</span> (updateExpirationTime &gt; currentlyRenderingFiber$<span class="hljs-number">1.</span>expirationTime) {
              currentlyRenderingFiber$<span class="hljs-number">1.</span>expirationTime = updateExpirationTime;
              markUnprocessedUpdateTime(updateExpirationTime);
            }
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-880" id="section-880"></a>
</div>
<p>This update does have sufficient priority.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (newBaseQueueLast !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> _clone = {
                <span class="hljs-attr">expirationTime</span>: Sync,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-881" id="section-881"></a>
</div>
<p>This update is going to be committed so we never want uncommit it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                suspenseConfig: update.suspenseConfig,
                <span class="hljs-attr">action</span>: update.action,
                <span class="hljs-attr">eagerReducer</span>: update.eagerReducer,
                <span class="hljs-attr">eagerState</span>: update.eagerState,
                <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
              };
              newBaseQueueLast = newBaseQueueLast.next = _clone;
            } <span class="hljs-comment">// Mark the event time of this update as relevant to this render pass.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-882" id="section-882"></a>
</div>
<p>TODO: This should ideally use the true event time of this update rather than
its priority which is a derived and not reverseable value.
TODO: We should skip this update if it was already committed but currently
we have no way of detecting the difference between a committed and suspended
update here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); <span class="hljs-comment">// Process this update.</span>

            <span class="hljs-keyword">if</span> (update.eagerReducer === reducer) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-883" id="section-883"></a>
</div>
<p>If this update was processed eagerly, and its reducer matches the
current reducer, we can use the eagerly computed state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              newState = update.eagerState;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> action = update.action;
              newState = reducer(newState, action);
            }
          }

          update = update.next;
        } <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span> &amp;&amp; update !== first);

        <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) {
          newBaseState = newState;
        } <span class="hljs-keyword">else</span> {
          newBaseQueueLast.next = newBaseQueueFirst;
        } <span class="hljs-comment">// Mark that the fiber performed work, but only if the new state is</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-884" id="section-884"></a>
</div>
<p>different from the current state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (!objectIs(newState, hook.memoizedState)) {
          markWorkInProgressReceivedUpdate();
        }

        hook.memoizedState = newState;
        hook.baseState = newBaseState;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = newState;
      }

      <span class="hljs-keyword">var</span> dispatch = queue.dispatch;
      <span class="hljs-keyword">return</span> [hook.memoizedState, dispatch];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rerenderReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) </span>{
      <span class="hljs-keyword">var</span> hook = updateWorkInProgressHook();
      <span class="hljs-keyword">var</span> queue = hook.queue;

      <span class="hljs-keyword">if</span> (!(queue !== <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should have a queue. This is likely a bug in React. Please file an issue."</span>);
        }
      }

      queue.lastRenderedReducer = reducer; <span class="hljs-comment">// This is a re-render. Apply the new render phase updates to the previous</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-885" id="section-885"></a>
</div>
<p>work-in-progress hook.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> dispatch = queue.dispatch;
      <span class="hljs-keyword">var</span> lastRenderPhaseUpdate = queue.pending;
      <span class="hljs-keyword">var</span> newState = hook.memoizedState;

      <span class="hljs-keyword">if</span> (lastRenderPhaseUpdate !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-886" id="section-886"></a>
</div>
<p>The queue doesn't persist past this render pass.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        queue.pending = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        <span class="hljs-keyword">var</span> update = firstRenderPhaseUpdate;

        <span class="hljs-keyword">do</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-887" id="section-887"></a>
</div>
<p>Process this render phase update. We don't have to check the
priority because it will always be the same as the current
render's.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> action = update.action;
          newState = reducer(newState, action);
          update = update.next;
        } <span class="hljs-keyword">while</span> (update !== firstRenderPhaseUpdate); <span class="hljs-comment">// Mark that the fiber performed work, but only if the new state is</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-888" id="section-888"></a>
</div>
<p>different from the current state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (!objectIs(newState, hook.memoizedState)) {
          markWorkInProgressReceivedUpdate();
        }

        hook.memoizedState = newState; <span class="hljs-comment">// Don't persist the state accumulated from the render phase updates to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-889" id="section-889"></a>
</div>
<p>the base state unless the queue is empty.
TODO: Not sure if this is the desired semantics, but it's what we
do for gDSFP. I can't remember why.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (hook.baseQueue === <span class="hljs-literal">null</span>) {
          hook.baseState = newState;
        }

        queue.lastRenderedState = newState;
      }

      <span class="hljs-keyword">return</span> [newState, dispatch];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountState</span>(<span class="hljs-params">initialState</span>) </span>{
      <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-890" id="section-890"></a>
</div>
<p>$FlowFixMe: Flow doesn't like mixed types</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        initialState = initialState();
      }

      hook.memoizedState = hook.baseState = initialState;
      <span class="hljs-keyword">var</span> queue = hook.queue = {
        <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">lastRenderedReducer</span>: basicStateReducer,
        <span class="hljs-attr">lastRenderedState</span>: initialState
      };
      <span class="hljs-keyword">var</span> dispatch = queue.dispatch = dispatchAction.bind(<span class="hljs-literal">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, queue);
      <span class="hljs-keyword">return</span> [hook.memoizedState, dispatch];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateState</span>(<span class="hljs-params">initialState</span>) </span>{
      <span class="hljs-keyword">return</span> updateReducer(basicStateReducer);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rerenderState</span>(<span class="hljs-params">initialState</span>) </span>{
      <span class="hljs-keyword">return</span> rerenderReducer(basicStateReducer);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushEffect</span>(<span class="hljs-params">tag, create, destroy, deps</span>) </span>{
      <span class="hljs-keyword">var</span> effect = {
        <span class="hljs-attr">tag</span>: tag,
        <span class="hljs-attr">create</span>: create,
        <span class="hljs-attr">destroy</span>: destroy,
        <span class="hljs-attr">deps</span>: deps,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-891" id="section-891"></a>
</div>
<p>Circular</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        next: <span class="hljs-literal">null</span>
      };
      <span class="hljs-keyword">var</span> componentUpdateQueue = currentlyRenderingFiber$<span class="hljs-number">1.</span>updateQueue;

      <span class="hljs-keyword">if</span> (componentUpdateQueue === <span class="hljs-literal">null</span>) {
        componentUpdateQueue = createFunctionComponentUpdateQueue();
        currentlyRenderingFiber$<span class="hljs-number">1.</span>updateQueue = componentUpdateQueue;
        componentUpdateQueue.lastEffect = effect.next = effect;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> lastEffect = componentUpdateQueue.lastEffect;

        <span class="hljs-keyword">if</span> (lastEffect === <span class="hljs-literal">null</span>) {
          componentUpdateQueue.lastEffect = effect.next = effect;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> firstEffect = lastEffect.next;
          lastEffect.next = effect;
          effect.next = firstEffect;
          componentUpdateQueue.lastEffect = effect;
        }
      }

      <span class="hljs-keyword">return</span> effect;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountRef</span>(<span class="hljs-params">initialValue</span>) </span>{
      <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();
      <span class="hljs-keyword">var</span> ref = {
        <span class="hljs-attr">current</span>: initialValue
      };
      {
        <span class="hljs-built_in">Object</span>.seal(ref);
      }
      hook.memoizedState = ref;
      <span class="hljs-keyword">return</span> ref;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateRef</span>(<span class="hljs-params">initialValue</span>) </span>{
      <span class="hljs-keyword">var</span> hook = updateWorkInProgressHook();
      <span class="hljs-keyword">return</span> hook.memoizedState;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountEffectImpl</span>(<span class="hljs-params">fiberEffectTag, hookEffectTag, create, deps</span>) </span>{
      <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();
      <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
      currentlyRenderingFiber$<span class="hljs-number">1.</span>effectTag |= fiberEffectTag;
      hook.memoizedState = pushEffect(HasEffect | hookEffectTag, create, <span class="hljs-literal">undefined</span>, nextDeps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateEffectImpl</span>(<span class="hljs-params">fiberEffectTag, hookEffectTag, create, deps</span>) </span>{
      <span class="hljs-keyword">var</span> hook = updateWorkInProgressHook();
      <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
      <span class="hljs-keyword">var</span> destroy = <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">if</span> (currentHook !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevEffect = currentHook.memoizedState;
        destroy = prevEffect.destroy;

        <span class="hljs-keyword">if</span> (nextDeps !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> prevDeps = prevEffect.deps;

          <span class="hljs-keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) {
            pushEffect(hookEffectTag, create, destroy, nextDeps);
            <span class="hljs-keyword">return</span>;
          }
        }
      }

      currentlyRenderingFiber$<span class="hljs-number">1.</span>effectTag |= fiberEffectTag;
      hook.memoizedState = pushEffect(HasEffect | hookEffectTag, create, destroy, nextDeps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountEffect</span>(<span class="hljs-params">create, deps</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-892" id="section-892"></a>
</div>
<p>$FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-string">'undefined'</span> !== <span class="hljs-keyword">typeof</span> jest) {
          warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$<span class="hljs-number">1</span>);
        }
      }
      <span class="hljs-keyword">return</span> mountEffectImpl(Update | Passive, Passive$<span class="hljs-number">1</span>, create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateEffect</span>(<span class="hljs-params">create, deps</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-893" id="section-893"></a>
</div>
<p>$FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-string">'undefined'</span> !== <span class="hljs-keyword">typeof</span> jest) {
          warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$<span class="hljs-number">1</span>);
        }
      }
      <span class="hljs-keyword">return</span> updateEffectImpl(Update | Passive, Passive$<span class="hljs-number">1</span>, create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountLayoutEffect</span>(<span class="hljs-params">create, deps</span>) </span>{
      <span class="hljs-keyword">return</span> mountEffectImpl(Update, Layout, create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateLayoutEffect</span>(<span class="hljs-params">create, deps</span>) </span>{
      <span class="hljs-keyword">return</span> updateEffectImpl(Update, Layout, create, deps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imperativeHandleEffect</span>(<span class="hljs-params">create, ref</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">var</span> refCallback = ref;

        <span class="hljs-keyword">var</span> _inst = create();

        refCallback(_inst);
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          refCallback(<span class="hljs-literal">null</span>);
        };
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span> &amp;&amp; ref !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> refObject = ref;
        {
          <span class="hljs-keyword">if</span> (!refObject.hasOwnProperty(<span class="hljs-string">'current'</span>)) {
            error(<span class="hljs-string">'Expected useImperativeHandle() first argument to either be a '</span> + <span class="hljs-string">'ref callback or React.createRef() object. Instead received: %s.'</span>, <span class="hljs-string">'an object with keys {'</span> + <span class="hljs-built_in">Object</span>.keys(refObject).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'}'</span>);
          }
        }

        <span class="hljs-keyword">var</span> _inst2 = create();

        refObject.current = _inst2;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          refObject.current = <span class="hljs-literal">null</span>;
        };
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountImperativeHandle</span>(<span class="hljs-params">ref, create, deps</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> create !== <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'Expected useImperativeHandle() second argument to be a function '</span> + <span class="hljs-string">'that creates a handle. Instead received: %s.'</span>, create !== <span class="hljs-literal">null</span> ? <span class="hljs-keyword">typeof</span> create : <span class="hljs-string">'null'</span>);
        }
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If deps are provided, should we skip comparing the ref itself?</span>

      <span class="hljs-keyword">var</span> effectDeps = deps !== <span class="hljs-literal">null</span> &amp;&amp; deps !== <span class="hljs-literal">undefined</span> ? deps.concat([ref]) : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(<span class="hljs-literal">null</span>, create, ref), effectDeps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateImperativeHandle</span>(<span class="hljs-params">ref, create, deps</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> create !== <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'Expected useImperativeHandle() second argument to be a function '</span> + <span class="hljs-string">'that creates a handle. Instead received: %s.'</span>, create !== <span class="hljs-literal">null</span> ? <span class="hljs-keyword">typeof</span> create : <span class="hljs-string">'null'</span>);
        }
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If deps are provided, should we skip comparing the ref itself?</span>

      <span class="hljs-keyword">var</span> effectDeps = deps !== <span class="hljs-literal">null</span> &amp;&amp; deps !== <span class="hljs-literal">undefined</span> ? deps.concat([ref]) : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(<span class="hljs-literal">null</span>, create, ref), effectDeps);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountDebugValue</span>(<span class="hljs-params">value, formatterFn</span>) </span>{<span class="hljs-comment">// This hook is normally a no-op.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-894" id="section-894"></a>
</div>
<p>The react-debug-hooks package injects its own implementation
so that e.g. DevTools can display custom hook values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    }

    <span class="hljs-keyword">var</span> updateDebugValue = mountDebugValue;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountCallback</span>(<span class="hljs-params">callback, deps</span>) </span>{
      <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();
      <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
      hook.memoizedState = [callback, nextDeps];
      <span class="hljs-keyword">return</span> callback;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCallback</span>(<span class="hljs-params">callback, deps</span>) </span>{
      <span class="hljs-keyword">var</span> hook = updateWorkInProgressHook();
      <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
      <span class="hljs-keyword">var</span> prevState = hook.memoizedState;

      <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (nextDeps !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> prevDeps = prevState[<span class="hljs-number">1</span>];

          <span class="hljs-keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) {
            <span class="hljs-keyword">return</span> prevState[<span class="hljs-number">0</span>];
          }
        }
      }

      hook.memoizedState = [callback, nextDeps];
      <span class="hljs-keyword">return</span> callback;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountMemo</span>(<span class="hljs-params">nextCreate, deps</span>) </span>{
      <span class="hljs-keyword">var</span> hook = mountWorkInProgressHook();
      <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
      <span class="hljs-keyword">var</span> nextValue = nextCreate();
      hook.memoizedState = [nextValue, nextDeps];
      <span class="hljs-keyword">return</span> nextValue;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateMemo</span>(<span class="hljs-params">nextCreate, deps</span>) </span>{
      <span class="hljs-keyword">var</span> hook = updateWorkInProgressHook();
      <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
      <span class="hljs-keyword">var</span> prevState = hook.memoizedState;

      <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-895" id="section-895"></a>
</div>
<p>Assume these are defined. If they're not, areHookInputsEqual will warn.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (nextDeps !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> prevDeps = prevState[<span class="hljs-number">1</span>];

          <span class="hljs-keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) {
            <span class="hljs-keyword">return</span> prevState[<span class="hljs-number">0</span>];
          }
        }
      }

      <span class="hljs-keyword">var</span> nextValue = nextCreate();
      hook.memoizedState = [nextValue, nextDeps];
      <span class="hljs-keyword">return</span> nextValue;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountDeferredValue</span>(<span class="hljs-params">value, config</span>) </span>{
      <span class="hljs-keyword">var</span> _mountState = mountState(value),
          prevValue = _mountState[<span class="hljs-number">0</span>],
          setValue = _mountState[<span class="hljs-number">1</span>];

      mountEffect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> previousConfig = ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense;
        ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = config === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config;

        <span class="hljs-keyword">try</span> {
          setValue(value);
        } <span class="hljs-keyword">finally</span> {
          ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = previousConfig;
        }
      }, [value, config]);
      <span class="hljs-keyword">return</span> prevValue;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDeferredValue</span>(<span class="hljs-params">value, config</span>) </span>{
      <span class="hljs-keyword">var</span> _updateState = updateState(),
          prevValue = _updateState[<span class="hljs-number">0</span>],
          setValue = _updateState[<span class="hljs-number">1</span>];

      updateEffect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> previousConfig = ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense;
        ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = config === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config;

        <span class="hljs-keyword">try</span> {
          setValue(value);
        } <span class="hljs-keyword">finally</span> {
          ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = previousConfig;
        }
      }, [value, config]);
      <span class="hljs-keyword">return</span> prevValue;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rerenderDeferredValue</span>(<span class="hljs-params">value, config</span>) </span>{
      <span class="hljs-keyword">var</span> _rerenderState = rerenderState(),
          prevValue = _rerenderState[<span class="hljs-number">0</span>],
          setValue = _rerenderState[<span class="hljs-number">1</span>];

      updateEffect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> previousConfig = ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense;
        ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = config === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config;

        <span class="hljs-keyword">try</span> {
          setValue(value);
        } <span class="hljs-keyword">finally</span> {
          ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = previousConfig;
        }
      }, [value, config]);
      <span class="hljs-keyword">return</span> prevValue;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startTransition</span>(<span class="hljs-params">setPending, config, callback</span>) </span>{
      <span class="hljs-keyword">var</span> priorityLevel = getCurrentPriorityLevel();
      runWithPriority$<span class="hljs-number">1</span>(priorityLevel &lt; UserBlockingPriority$<span class="hljs-number">1</span> ? UserBlockingPriority$<span class="hljs-number">1</span> : priorityLevel, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        setPending(<span class="hljs-literal">true</span>);
      });
      runWithPriority$<span class="hljs-number">1</span>(priorityLevel &gt; NormalPriority ? NormalPriority : priorityLevel, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> previousConfig = ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense;
        ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = config === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config;

        <span class="hljs-keyword">try</span> {
          setPending(<span class="hljs-literal">false</span>);
          callback();
        } <span class="hljs-keyword">finally</span> {
          ReactCurrentBatchConfig$<span class="hljs-number">1.</span>suspense = previousConfig;
        }
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountTransition</span>(<span class="hljs-params">config</span>) </span>{
      <span class="hljs-keyword">var</span> _mountState2 = mountState(<span class="hljs-literal">false</span>),
          isPending = _mountState2[<span class="hljs-number">0</span>],
          setPending = _mountState2[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">var</span> start = mountCallback(startTransition.bind(<span class="hljs-literal">null</span>, setPending, config), [setPending, config]);
      <span class="hljs-keyword">return</span> [start, isPending];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTransition</span>(<span class="hljs-params">config</span>) </span>{
      <span class="hljs-keyword">var</span> _updateState2 = updateState(),
          isPending = _updateState2[<span class="hljs-number">0</span>],
          setPending = _updateState2[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">var</span> start = updateCallback(startTransition.bind(<span class="hljs-literal">null</span>, setPending, config), [setPending, config]);
      <span class="hljs-keyword">return</span> [start, isPending];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rerenderTransition</span>(<span class="hljs-params">config</span>) </span>{
      <span class="hljs-keyword">var</span> _rerenderState2 = rerenderState(),
          isPending = _rerenderState2[<span class="hljs-number">0</span>],
          setPending = _rerenderState2[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">var</span> start = updateCallback(startTransition.bind(<span class="hljs-literal">null</span>, setPending, config), [setPending, config]);
      <span class="hljs-keyword">return</span> [start, isPending];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchAction</span>(<span class="hljs-params">fiber, queue, action</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">"State updates from the useState() and useReducer() Hooks don't support the "</span> + <span class="hljs-string">'second callback argument. To execute a side effect after '</span> + <span class="hljs-string">'rendering, declare it in the component body with useEffect().'</span>);
        }
      }
      <span class="hljs-keyword">var</span> currentTime = requestCurrentTimeForUpdate();
      <span class="hljs-keyword">var</span> suspenseConfig = requestCurrentSuspenseConfig();
      <span class="hljs-keyword">var</span> expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
      <span class="hljs-keyword">var</span> update = {
        <span class="hljs-attr">expirationTime</span>: expirationTime,
        <span class="hljs-attr">suspenseConfig</span>: suspenseConfig,
        <span class="hljs-attr">action</span>: action,
        <span class="hljs-attr">eagerReducer</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">eagerState</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      };
      {
        update.priority = getCurrentPriorityLevel();
      } <span class="hljs-comment">// Append the update to the end of the list.</span>

      <span class="hljs-keyword">var</span> pending = queue.pending;

      <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-896" id="section-896"></a>
</div>
<p>This is the first update. Create a circular list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        update.next = update;
      } <span class="hljs-keyword">else</span> {
        update.next = pending.next;
        pending.next = update;
      }

      queue.pending = update;
      <span class="hljs-keyword">var</span> alternate = fiber.alternate;

      <span class="hljs-keyword">if</span> (fiber === currentlyRenderingFiber$<span class="hljs-number">1</span> || alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber$<span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-897" id="section-897"></a>
</div>
<p>This is a render phase update. Stash it in a lazily-created map of
queue -&gt; linked list of updates. After this render pass, we'll restart
and apply the stashed updates on top of the work-in-progress hook.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        didScheduleRenderPhaseUpdate = <span class="hljs-literal">true</span>;
        update.expirationTime = renderExpirationTime;
        currentlyRenderingFiber$<span class="hljs-number">1.</span>expirationTime = renderExpirationTime;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (fiber.expirationTime === NoWork &amp;&amp; (alternate === <span class="hljs-literal">null</span> || alternate.expirationTime === NoWork)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-898" id="section-898"></a>
</div>
<p>The queue is currently empty, which means we can eagerly compute the
next state before entering the render phase. If the new state is the
same as the current state, we may be able to bail out entirely.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> lastRenderedReducer = queue.lastRenderedReducer;

          <span class="hljs-keyword">if</span> (lastRenderedReducer !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> prevDispatcher;
            {
              prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            }

            <span class="hljs-keyword">try</span> {
              <span class="hljs-keyword">var</span> currentState = queue.lastRenderedState;
              <span class="hljs-keyword">var</span> eagerState = lastRenderedReducer(currentState, action); <span class="hljs-comment">// Stash the eagerly computed state, and the reducer used to compute</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-899" id="section-899"></a>
</div>
<p>it, on the update object. If the reducer hasn't changed by the
time we enter the render phase, then the eager state can be used
without calling the reducer again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              update.eagerReducer = lastRenderedReducer;
              update.eagerState = eagerState;

              <span class="hljs-keyword">if</span> (objectIs(eagerState, currentState)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-900" id="section-900"></a>
</div>
<p>Fast path. We can bail out without scheduling React to re-render.
It's still possible that we'll need to rebase this update later,
if the component re-renders for a different reason and by that
time the reducer has changed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">return</span>;
              }
            } <span class="hljs-keyword">catch</span> (error) {<span class="hljs-comment">// Suppress the error. It will throw again in the render phase.</span>
            } <span class="hljs-keyword">finally</span> {
              {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            }
          }
        }

        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-901" id="section-901"></a>
</div>
<p>$FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-string">'undefined'</span> !== <span class="hljs-keyword">typeof</span> jest) {
            warnIfNotScopedWithMatchingAct(fiber);
            warnIfNotCurrentlyActingUpdatesInDev(fiber);
          }
        }
        scheduleWork(fiber, expirationTime);
      }
    }

    <span class="hljs-keyword">var</span> ContextOnlyDispatcher = {
      <span class="hljs-attr">readContext</span>: readContext,
      <span class="hljs-attr">useCallback</span>: throwInvalidHookError,
      <span class="hljs-attr">useContext</span>: throwInvalidHookError,
      <span class="hljs-attr">useEffect</span>: throwInvalidHookError,
      <span class="hljs-attr">useImperativeHandle</span>: throwInvalidHookError,
      <span class="hljs-attr">useLayoutEffect</span>: throwInvalidHookError,
      <span class="hljs-attr">useMemo</span>: throwInvalidHookError,
      <span class="hljs-attr">useReducer</span>: throwInvalidHookError,
      <span class="hljs-attr">useRef</span>: throwInvalidHookError,
      <span class="hljs-attr">useState</span>: throwInvalidHookError,
      <span class="hljs-attr">useDebugValue</span>: throwInvalidHookError,
      <span class="hljs-attr">useResponder</span>: throwInvalidHookError,
      <span class="hljs-attr">useDeferredValue</span>: throwInvalidHookError,
      <span class="hljs-attr">useTransition</span>: throwInvalidHookError
    };
    <span class="hljs-keyword">var</span> HooksDispatcherOnMountInDEV = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> HooksDispatcherOnMountWithHookTypesInDEV = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> HooksDispatcherOnUpdateInDEV = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> HooksDispatcherOnRerenderInDEV = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> InvalidNestedHooksDispatcherOnMountInDEV = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> InvalidNestedHooksDispatcherOnUpdateInDEV = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> InvalidNestedHooksDispatcherOnRerenderInDEV = <span class="hljs-literal">null</span>;
    {
      <span class="hljs-keyword">var</span> warnInvalidContextAccess = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        error(<span class="hljs-string">'Context can only be read while React is rendering. '</span> + <span class="hljs-string">'In classes, you can read it in the render method or getDerivedStateFromProps. '</span> + <span class="hljs-string">'In function components, you can read it directly in the function body, but not '</span> + <span class="hljs-string">'inside Hooks like useReducer() or useMemo().'</span>);
      };

      <span class="hljs-keyword">var</span> warnInvalidHookAccess = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        error(<span class="hljs-string">'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '</span> + <span class="hljs-string">'You can only call Hooks at the top level of your React function. '</span> + <span class="hljs-string">'For more information, see '</span> + <span class="hljs-string">'https://fb.me/rules-of-hooks'</span>);
      };

      HooksDispatcherOnMountInDEV = {
        <span class="hljs-attr">readContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useCallback'</span>;
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          <span class="hljs-keyword">return</span> mountCallback(callback, deps);
        },
        <span class="hljs-attr">useContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useContext'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useEffect'</span>;
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          <span class="hljs-keyword">return</span> mountEffect(create, deps);
        },
        <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useImperativeHandle'</span>;
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          <span class="hljs-keyword">return</span> mountImperativeHandle(ref, create, deps);
        },
        <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useLayoutEffect'</span>;
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          <span class="hljs-keyword">return</span> mountLayoutEffect(create, deps);
        },
        <span class="hljs-attr">useMemo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useMemo'</span>;
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountMemo(create, deps);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useReducer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useReducer'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountReducer(reducer, initialArg, init);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useRef</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useRef'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountRef(initialValue);
        },
        <span class="hljs-attr">useState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useState'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountState(initialState);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useDebugValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDebugValue'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountDebugValue();
        },
        <span class="hljs-attr">useResponder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responder, props</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useResponder'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> createDeprecatedResponderListener(responder, props);
        },
        <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDeferredValue'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountDeferredValue(value, config);
        },
        <span class="hljs-attr">useTransition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useTransition'</span>;
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountTransition(config);
        }
      };
      HooksDispatcherOnMountWithHookTypesInDEV = {
        <span class="hljs-attr">readContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useCallback'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountCallback(callback, deps);
        },
        <span class="hljs-attr">useContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useContext'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useEffect'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountEffect(create, deps);
        },
        <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useImperativeHandle'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountImperativeHandle(ref, create, deps);
        },
        <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useLayoutEffect'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountLayoutEffect(create, deps);
        },
        <span class="hljs-attr">useMemo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useMemo'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountMemo(create, deps);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useReducer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useReducer'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountReducer(reducer, initialArg, init);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useRef</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useRef'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountRef(initialValue);
        },
        <span class="hljs-attr">useState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useState'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountState(initialState);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useDebugValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDebugValue'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountDebugValue();
        },
        <span class="hljs-attr">useResponder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responder, props</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useResponder'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> createDeprecatedResponderListener(responder, props);
        },
        <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDeferredValue'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountDeferredValue(value, config);
        },
        <span class="hljs-attr">useTransition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useTransition'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> mountTransition(config);
        }
      };
      HooksDispatcherOnUpdateInDEV = {
        <span class="hljs-attr">readContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useCallback'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateCallback(callback, deps);
        },
        <span class="hljs-attr">useContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useContext'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useEffect'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateEffect(create, deps);
        },
        <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useImperativeHandle'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateImperativeHandle(ref, create, deps);
        },
        <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useLayoutEffect'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateLayoutEffect(create, deps);
        },
        <span class="hljs-attr">useMemo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useMemo'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateMemo(create, deps);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useReducer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useReducer'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateReducer(reducer, initialArg, init);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useRef</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useRef'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateRef();
        },
        <span class="hljs-attr">useState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useState'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateState(initialState);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useDebugValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDebugValue'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateDebugValue();
        },
        <span class="hljs-attr">useResponder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responder, props</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useResponder'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> createDeprecatedResponderListener(responder, props);
        },
        <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDeferredValue'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateDeferredValue(value, config);
        },
        <span class="hljs-attr">useTransition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useTransition'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateTransition(config);
        }
      };
      HooksDispatcherOnRerenderInDEV = {
        <span class="hljs-attr">readContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useCallback'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateCallback(callback, deps);
        },
        <span class="hljs-attr">useContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useContext'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useEffect'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateEffect(create, deps);
        },
        <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useImperativeHandle'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateImperativeHandle(ref, create, deps);
        },
        <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useLayoutEffect'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateLayoutEffect(create, deps);
        },
        <span class="hljs-attr">useMemo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useMemo'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateMemo(create, deps);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useReducer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useReducer'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> rerenderReducer(reducer, initialArg, init);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useRef</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useRef'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateRef();
        },
        <span class="hljs-attr">useState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useState'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> rerenderState(initialState);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useDebugValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDebugValue'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateDebugValue();
        },
        <span class="hljs-attr">useResponder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responder, props</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useResponder'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> createDeprecatedResponderListener(responder, props);
        },
        <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDeferredValue'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> rerenderDeferredValue(value, config);
        },
        <span class="hljs-attr">useTransition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useTransition'</span>;
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> rerenderTransition(config);
        }
      };
      InvalidNestedHooksDispatcherOnMountInDEV = {
        <span class="hljs-attr">readContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          warnInvalidContextAccess();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useCallback'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountCallback(callback, deps);
        },
        <span class="hljs-attr">useContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useContext'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useEffect'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountEffect(create, deps);
        },
        <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useImperativeHandle'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountImperativeHandle(ref, create, deps);
        },
        <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useLayoutEffect'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountLayoutEffect(create, deps);
        },
        <span class="hljs-attr">useMemo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useMemo'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountMemo(create, deps);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useReducer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useReducer'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountReducer(reducer, initialArg, init);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useRef</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useRef'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountRef(initialValue);
        },
        <span class="hljs-attr">useState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useState'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> mountState(initialState);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useDebugValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDebugValue'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountDebugValue();
        },
        <span class="hljs-attr">useResponder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responder, props</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useResponder'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> createDeprecatedResponderListener(responder, props);
        },
        <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDeferredValue'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountDeferredValue(value, config);
        },
        <span class="hljs-attr">useTransition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useTransition'</span>;
          warnInvalidHookAccess();
          mountHookTypesDev();
          <span class="hljs-keyword">return</span> mountTransition(config);
        }
      };
      InvalidNestedHooksDispatcherOnUpdateInDEV = {
        <span class="hljs-attr">readContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          warnInvalidContextAccess();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useCallback'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateCallback(callback, deps);
        },
        <span class="hljs-attr">useContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useContext'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useEffect'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateEffect(create, deps);
        },
        <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useImperativeHandle'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateImperativeHandle(ref, create, deps);
        },
        <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useLayoutEffect'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateLayoutEffect(create, deps);
        },
        <span class="hljs-attr">useMemo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useMemo'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateMemo(create, deps);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useReducer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useReducer'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateReducer(reducer, initialArg, init);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useRef</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useRef'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateRef();
        },
        <span class="hljs-attr">useState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useState'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateState(initialState);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useDebugValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDebugValue'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateDebugValue();
        },
        <span class="hljs-attr">useResponder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responder, props</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useResponder'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> createDeprecatedResponderListener(responder, props);
        },
        <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDeferredValue'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateDeferredValue(value, config);
        },
        <span class="hljs-attr">useTransition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useTransition'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateTransition(config);
        }
      };
      InvalidNestedHooksDispatcherOnRerenderInDEV = {
        <span class="hljs-attr">readContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          warnInvalidContextAccess();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useCallback'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateCallback(callback, deps);
        },
        <span class="hljs-attr">useContext</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useContext'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> readContext(context, observedBits);
        },
        <span class="hljs-attr">useEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useEffect'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateEffect(create, deps);
        },
        <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useImperativeHandle'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateImperativeHandle(ref, create, deps);
        },
        <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useLayoutEffect'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateLayoutEffect(create, deps);
        },
        <span class="hljs-attr">useMemo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useMemo'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> updateMemo(create, deps);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useReducer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useReducer'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> rerenderReducer(reducer, initialArg, init);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useRef</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useRef'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateRef();
        },
        <span class="hljs-attr">useState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useState'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> rerenderState(initialState);
          } <span class="hljs-keyword">finally</span> {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        },
        <span class="hljs-attr">useDebugValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDebugValue'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> updateDebugValue();
        },
        <span class="hljs-attr">useResponder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responder, props</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useResponder'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> createDeprecatedResponderListener(responder, props);
        },
        <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useDeferredValue'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> rerenderDeferredValue(value, config);
        },
        <span class="hljs-attr">useTransition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
          currentHookNameInDev = <span class="hljs-string">'useTransition'</span>;
          warnInvalidHookAccess();
          updateHookTypesDev();
          <span class="hljs-keyword">return</span> rerenderTransition(config);
        }
      };
    }
    <span class="hljs-keyword">var</span> now$<span class="hljs-number">1</span> = Scheduler.unstable_now;
    <span class="hljs-keyword">var</span> commitTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> profilerStartTime = <span class="hljs-number">-1</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCommitTime</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> commitTime;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recordCommitTime</span>(<span class="hljs-params"></span>) </span>{
      commitTime = now$<span class="hljs-number">1</span>();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startProfilerTimer</span>(<span class="hljs-params">fiber</span>) </span>{
      profilerStartTime = now$<span class="hljs-number">1</span>();

      <span class="hljs-keyword">if</span> (fiber.actualStartTime &lt; <span class="hljs-number">0</span>) {
        fiber.actualStartTime = now$<span class="hljs-number">1</span>();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopProfilerTimerIfRunning</span>(<span class="hljs-params">fiber</span>) </span>{
      profilerStartTime = <span class="hljs-number">-1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopProfilerTimerIfRunningAndRecordDelta</span>(<span class="hljs-params">fiber, overrideBaseTime</span>) </span>{
      <span class="hljs-keyword">if</span> (profilerStartTime &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> elapsedTime = now$<span class="hljs-number">1</span>() - profilerStartTime;
        fiber.actualDuration += elapsedTime;

        <span class="hljs-keyword">if</span> (overrideBaseTime) {
          fiber.selfBaseDuration = elapsedTime;
        }

        profilerStartTime = <span class="hljs-number">-1</span>;
      }
    } <span class="hljs-comment">// This may have been an insertion or a hydration.</span>


    <span class="hljs-keyword">var</span> hydrationParentFiber = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> nextHydratableInstance = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> isHydrating = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enterHydrationState</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> parentInstance = fiber.stateNode.containerInfo;
      nextHydratableInstance = getFirstHydratableChild(parentInstance);
      hydrationParentFiber = fiber;
      isHydrating = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteHydratableInstance</span>(<span class="hljs-params">returnFiber, instance</span>) </span>{
      {
        <span class="hljs-keyword">switch</span> (returnFiber.tag) {
          <span class="hljs-keyword">case</span> HostRoot:
            didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> HostComponent:
            didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
            <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">var</span> childToDelete = createFiberFromHostInstanceForDeletion();
      childToDelete.stateNode = instance;
      childToDelete.return = returnFiber;
      childToDelete.effectTag = Deletion; <span class="hljs-comment">// This might seem like it belongs on progressedFirstDeletion. However,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-902" id="section-902"></a>
</div>
<p>these children are not part of the reconciliation list of children.
Even if we abort and rereconcile the children, that will try to hydrate
again and the nodes are still in the host tree so these will be
recreated.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (returnFiber.lastEffect !== <span class="hljs-literal">null</span>) {
        returnFiber.lastEffect.nextEffect = childToDelete;
        returnFiber.lastEffect = childToDelete;
      } <span class="hljs-keyword">else</span> {
        returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertNonHydratedInstance</span>(<span class="hljs-params">returnFiber, fiber</span>) </span>{
      fiber.effectTag = fiber.effectTag &amp; ~Hydrating | Placement;
      {
        <span class="hljs-keyword">switch</span> (returnFiber.tag) {
          <span class="hljs-keyword">case</span> HostRoot:
            {
              <span class="hljs-keyword">var</span> parentContainer = returnFiber.stateNode.containerInfo;

              <span class="hljs-keyword">switch</span> (fiber.tag) {
                <span class="hljs-keyword">case</span> HostComponent:
                  <span class="hljs-keyword">var</span> type = fiber.type;
                  <span class="hljs-keyword">var</span> props = fiber.pendingProps;
                  didNotFindHydratableContainerInstance(parentContainer, type);
                  <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> HostText:
                  <span class="hljs-keyword">var</span> text = fiber.pendingProps;
                  didNotFindHydratableContainerTextInstance(parentContainer, text);
                  <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> HostComponent:
            {
              <span class="hljs-keyword">var</span> parentType = returnFiber.type;
              <span class="hljs-keyword">var</span> parentProps = returnFiber.memoizedProps;
              <span class="hljs-keyword">var</span> parentInstance = returnFiber.stateNode;

              <span class="hljs-keyword">switch</span> (fiber.tag) {
                <span class="hljs-keyword">case</span> HostComponent:
                  <span class="hljs-keyword">var</span> _type = fiber.type;
                  <span class="hljs-keyword">var</span> _props = fiber.pendingProps;
                  didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                  <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> HostText:
                  <span class="hljs-keyword">var</span> _text = fiber.pendingProps;
                  didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                  <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> SuspenseComponent:
                  didNotFindHydratableSuspenseInstance(parentType, parentProps);
                  <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-attr">default</span>:
            <span class="hljs-keyword">return</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryHydrate</span>(<span class="hljs-params">fiber, nextInstance</span>) </span>{
      <span class="hljs-keyword">switch</span> (fiber.tag) {
        <span class="hljs-keyword">case</span> HostComponent:
          {
            <span class="hljs-keyword">var</span> type = fiber.type;
            <span class="hljs-keyword">var</span> props = fiber.pendingProps;
            <span class="hljs-keyword">var</span> instance = canHydrateInstance(nextInstance, type);

            <span class="hljs-keyword">if</span> (instance !== <span class="hljs-literal">null</span>) {
              fiber.stateNode = instance;
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

        <span class="hljs-keyword">case</span> HostText:
          {
            <span class="hljs-keyword">var</span> text = fiber.pendingProps;
            <span class="hljs-keyword">var</span> textInstance = canHydrateTextInstance(nextInstance, text);

            <span class="hljs-keyword">if</span> (textInstance !== <span class="hljs-literal">null</span>) {
              fiber.stateNode = textInstance;
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseComponent:
          {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryToClaimNextHydratableInstance</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (!isHydrating) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> nextInstance = nextHydratableInstance;

      <span class="hljs-keyword">if</span> (!nextInstance) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-903" id="section-903"></a>
</div>
<p>Nothing to hydrate. Make it an insertion.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = <span class="hljs-literal">false</span>;
        hydrationParentFiber = fiber;
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> firstAttemptedInstance = nextInstance;

      <span class="hljs-keyword">if</span> (!tryHydrate(fiber, nextInstance)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-904" id="section-904"></a>
</div>
<p>If we can't hydrate this instance let's try the next one.
We use this as a heuristic. It's based on intuition and not data so it
might be flawed or unnecessary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        nextInstance = getNextHydratableSibling(firstAttemptedInstance);

        <span class="hljs-keyword">if</span> (!nextInstance || !tryHydrate(fiber, nextInstance)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-905" id="section-905"></a>
</div>
<p>Nothing to hydrate. Make it an insertion.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = <span class="hljs-literal">false</span>;
          hydrationParentFiber = fiber;
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// We matched the next one, we'll now assume that the first one was</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-906" id="section-906"></a>
</div>
<p>superfluous and we'll delete it. Since we can't eagerly delete it
we'll have to schedule a deletion. To do that, this node needs a dummy
fiber associated with it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
      }

      hydrationParentFiber = fiber;
      nextHydratableInstance = getFirstHydratableChild(nextInstance);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareToHydrateHostInstance</span>(<span class="hljs-params">fiber, rootContainerInstance, hostContext</span>) </span>{
      <span class="hljs-keyword">var</span> instance = fiber.stateNode;
      <span class="hljs-keyword">var</span> updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Type this specific to this type of component.</span>

      fiber.updateQueue = updatePayload; <span class="hljs-comment">// If the update payload indicates that there is a change or if there</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-907" id="section-907"></a>
</div>
<p>is a new ref we mark this as an update.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (updatePayload !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareToHydrateHostTextInstance</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> textInstance = fiber.stateNode;
      <span class="hljs-keyword">var</span> textContent = fiber.memoizedProps;
      <span class="hljs-keyword">var</span> shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
      {
        <span class="hljs-keyword">if</span> (shouldUpdate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-908" id="section-908"></a>
</div>
<p>We assume that prepareToHydrateHostTextInstance is called in a context where the
hydration parent is the parent host component of this host text.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> returnFiber = hydrationParentFiber;

          <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">switch</span> (returnFiber.tag) {
              <span class="hljs-keyword">case</span> HostRoot:
                {
                  <span class="hljs-keyword">var</span> parentContainer = returnFiber.stateNode.containerInfo;
                  didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                  <span class="hljs-keyword">break</span>;
                }

              <span class="hljs-keyword">case</span> HostComponent:
                {
                  <span class="hljs-keyword">var</span> parentType = returnFiber.type;
                  <span class="hljs-keyword">var</span> parentProps = returnFiber.memoizedProps;
                  <span class="hljs-keyword">var</span> parentInstance = returnFiber.stateNode;
                  didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                  <span class="hljs-keyword">break</span>;
                }
            }
          }
        }
      }
      <span class="hljs-keyword">return</span> shouldUpdate;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipPastDehydratedSuspenseInstance</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> suspenseState = fiber.memoizedState;
      <span class="hljs-keyword">var</span> suspenseInstance = suspenseState !== <span class="hljs-literal">null</span> ? suspenseState.dehydrated : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (!suspenseInstance) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }

      <span class="hljs-keyword">return</span> getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popToNextHostParent</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> parent = fiber.return;

      <span class="hljs-keyword">while</span> (parent !== <span class="hljs-literal">null</span> &amp;&amp; parent.tag !== HostComponent &amp;&amp; parent.tag !== HostRoot &amp;&amp; parent.tag !== SuspenseComponent) {
        parent = parent.return;
      }

      hydrationParentFiber = parent;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popHydrationState</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (fiber !== hydrationParentFiber) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-909" id="section-909"></a>
</div>
<p>We're deeper than the current hydration context, inside an inserted
tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">if</span> (!isHydrating) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-910" id="section-910"></a>
</div>
<p>If we're not currently hydrating but we're in a hydration context, then
we were an insertion and now need to pop up reenter hydration of our
siblings.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        popToNextHostParent(fiber);
        isHydrating = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> type = fiber.type; <span class="hljs-comment">// If we have any remaining hydratable nodes, we need to delete them now.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-911" id="section-911"></a>
</div>
<p>We only do this deeper than head and body since they tend to have random
other nodes in them. We also ignore components with pure text content in
side of them.
TODO: Better heuristic.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (fiber.tag !== HostComponent || type !== <span class="hljs-string">'head'</span> &amp;&amp; type !== <span class="hljs-string">'body'</span> &amp;&amp; !shouldSetTextContent(type, fiber.memoizedProps)) {
        <span class="hljs-keyword">var</span> nextInstance = nextHydratableInstance;

        <span class="hljs-keyword">while</span> (nextInstance) {
          deleteHydratableInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }

      popToNextHostParent(fiber);

      <span class="hljs-keyword">if</span> (fiber.tag === SuspenseComponent) {
        nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
      } <span class="hljs-keyword">else</span> {
        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetHydrationState</span>(<span class="hljs-params"></span>) </span>{
      hydrationParentFiber = <span class="hljs-literal">null</span>;
      nextHydratableInstance = <span class="hljs-literal">null</span>;
      isHydrating = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> ReactCurrentOwner$<span class="hljs-number">1</span> = ReactSharedInternals.ReactCurrentOwner;
    <span class="hljs-keyword">var</span> didReceiveUpdate = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didWarnAboutBadClass;
    <span class="hljs-keyword">var</span> didWarnAboutModulePatternComponent;
    <span class="hljs-keyword">var</span> didWarnAboutContextTypeOnFunctionComponent;
    <span class="hljs-keyword">var</span> didWarnAboutGetDerivedStateOnFunctionComponent;
    <span class="hljs-keyword">var</span> didWarnAboutFunctionRefs;
    <span class="hljs-keyword">var</span> didWarnAboutReassigningProps;
    <span class="hljs-keyword">var</span> didWarnAboutRevealOrder;
    <span class="hljs-keyword">var</span> didWarnAboutTailOptions;
    {
      didWarnAboutBadClass = {};
      didWarnAboutModulePatternComponent = {};
      didWarnAboutContextTypeOnFunctionComponent = {};
      didWarnAboutGetDerivedStateOnFunctionComponent = {};
      didWarnAboutFunctionRefs = {};
      didWarnAboutReassigningProps = <span class="hljs-literal">false</span>;
      didWarnAboutRevealOrder = {};
      didWarnAboutTailOptions = {};
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildren</span>(<span class="hljs-params">current, workInProgress, nextChildren, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-912" id="section-912"></a>
</div>
<p>If this is a fresh new component that hasn't been rendered yet, we
won't update its child set by applying minimal side-effects. Instead,
we will add them all to the child before it gets rendered. That means
we can optimize this reconciliation pass by not tracking side-effects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.child = mountChildFibers(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderExpirationTime);
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-913" id="section-913"></a>
</div>
<p>If the current child is the same as the work in progress, it means that
we haven't yet started any work on these children. Therefore, we use
the clone algorithm to create a copy of all the current children.
If we had any progressed work already, that is invalid at this point so
let's throw it out.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forceUnmountCurrentAndReconcile</span>(<span class="hljs-params">current, workInProgress, nextChildren, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-914" id="section-914"></a>
</div>
<p>This function is fork of reconcileChildren. It's used in cases where we
want to reconcile without matching against the existing set. This has the
effect of all current children being unmounted; even if the type and key
are the same, the old child is unmounted and a new child is created.</p>
<p>To do this, we're going to go through the reconcile algorithm twice. In
the first pass, we schedule a deletion for all the current children by
passing null.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      workInProgress.child = reconcileChildFibers(workInProgress, current.child, <span class="hljs-literal">null</span>, renderExpirationTime); <span class="hljs-comment">// In the second pass, we mount the new children. The trick here is that we</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-915" id="section-915"></a>
</div>
<p>pass null in place of where we usually pass the current child set. This has
the effect of remounting all children regardless of whether their
identities match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      workInProgress.child = reconcileChildFibers(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderExpirationTime);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateForwardRef</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-916" id="section-916"></a>
</div>
<p>TODO: current can be non-null here even if the component
hasn't yet mounted. This happens after the first render suspends.
We'll need to figure out if this is fine or can cause issues.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      {
        <span class="hljs-keyword">if</span> (workInProgress.type !== workInProgress.elementType) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-917" id="section-917"></a>
</div>
<p>Lazy component props can't be validated in createElement
because they're only guaranteed to be resolved here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> innerPropTypes = Component.propTypes;

          <span class="hljs-keyword">if</span> (innerPropTypes) {
            checkPropTypes(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">'prop'</span>, getComponentName(Component), getCurrentFiberStackInDev);
          }
        }
      }
      <span class="hljs-keyword">var</span> render = Component.render;
      <span class="hljs-keyword">var</span> ref = workInProgress.ref; <span class="hljs-comment">// The rest is a fork of updateFunctionComponent</span>

      <span class="hljs-keyword">var</span> nextChildren;
      prepareToReadContext(workInProgress, renderExpirationTime);
      {
        ReactCurrentOwner$<span class="hljs-number">1.</span>current = workInProgress;
        setIsRendering(<span class="hljs-literal">true</span>);
        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);

        <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-918" id="section-918"></a>
</div>
<p>Only double-render components with Hooks</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (workInProgress.memoizedState !== <span class="hljs-literal">null</span>) {
            nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);
          }
        }

        setIsRendering(<span class="hljs-literal">false</span>);
      }

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) {
        bailoutHooks(current, workInProgress, renderExpirationTime);
        <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
      } <span class="hljs-comment">// React DevTools reads this flag.</span>


      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateMemoComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> type = Component.type;

        <span class="hljs-keyword">if</span> (isSimpleFunctionComponent(type) &amp;&amp; Component.compare === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-comment">// SimpleMemoComponent codepath doesn't resolve outer props either.</span>
        Component.defaultProps === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">var</span> resolvedType = type;
          {
            resolvedType = resolveFunctionForHotReloading(type);
          } <span class="hljs-comment">// If this is a plain function component without default props,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-919" id="section-919"></a>
</div>
<p>and with only the default shallow comparison, we upgrade it
to a SimpleMemoComponent to allow fast path updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          workInProgress.tag = SimpleMemoComponent;
          workInProgress.type = resolvedType;
          {
            validateFunctionComponentInDev(workInProgress, type);
          }
          <span class="hljs-keyword">return</span> updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateExpirationTime, renderExpirationTime);
        }

        {
          <span class="hljs-keyword">var</span> innerPropTypes = type.propTypes;

          <span class="hljs-keyword">if</span> (innerPropTypes) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-920" id="section-920"></a>
</div>
<p>Inner memo component props aren't currently validated in createElement.
We could move it there, but we'd still need this for lazy code path.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            checkPropTypes(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">'prop'</span>, getComponentName(type), getCurrentFiberStackInDev);
          }
        }
        <span class="hljs-keyword">var</span> child = createFiberFromTypeAndProps(Component.type, <span class="hljs-literal">null</span>, nextProps, <span class="hljs-literal">null</span>, workInProgress.mode, renderExpirationTime);
        child.ref = workInProgress.ref;
        child.return = workInProgress;
        workInProgress.child = child;
        <span class="hljs-keyword">return</span> child;
      }

      {
        <span class="hljs-keyword">var</span> _type = Component.type;
        <span class="hljs-keyword">var</span> _innerPropTypes = _type.propTypes;

        <span class="hljs-keyword">if</span> (_innerPropTypes) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-921" id="section-921"></a>
</div>
<p>Inner memo component props aren't currently validated in createElement.
We could move it there, but we'd still need this for lazy code path.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          checkPropTypes(_innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
          <span class="hljs-string">'prop'</span>, getComponentName(_type), getCurrentFiberStackInDev);
        }
      }
      <span class="hljs-keyword">var</span> currentChild = current.child; <span class="hljs-comment">// This is always exactly one child</span>

      <span class="hljs-keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-922" id="section-922"></a>
</div>
<p>This will be the props with resolved defaultProps,
unlike current.memoizedProps which will be the unresolved ones.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> prevProps = currentChild.memoizedProps; <span class="hljs-comment">// Default to shallow comparison</span>

        <span class="hljs-keyword">var</span> compare = Component.compare;
        compare = compare !== <span class="hljs-literal">null</span> ? compare : shallowEqual;

        <span class="hljs-keyword">if</span> (compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) {
          <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
        }
      } <span class="hljs-comment">// React DevTools reads this flag.</span>


      workInProgress.effectTag |= PerformedWork;
      <span class="hljs-keyword">var</span> newChild = createWorkInProgress(currentChild, nextProps);
      newChild.ref = workInProgress.ref;
      newChild.return = workInProgress;
      workInProgress.child = newChild;
      <span class="hljs-keyword">return</span> newChild;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSimpleMemoComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-923" id="section-923"></a>
</div>
<p>TODO: current can be non-null here even if the component
hasn't yet mounted. This happens when the inner render suspends.
We'll need to figure out if this is fine or can cause issues.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      {
        <span class="hljs-keyword">if</span> (workInProgress.type !== workInProgress.elementType) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-924" id="section-924"></a>
</div>
<p>Lazy component props can't be validated in createElement
because they're only guaranteed to be resolved here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> outerMemoType = workInProgress.elementType;

          <span class="hljs-keyword">if</span> (outerMemoType.$$<span class="hljs-keyword">typeof</span> === REACT_LAZY_TYPE) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-925" id="section-925"></a>
</div>
<p>We warn when you define propTypes on lazy()
so let's just skip over it to find memo() outer wrapper.
Inner props for memo are validated later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            outerMemoType = refineResolvedLazyComponent(outerMemoType);
          }

          <span class="hljs-keyword">var</span> outerPropTypes = outerMemoType &amp;&amp; outerMemoType.propTypes;

          <span class="hljs-keyword">if</span> (outerPropTypes) {
            checkPropTypes(outerPropTypes, nextProps, <span class="hljs-comment">// Resolved (SimpleMemoComponent has no defaultProps)</span>
            <span class="hljs-string">'prop'</span>, getComponentName(outerMemoType), getCurrentFiberStackInDev);
          } <span class="hljs-comment">// Inner propTypes will be validated in the function component path.</span>

        }
      }

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevProps = current.memoizedProps;

        <span class="hljs-keyword">if</span> (shallowEqual(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref &amp;&amp; <span class="hljs-comment">// Prevent bailout if the implementation changed due to hot reload.</span>
        workInProgress.type === current.type) {
          didReceiveUpdate = <span class="hljs-literal">false</span>;

          <span class="hljs-keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-926" id="section-926"></a>
</div>
<p>The pending update priority was cleared at the beginning of
beginWork. We're about to bail out, but there might be additional
updates at a lower priority. Usually, the priority level of the
remaining updates is accumlated during the evaluation of the
component (i.e. when processing the update queue). But since since
we're bailing out early <em>without</em> evaluating the component, we need
to account for it here, too. Reset to the value of the current fiber.
NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
because a MemoComponent fiber does not have hooks or an update queue;
rather, it wraps around an inner component, which may or may not
contains hooks.
TODO: Move the reset at in beginWork out of the common path so that
this is no longer necessary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            workInProgress.expirationTime = current.expirationTime;
            <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
          }
        }
      }

      <span class="hljs-keyword">return</span> updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFragment</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> nextChildren = workInProgress.pendingProps;
      reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateMode</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> nextChildren = workInProgress.pendingProps.children;
      reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateProfiler</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      {
        workInProgress.effectTag |= Update;
      }
      <span class="hljs-keyword">var</span> nextProps = workInProgress.pendingProps;
      <span class="hljs-keyword">var</span> nextChildren = nextProps.children;
      reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRef</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
      <span class="hljs-keyword">var</span> ref = workInProgress.ref;

      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> &amp;&amp; ref !== <span class="hljs-literal">null</span> || current !== <span class="hljs-literal">null</span> &amp;&amp; current.ref !== ref) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-927" id="section-927"></a>
</div>
<p>Schedule a Ref effect</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.effectTag |= Ref;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFunctionComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, renderExpirationTime</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (workInProgress.type !== workInProgress.elementType) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-928" id="section-928"></a>
</div>
<p>Lazy component props can't be validated in createElement
because they're only guaranteed to be resolved here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> innerPropTypes = Component.propTypes;

          <span class="hljs-keyword">if</span> (innerPropTypes) {
            checkPropTypes(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">'prop'</span>, getComponentName(Component), getCurrentFiberStackInDev);
          }
        }
      }
      <span class="hljs-keyword">var</span> context;
      {
        <span class="hljs-keyword">var</span> unmaskedContext = getUnmaskedContext(workInProgress, Component, <span class="hljs-literal">true</span>);
        context = getMaskedContext(workInProgress, unmaskedContext);
      }
      <span class="hljs-keyword">var</span> nextChildren;
      prepareToReadContext(workInProgress, renderExpirationTime);
      {
        ReactCurrentOwner$<span class="hljs-number">1.</span>current = workInProgress;
        setIsRendering(<span class="hljs-literal">true</span>);
        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);

        <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-929" id="section-929"></a>
</div>
<p>Only double-render components with Hooks</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (workInProgress.memoizedState !== <span class="hljs-literal">null</span>) {
            nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);
          }
        }

        setIsRendering(<span class="hljs-literal">false</span>);
      }

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) {
        bailoutHooks(current, workInProgress, renderExpirationTime);
        <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
      } <span class="hljs-comment">// React DevTools reads this flag.</span>


      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateClassComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, renderExpirationTime</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (workInProgress.type !== workInProgress.elementType) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-930" id="section-930"></a>
</div>
<p>Lazy component props can't be validated in createElement
because they're only guaranteed to be resolved here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> innerPropTypes = Component.propTypes;

          <span class="hljs-keyword">if</span> (innerPropTypes) {
            checkPropTypes(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">'prop'</span>, getComponentName(Component), getCurrentFiberStackInDev);
          }
        }
      } <span class="hljs-comment">// Push context providers early to prevent context stack mismatches.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-931" id="section-931"></a>
</div>
<p>During mounting we don't know the child context yet as the instance doesn't exist.
We will invalidate the child context in finishClassComponent() right after rendering.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> hasContext;

      <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
        hasContext = <span class="hljs-literal">true</span>;
        pushContextProvider(workInProgress);
      } <span class="hljs-keyword">else</span> {
        hasContext = <span class="hljs-literal">false</span>;
      }

      prepareToReadContext(workInProgress, renderExpirationTime);
      <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;
      <span class="hljs-keyword">var</span> shouldUpdate;

      <span class="hljs-keyword">if</span> (instance === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-932" id="section-932"></a>
</div>
<p>A class component without an instance only mounts if it suspended
inside a non-concurrent tree, in an inconsistent state. We want to
treat it like a new mount, even though an empty version of it already
committed. Disconnect the alternate pointers.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          current.alternate = <span class="hljs-literal">null</span>;
          workInProgress.alternate = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

          workInProgress.effectTag |= Placement;
        } <span class="hljs-comment">// In the initial pass we might need to construct the instance.</span>


        constructClassInstance(workInProgress, Component, nextProps);
        mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        shouldUpdate = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-933" id="section-933"></a>
</div>
<p>In a resume, we'll already have an instance we can reuse.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
      } <span class="hljs-keyword">else</span> {
        shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderExpirationTime);
      }

      <span class="hljs-keyword">var</span> nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
      {
        <span class="hljs-keyword">var</span> inst = workInProgress.stateNode;

        <span class="hljs-keyword">if</span> (inst.props !== nextProps) {
          <span class="hljs-keyword">if</span> (!didWarnAboutReassigningProps) {
            error(<span class="hljs-string">'It looks like %s is reassigning its own `this.props` while rendering. '</span> + <span class="hljs-string">'This is not supported and can lead to confusing bugs.'</span>, getComponentName(workInProgress.type) || <span class="hljs-string">'a component'</span>);
          }

          didWarnAboutReassigningProps = <span class="hljs-literal">true</span>;
        }
      }
      <span class="hljs-keyword">return</span> nextUnitOfWork;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishClassComponent</span>(<span class="hljs-params">current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-934" id="section-934"></a>
</div>
<p>Refs should update even if shouldComponentUpdate returns false</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      markRef(current, workInProgress);
      <span class="hljs-keyword">var</span> didCaptureError = (workInProgress.effectTag &amp; DidCapture) !== NoEffect;

      <span class="hljs-keyword">if</span> (!shouldUpdate &amp;&amp; !didCaptureError) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-935" id="section-935"></a>
</div>
<p>Context providers should defer to sCU for rendering</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (hasContext) {
          invalidateContextProvider(workInProgress, Component, <span class="hljs-literal">false</span>);
        }

        <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
      }

      <span class="hljs-keyword">var</span> instance = workInProgress.stateNode; <span class="hljs-comment">// Rerender</span>

      ReactCurrentOwner$<span class="hljs-number">1.</span>current = workInProgress;
      <span class="hljs-keyword">var</span> nextChildren;

      <span class="hljs-keyword">if</span> (didCaptureError &amp;&amp; <span class="hljs-keyword">typeof</span> Component.getDerivedStateFromError !== <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-936" id="section-936"></a>
</div>
<p>If we captured an error, but getDerivedStateFromError is not defined,
unmount all the children. componentDidCatch will schedule an update to
re-render a fallback. This is temporary until we migrate everyone to
the new API.
TODO: Warn in a future release.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        nextChildren = <span class="hljs-literal">null</span>;
        {
          stopProfilerTimerIfRunning();
        }
      } <span class="hljs-keyword">else</span> {
        {
          setIsRendering(<span class="hljs-literal">true</span>);
          nextChildren = instance.render();

          <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
            instance.render();
          }

          setIsRendering(<span class="hljs-literal">false</span>);
        }
      } <span class="hljs-comment">// React DevTools reads this flag.</span>


      workInProgress.effectTag |= PerformedWork;

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; didCaptureError) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-937" id="section-937"></a>
</div>
<p>If we're recovering from an error, reconcile without reusing any of
the existing children. Conceptually, the normal children and the children
that are shown on error are two different sets, so we shouldn't reuse
normal children even if their identities match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime);
      } <span class="hljs-keyword">else</span> {
        reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      } <span class="hljs-comment">// Memoize state using the values we just used to render.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-938" id="section-938"></a>
</div>
<p>TODO: Restructure so we never read values from the instance.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      workInProgress.memoizedState = instance.state; <span class="hljs-comment">// The context might have changed so we need to recalculate it.</span>

      <span class="hljs-keyword">if</span> (hasContext) {
        invalidateContextProvider(workInProgress, Component, <span class="hljs-literal">true</span>);
      }

      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushHostRootContext</span>(<span class="hljs-params">workInProgress</span>) </span>{
      <span class="hljs-keyword">var</span> root = workInProgress.stateNode;

      <span class="hljs-keyword">if</span> (root.pendingContext) {
        pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.context) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-939" id="section-939"></a>
</div>
<p>Should always be set</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        pushTopLevelContextObject(workInProgress, root.context, <span class="hljs-literal">false</span>);
      }

      pushHostContainer(workInProgress, root.containerInfo);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostRoot</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      pushHostRootContext(workInProgress);
      <span class="hljs-keyword">var</span> updateQueue = workInProgress.updateQueue;

      <span class="hljs-keyword">if</span> (!(current !== <span class="hljs-literal">null</span> &amp;&amp; updateQueue !== <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }

      <span class="hljs-keyword">var</span> nextProps = workInProgress.pendingProps;
      <span class="hljs-keyword">var</span> prevState = workInProgress.memoizedState;
      <span class="hljs-keyword">var</span> prevChildren = prevState !== <span class="hljs-literal">null</span> ? prevState.element : <span class="hljs-literal">null</span>;
      cloneUpdateQueue(current, workInProgress);
      processUpdateQueue(workInProgress, nextProps, <span class="hljs-literal">null</span>, renderExpirationTime);
      <span class="hljs-keyword">var</span> nextState = workInProgress.memoizedState; <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-940" id="section-940"></a>
</div>
<p>being called &quot;element&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> nextChildren = nextState.element;

      <span class="hljs-keyword">if</span> (nextChildren === prevChildren) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-941" id="section-941"></a>
</div>
<p>If the state is the same as before, that's a bailout because we had
no work that expires at this time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        resetHydrationState();
        <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
      }

      <span class="hljs-keyword">var</span> root = workInProgress.stateNode;

      <span class="hljs-keyword">if</span> (root.hydrate &amp;&amp; enterHydrationState(workInProgress)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-942" id="section-942"></a>
</div>
<p>If we don't have any current children this might be the first pass.
We always try to hydrate. If this isn't a hydration pass there won't
be any children to hydrate which is effectively the same thing as
not hydrating.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> child = mountChildFibers(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderExpirationTime);
        workInProgress.child = child;
        <span class="hljs-keyword">var</span> node = child;

        <span class="hljs-keyword">while</span> (node) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-943" id="section-943"></a>
</div>
<p>Mark each child as hydrating. This is a fast path to know whether this
tree is part of a hydrating tree. This is used to determine if a child
node has fully mounted yet, and for scheduling event replaying.
Conceptually this is similar to Placement in that a new subtree is
inserted into the React tree here. It just happens to not need DOM
mutations because it already exists.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          node.effectTag = node.effectTag &amp; ~Placement | Hydrating;
          node = node.sibling;
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-944" id="section-944"></a>
</div>
<p>Otherwise reset hydration state in case we aborted and resumed another
root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
        resetHydrationState();
      }

      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostComponent</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      pushHostContext(workInProgress);

      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
        tryToClaimNextHydratableInstance(workInProgress);
      }

      <span class="hljs-keyword">var</span> type = workInProgress.type;
      <span class="hljs-keyword">var</span> nextProps = workInProgress.pendingProps;
      <span class="hljs-keyword">var</span> prevProps = current !== <span class="hljs-literal">null</span> ? current.memoizedProps : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> nextChildren = nextProps.children;
      <span class="hljs-keyword">var</span> isDirectTextChild = shouldSetTextContent(type, nextProps);

      <span class="hljs-keyword">if</span> (isDirectTextChild) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-945" id="section-945"></a>
</div>
<p>We special case a direct text child of a host node. This is a common
case. We won't handle it as a reified child. We will instead handle
this in the host environment that also has access to this prop. That
avoids allocating another HostText fiber and traversing it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        nextChildren = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prevProps !== <span class="hljs-literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-946" id="section-946"></a>
</div>
<p>If we're switching from a direct text child to a normal child, or to
empty, we need to schedule the text content to be reset.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.effectTag |= ContentReset;
      }

      markRef(current, workInProgress); <span class="hljs-comment">// Check the host config to see if the children are offscreen/hidden.</span>

      <span class="hljs-keyword">if</span> (workInProgress.mode &amp; ConcurrentMode &amp;&amp; renderExpirationTime !== Never &amp;&amp; shouldDeprioritizeSubtree(type, nextProps)) {
        {
          markSpawnedWork(Never);
        } <span class="hljs-comment">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>

        workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHostText</span>(<span class="hljs-params">current, workInProgress</span>) </span>{
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
        tryToClaimNextHydratableInstance(workInProgress);
      } <span class="hljs-comment">// Nothing to do here. This is terminal. We'll do the completion step</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-947" id="section-947"></a>
</div>
<p>immediately after.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountLazyComponent</span>(<span class="hljs-params">_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (_current !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-948" id="section-948"></a>
</div>
<p>A lazy component only mounts if it suspended inside a non-
concurrent tree, in an inconsistent state. We want to treat it like
a new mount, even though an empty version of it already committed.
Disconnect the alternate pointers.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        _current.alternate = <span class="hljs-literal">null</span>;
        workInProgress.alternate = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

        workInProgress.effectTag |= Placement;
      }

      <span class="hljs-keyword">var</span> props = workInProgress.pendingProps; <span class="hljs-comment">// We can't start a User Timing measurement with correct label yet.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-949" id="section-949"></a>
</div>
<p>Cancel and resume right after we know the tag.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      cancelWorkTimer(workInProgress);
      <span class="hljs-keyword">var</span> Component = readLazyComponentType(elementType); <span class="hljs-comment">// Store the unwrapped component in the type.</span>

      workInProgress.type = Component;
      <span class="hljs-keyword">var</span> resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
      startWorkTimer(workInProgress);
      <span class="hljs-keyword">var</span> resolvedProps = resolveDefaultProps(Component, props);
      <span class="hljs-keyword">var</span> child;

      <span class="hljs-keyword">switch</span> (resolvedTag) {
        <span class="hljs-keyword">case</span> FunctionComponent:
          {
            {
              validateFunctionComponentInDev(workInProgress, Component);
              workInProgress.type = Component = resolveFunctionForHotReloading(Component);
            }
            child = updateFunctionComponent(<span class="hljs-literal">null</span>, workInProgress, Component, resolvedProps, renderExpirationTime);
            <span class="hljs-keyword">return</span> child;
          }

        <span class="hljs-keyword">case</span> ClassComponent:
          {
            {
              workInProgress.type = Component = resolveClassForHotReloading(Component);
            }
            child = updateClassComponent(<span class="hljs-literal">null</span>, workInProgress, Component, resolvedProps, renderExpirationTime);
            <span class="hljs-keyword">return</span> child;
          }

        <span class="hljs-keyword">case</span> ForwardRef:
          {
            {
              workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
            }
            child = updateForwardRef(<span class="hljs-literal">null</span>, workInProgress, Component, resolvedProps, renderExpirationTime);
            <span class="hljs-keyword">return</span> child;
          }

        <span class="hljs-keyword">case</span> MemoComponent:
          {
            {
              <span class="hljs-keyword">if</span> (workInProgress.type !== workInProgress.elementType) {
                <span class="hljs-keyword">var</span> outerPropTypes = Component.propTypes;

                <span class="hljs-keyword">if</span> (outerPropTypes) {
                  checkPropTypes(outerPropTypes, resolvedProps, <span class="hljs-comment">// Resolved for outer only</span>
                  <span class="hljs-string">'prop'</span>, getComponentName(Component), getCurrentFiberStackInDev);
                }
              }
            }
            child = updateMemoComponent(<span class="hljs-literal">null</span>, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), <span class="hljs-comment">// The inner type can have defaults too</span>
            updateExpirationTime, renderExpirationTime);
            <span class="hljs-keyword">return</span> child;
          }
      }

      <span class="hljs-keyword">var</span> hint = <span class="hljs-string">''</span>;
      {
        <span class="hljs-keyword">if</span> (Component !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> Component === <span class="hljs-string">'object'</span> &amp;&amp; Component.$$<span class="hljs-keyword">typeof</span> === REACT_LAZY_TYPE) {
          hint = <span class="hljs-string">' Did you wrap a component in React.lazy() more than once?'</span>;
        }
      } <span class="hljs-comment">// This message intentionally doesn't mention ForwardRef or MemoComponent</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-950" id="section-950"></a>
</div>
<p>because the fact that it's a separate type of work is an
implementation detail.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Element type is invalid. Received a promise that resolves to: "</span> + Component + <span class="hljs-string">". Lazy element type must resolve to a class or function."</span> + hint);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountIncompleteClassComponent</span>(<span class="hljs-params">_current, workInProgress, Component, nextProps, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (_current !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-951" id="section-951"></a>
</div>
<p>An incomplete component only mounts if it suspended inside a non-
concurrent tree, in an inconsistent state. We want to treat it like
a new mount, even though an empty version of it already committed.
Disconnect the alternate pointers.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        _current.alternate = <span class="hljs-literal">null</span>;
        workInProgress.alternate = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

        workInProgress.effectTag |= Placement;
      } <span class="hljs-comment">// Promote the fiber to a class and try rendering again.</span>


      workInProgress.tag = ClassComponent; <span class="hljs-comment">// The rest of this function is a fork of `updateClassComponent`</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-952" id="section-952"></a>
</div>
<p>Push context providers early to prevent context stack mismatches.
During mounting we don't know the child context yet as the instance doesn't exist.
We will invalidate the child context in finishClassComponent() right after rendering.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> hasContext;

      <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
        hasContext = <span class="hljs-literal">true</span>;
        pushContextProvider(workInProgress);
      } <span class="hljs-keyword">else</span> {
        hasContext = <span class="hljs-literal">false</span>;
      }

      prepareToReadContext(workInProgress, renderExpirationTime);
      constructClassInstance(workInProgress, Component, nextProps);
      mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
      <span class="hljs-keyword">return</span> finishClassComponent(<span class="hljs-literal">null</span>, workInProgress, Component, <span class="hljs-literal">true</span>, hasContext, renderExpirationTime);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountIndeterminateComponent</span>(<span class="hljs-params">_current, workInProgress, Component, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (_current !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-953" id="section-953"></a>
</div>
<p>An indeterminate component only mounts if it suspended inside a non-
concurrent tree, in an inconsistent state. We want to treat it like
a new mount, even though an empty version of it already committed.
Disconnect the alternate pointers.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        _current.alternate = <span class="hljs-literal">null</span>;
        workInProgress.alternate = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

        workInProgress.effectTag |= Placement;
      }

      <span class="hljs-keyword">var</span> props = workInProgress.pendingProps;
      <span class="hljs-keyword">var</span> context;
      {
        <span class="hljs-keyword">var</span> unmaskedContext = getUnmaskedContext(workInProgress, Component, <span class="hljs-literal">false</span>);
        context = getMaskedContext(workInProgress, unmaskedContext);
      }
      prepareToReadContext(workInProgress, renderExpirationTime);
      <span class="hljs-keyword">var</span> value;
      {
        <span class="hljs-keyword">if</span> (Component.prototype &amp;&amp; <span class="hljs-keyword">typeof</span> Component.prototype.render === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">var</span> componentName = getComponentName(Component) || <span class="hljs-string">'Unknown'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutBadClass[componentName]) {
            error(<span class="hljs-string">"The &lt;%s /&gt; component appears to have a render method, but doesn't extend React.Component. "</span> + <span class="hljs-string">'This is likely to cause errors. Change %s to extend React.Component instead.'</span>, componentName, componentName);
            didWarnAboutBadClass[componentName] = <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
          ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, <span class="hljs-literal">null</span>);
        }

        setIsRendering(<span class="hljs-literal">true</span>);
        ReactCurrentOwner$<span class="hljs-number">1.</span>current = workInProgress;
        value = renderWithHooks(<span class="hljs-literal">null</span>, workInProgress, Component, props, context, renderExpirationTime);
        setIsRendering(<span class="hljs-literal">false</span>);
      } <span class="hljs-comment">// React DevTools reads this flag.</span>

      workInProgress.effectTag |= PerformedWork;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.render === <span class="hljs-string">'function'</span> &amp;&amp; value.$$<span class="hljs-keyword">typeof</span> === <span class="hljs-literal">undefined</span>) {
        {
          <span class="hljs-keyword">var</span> _componentName = getComponentName(Component) || <span class="hljs-string">'Unknown'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutModulePatternComponent[_componentName]) {
            error(<span class="hljs-string">'The &lt;%s /&gt; component appears to be a function component that returns a class instance. '</span> + <span class="hljs-string">'Change %s to a class that extends React.Component instead. '</span> + <span class="hljs-string">"If you can't use a class try assigning the prototype on the function as a workaround. "</span> + <span class="hljs-string">"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "</span> + <span class="hljs-string">'cannot be called with `new` by React.'</span>, _componentName, _componentName, _componentName);
            didWarnAboutModulePatternComponent[_componentName] = <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-comment">// Proceed under the assumption that this is a class instance</span>

        workInProgress.tag = ClassComponent; <span class="hljs-comment">// Throw out any hooks that were used.</span>

        workInProgress.memoizedState = <span class="hljs-literal">null</span>;
        workInProgress.updateQueue = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Push context providers early to prevent context stack mismatches.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-954" id="section-954"></a>
</div>
<p>During mounting we don't know the child context yet as the instance doesn't exist.
We will invalidate the child context in finishClassComponent() right after rendering.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">var</span> hasContext = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
          hasContext = <span class="hljs-literal">true</span>;
          pushContextProvider(workInProgress);
        } <span class="hljs-keyword">else</span> {
          hasContext = <span class="hljs-literal">false</span>;
        }

        workInProgress.memoizedState = value.state !== <span class="hljs-literal">null</span> &amp;&amp; value.state !== <span class="hljs-literal">undefined</span> ? value.state : <span class="hljs-literal">null</span>;
        initializeUpdateQueue(workInProgress);
        <span class="hljs-keyword">var</span> getDerivedStateFromProps = Component.getDerivedStateFromProps;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">'function'</span>) {
          applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
        }

        adoptClassInstance(workInProgress, value);
        mountClassInstance(workInProgress, Component, props, renderExpirationTime);
        <span class="hljs-keyword">return</span> finishClassComponent(<span class="hljs-literal">null</span>, workInProgress, Component, <span class="hljs-literal">true</span>, hasContext, renderExpirationTime);
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-955" id="section-955"></a>
</div>
<p>Proceed under the assumption that this is a function component</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.tag = FunctionComponent;
        {
          <span class="hljs-keyword">if</span> (workInProgress.mode &amp; StrictMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-956" id="section-956"></a>
</div>
<p>Only double-render components with Hooks</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (workInProgress.memoizedState !== <span class="hljs-literal">null</span>) {
              value = renderWithHooks(<span class="hljs-literal">null</span>, workInProgress, Component, props, context, renderExpirationTime);
            }
          }
        }
        reconcileChildren(<span class="hljs-literal">null</span>, workInProgress, value, renderExpirationTime);
        {
          validateFunctionComponentInDev(workInProgress, Component);
        }
        <span class="hljs-keyword">return</span> workInProgress.child;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateFunctionComponentInDev</span>(<span class="hljs-params">workInProgress, Component</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (Component) {
          <span class="hljs-keyword">if</span> (Component.childContextTypes) {
            error(<span class="hljs-string">'%s(...): childContextTypes cannot be defined on a function component.'</span>, Component.displayName || Component.name || <span class="hljs-string">'Component'</span>);
          }
        }

        <span class="hljs-keyword">if</span> (workInProgress.ref !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> info = <span class="hljs-string">''</span>;
          <span class="hljs-keyword">var</span> ownerName = getCurrentFiberOwnerNameInDevOrNull();

          <span class="hljs-keyword">if</span> (ownerName) {
            info += <span class="hljs-string">'\n\nCheck the render method of `'</span> + ownerName + <span class="hljs-string">'`.'</span>;
          }

          <span class="hljs-keyword">var</span> warningKey = ownerName || workInProgress._debugID || <span class="hljs-string">''</span>;
          <span class="hljs-keyword">var</span> debugSource = workInProgress._debugSource;

          <span class="hljs-keyword">if</span> (debugSource) {
            warningKey = debugSource.fileName + <span class="hljs-string">':'</span> + debugSource.lineNumber;
          }

          <span class="hljs-keyword">if</span> (!didWarnAboutFunctionRefs[warningKey]) {
            didWarnAboutFunctionRefs[warningKey] = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'Function components cannot be given refs. '</span> + <span class="hljs-string">'Attempts to access this ref will fail. '</span> + <span class="hljs-string">'Did you mean to use React.forwardRef()?%s'</span>, info);
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Component.getDerivedStateFromProps === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">var</span> _componentName2 = getComponentName(Component) || <span class="hljs-string">'Unknown'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {
            error(<span class="hljs-string">'%s: Function components do not support getDerivedStateFromProps.'</span>, _componentName2);
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = <span class="hljs-literal">true</span>;
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Component.contextType === <span class="hljs-string">'object'</span> &amp;&amp; Component.contextType !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> _componentName3 = getComponentName(Component) || <span class="hljs-string">'Unknown'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {
            error(<span class="hljs-string">'%s: Function components do not support contextType.'</span>, _componentName3);
            didWarnAboutContextTypeOnFunctionComponent[_componentName3] = <span class="hljs-literal">true</span>;
          }
        }
      }
    }

    <span class="hljs-keyword">var</span> SUSPENDED_MARKER = {
      <span class="hljs-attr">dehydrated</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">retryTime</span>: NoWork
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldRemainOnFallback</span>(<span class="hljs-params">suspenseContext, current, workInProgress</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-957" id="section-957"></a>
</div>
<p>If the context is telling us that we should show a fallback, and we're not
already showing content, then we should show the fallback instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> hasSuspenseContext(suspenseContext, ForceSuspenseFallback) &amp;&amp; (current === <span class="hljs-literal">null</span> || current.memoizedState !== <span class="hljs-literal">null</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSuspenseComponent</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> mode = workInProgress.mode;
      <span class="hljs-keyword">var</span> nextProps = workInProgress.pendingProps; <span class="hljs-comment">// This is used by DevTools to force a boundary to suspend.</span>

      {
        <span class="hljs-keyword">if</span> (shouldSuspend(workInProgress)) {
          workInProgress.effectTag |= DidCapture;
        }
      }
      <span class="hljs-keyword">var</span> suspenseContext = suspenseStackCursor.current;
      <span class="hljs-keyword">var</span> nextDidTimeout = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> didSuspend = (workInProgress.effectTag &amp; DidCapture) !== NoEffect;

      <span class="hljs-keyword">if</span> (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-958" id="section-958"></a>
</div>
<p>Something in this boundary's subtree already suspended. Switch to
rendering the fallback children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        nextDidTimeout = <span class="hljs-literal">true</span>;
        workInProgress.effectTag &amp;= ~DidCapture;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-959" id="section-959"></a>
</div>
<p>Attempting the main content</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.memoizedState !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-960" id="section-960"></a>
</div>
<p>This is a new mount or this boundary is already showing a fallback state.
Mark this subtree context as having at least one invisible parent that could
handle the fallback state.
Boundaries without fallbacks or should be avoided are not considered since
they cannot handle preferred fallback states.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (nextProps.fallback !== <span class="hljs-literal">undefined</span> &amp;&amp; nextProps.unstable_avoidThisFallback !== <span class="hljs-literal">true</span>) {
            suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
          }
        }
      }

      suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
      pushSuspenseContext(workInProgress, suspenseContext); <span class="hljs-comment">// This next part is a bit confusing. If the children timeout, we switch to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-961" id="section-961"></a>
</div>
<p>showing the fallback children in place of the &quot;primary&quot; children.
However, we don't want to delete the primary children because then their
state will be lost (both the React state and the host state, e.g.
uncontrolled form inputs). Instead we keep them mounted and hide them.
Both the fallback children AND the primary children are rendered at the
same time. Once the primary children are un-suspended, we can delete
the fallback children — don't need to preserve their state.</p>
<p>The two sets of children are siblings in the host environment, but
semantically, for purposes of reconciliation, they are two separate sets.
So we store them using two fragment fibers.</p>
<p>However, we want to avoid allocating extra fibers for every placeholder.
They're only necessary when the children time out, because that's the
only time when both sets are mounted.</p>
<p>So, the extra fragment fibers are only used if the children time out.
Otherwise, we render the primary children directly. This requires some
custom reconciliation logic to preserve the state of the primary
children. It's essentially a very basic form of re-parenting.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-962" id="section-962"></a>
</div>
<p>If we're currently hydrating, try to hydrate this boundary.
But only if this has a fallback.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (nextProps.fallback !== <span class="hljs-literal">undefined</span>) {
          tryToClaimNextHydratableInstance(workInProgress); <span class="hljs-comment">// This could've been a dehydrated suspense component.</span>
        } <span class="hljs-comment">// This is the initial mount. This branch is pretty simple because there's</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-963" id="section-963"></a>
</div>
<p>no previous state that needs to be preserved.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (nextDidTimeout) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-964" id="section-964"></a>
</div>
<p>Mount separate fragments for primary and fallback children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> nextFallbackChildren = nextProps.fallback;
          <span class="hljs-keyword">var</span> primaryChildFragment = createFiberFromFragment(<span class="hljs-literal">null</span>, mode, NoWork, <span class="hljs-literal">null</span>);
          primaryChildFragment.return = workInProgress;

          <span class="hljs-keyword">if</span> ((workInProgress.mode &amp; BlockingMode) === NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-965" id="section-965"></a>
</div>
<p>Outside of blocking mode, we commit the effects from the
partially completed, timed-out tree, too.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> progressedState = workInProgress.memoizedState;
            <span class="hljs-keyword">var</span> progressedPrimaryChild = progressedState !== <span class="hljs-literal">null</span> ? workInProgress.child.child : workInProgress.child;
            primaryChildFragment.child = progressedPrimaryChild;
            <span class="hljs-keyword">var</span> progressedChild = progressedPrimaryChild;

            <span class="hljs-keyword">while</span> (progressedChild !== <span class="hljs-literal">null</span>) {
              progressedChild.return = primaryChildFragment;
              progressedChild = progressedChild.sibling;
            }
          }

          <span class="hljs-keyword">var</span> fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, <span class="hljs-literal">null</span>);
          fallbackChildFragment.return = workInProgress;
          primaryChildFragment.sibling = fallbackChildFragment; <span class="hljs-comment">// Skip the primary children, and continue working on the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-966" id="section-966"></a>
</div>
<p>fallback children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          workInProgress.memoizedState = SUSPENDED_MARKER;
          workInProgress.child = primaryChildFragment;
          <span class="hljs-keyword">return</span> fallbackChildFragment;
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-967" id="section-967"></a>
</div>
<p>Mount the primary children without an intermediate fragment fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> nextPrimaryChildren = nextProps.children;
          workInProgress.memoizedState = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">return</span> workInProgress.child = mountChildFibers(workInProgress, <span class="hljs-literal">null</span>, nextPrimaryChildren, renderExpirationTime);
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-968" id="section-968"></a>
</div>
<p>This is an update. This branch is more complicated because we need to
ensure the state of the primary children is preserved.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> prevState = current.memoizedState;

        <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-969" id="section-969"></a>
</div>
<p>wrapped in a fragment fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> currentPrimaryChildFragment = current.child;
          <span class="hljs-keyword">var</span> currentFallbackChildFragment = currentPrimaryChildFragment.sibling;

          <span class="hljs-keyword">if</span> (nextDidTimeout) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-970" id="section-970"></a>
</div>
<p>Still timed out. Reuse the current primary children by cloning
its fragment. We're going to skip over these entirely.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> _nextFallbackChildren2 = nextProps.fallback;

            <span class="hljs-keyword">var</span> _primaryChildFragment2 = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps);

            _primaryChildFragment2.return = workInProgress;

            <span class="hljs-keyword">if</span> ((workInProgress.mode &amp; BlockingMode) === NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-971" id="section-971"></a>
</div>
<p>Outside of blocking mode, we commit the effects from the
partially completed, timed-out tree, too.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> _progressedState = workInProgress.memoizedState;

              <span class="hljs-keyword">var</span> _progressedPrimaryChild = _progressedState !== <span class="hljs-literal">null</span> ? workInProgress.child.child : workInProgress.child;

              <span class="hljs-keyword">if</span> (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
                _primaryChildFragment2.child = _progressedPrimaryChild;
                <span class="hljs-keyword">var</span> _progressedChild2 = _progressedPrimaryChild;

                <span class="hljs-keyword">while</span> (_progressedChild2 !== <span class="hljs-literal">null</span>) {
                  _progressedChild2.return = _primaryChildFragment2;
                  _progressedChild2 = _progressedChild2.sibling;
                }
              }
            } <span class="hljs-comment">// Because primaryChildFragment is a new fiber that we're inserting as the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-972" id="section-972"></a>
</div>
<p>parent of a new tree, we need to set its treeBaseDuration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">if</span> (workInProgress.mode &amp; ProfileMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-973" id="section-973"></a>
</div>
<p>treeBaseDuration is the sum of all the child tree base durations.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> _treeBaseDuration = <span class="hljs-number">0</span>;
              <span class="hljs-keyword">var</span> _hiddenChild = _primaryChildFragment2.child;

              <span class="hljs-keyword">while</span> (_hiddenChild !== <span class="hljs-literal">null</span>) {
                _treeBaseDuration += _hiddenChild.treeBaseDuration;
                _hiddenChild = _hiddenChild.sibling;
              }

              _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
            } <span class="hljs-comment">// Clone the fallback child fragment, too. These we'll continue</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-974" id="section-974"></a>
</div>
<p>working on.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">var</span> _fallbackChildFragment2 = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren2);

            _fallbackChildFragment2.return = workInProgress;
            _primaryChildFragment2.sibling = _fallbackChildFragment2;
            _primaryChildFragment2.childExpirationTime = NoWork; <span class="hljs-comment">// Skip the primary children, and continue working on the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-975" id="section-975"></a>
</div>
<p>fallback children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            workInProgress.memoizedState = SUSPENDED_MARKER;
            workInProgress.child = _primaryChildFragment2;
            <span class="hljs-keyword">return</span> _fallbackChildFragment2;
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-976" id="section-976"></a>
</div>
<p>No longer suspended. Switch back to showing the primary children,
and remove the intermediate fragment fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> _nextPrimaryChildren = nextProps.children;
            <span class="hljs-keyword">var</span> currentPrimaryChild = currentPrimaryChildFragment.child;
            <span class="hljs-keyword">var</span> primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime); <span class="hljs-comment">// If this render doesn't suspend, we need to delete the fallback</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-977" id="section-977"></a>
</div>
<p>children. Wait until the complete phase, after we've confirmed the
fallback is no longer needed.
TODO: Would it be better to store the fallback fragment on
the stateNode?
Continue rendering the children, like we normally do.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            workInProgress.memoizedState = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span> workInProgress.child = primaryChild;
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-978" id="section-978"></a>
</div>
<p>The current tree has not already timed out. That means the primary
children are not wrapped in a fragment fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> _currentPrimaryChild = current.child;

          <span class="hljs-keyword">if</span> (nextDidTimeout) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-979" id="section-979"></a>
</div>
<p>Timed out. Wrap the children in a fragment fiber to keep them
separate from the fallback children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> _nextFallbackChildren3 = nextProps.fallback;

            <span class="hljs-keyword">var</span> _primaryChildFragment3 = createFiberFromFragment( <span class="hljs-comment">// It shouldn't matter what the pending props are because we aren't</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-980" id="section-980"></a>
</div>
<p>going to render this fragment.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-literal">null</span>, mode, NoWork, <span class="hljs-literal">null</span>);

            _primaryChildFragment3.return = workInProgress;
            _primaryChildFragment3.child = _currentPrimaryChild;

            <span class="hljs-keyword">if</span> (_currentPrimaryChild !== <span class="hljs-literal">null</span>) {
              _currentPrimaryChild.return = _primaryChildFragment3;
            } <span class="hljs-comment">// Even though we're creating a new fiber, there are no new children,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-981" id="section-981"></a>
</div>
<p>because we're reusing an already mounted tree. So we don't need to
schedule a placement.
primaryChildFragment.effectTag |= Placement;</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">if</span> ((workInProgress.mode &amp; BlockingMode) === NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-982" id="section-982"></a>
</div>
<p>Outside of blocking mode, we commit the effects from the
partially completed, timed-out tree, too.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> _progressedState2 = workInProgress.memoizedState;

              <span class="hljs-keyword">var</span> _progressedPrimaryChild2 = _progressedState2 !== <span class="hljs-literal">null</span> ? workInProgress.child.child : workInProgress.child;

              _primaryChildFragment3.child = _progressedPrimaryChild2;
              <span class="hljs-keyword">var</span> _progressedChild3 = _progressedPrimaryChild2;

              <span class="hljs-keyword">while</span> (_progressedChild3 !== <span class="hljs-literal">null</span>) {
                _progressedChild3.return = _primaryChildFragment3;
                _progressedChild3 = _progressedChild3.sibling;
              }
            } <span class="hljs-comment">// Because primaryChildFragment is a new fiber that we're inserting as the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-983" id="section-983"></a>
</div>
<p>parent of a new tree, we need to set its treeBaseDuration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">if</span> (workInProgress.mode &amp; ProfileMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-984" id="section-984"></a>
</div>
<p>treeBaseDuration is the sum of all the child tree base durations.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> _treeBaseDuration2 = <span class="hljs-number">0</span>;
              <span class="hljs-keyword">var</span> _hiddenChild2 = _primaryChildFragment3.child;

              <span class="hljs-keyword">while</span> (_hiddenChild2 !== <span class="hljs-literal">null</span>) {
                _treeBaseDuration2 += _hiddenChild2.treeBaseDuration;
                _hiddenChild2 = _hiddenChild2.sibling;
              }

              _primaryChildFragment3.treeBaseDuration = _treeBaseDuration2;
            } <span class="hljs-comment">// Create a fragment from the fallback children, too.</span>


            <span class="hljs-keyword">var</span> _fallbackChildFragment3 = createFiberFromFragment(_nextFallbackChildren3, mode, renderExpirationTime, <span class="hljs-literal">null</span>);

            _fallbackChildFragment3.return = workInProgress;
            _primaryChildFragment3.sibling = _fallbackChildFragment3;
            _fallbackChildFragment3.effectTag |= Placement;
            _primaryChildFragment3.childExpirationTime = NoWork; <span class="hljs-comment">// Skip the primary children, and continue working on the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-985" id="section-985"></a>
</div>
<p>fallback children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            workInProgress.memoizedState = SUSPENDED_MARKER;
            workInProgress.child = _primaryChildFragment3;
            <span class="hljs-keyword">return</span> _fallbackChildFragment3;
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-986" id="section-986"></a>
</div>
<p>Still haven't timed out. Continue rendering the children, like we
normally do.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            workInProgress.memoizedState = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">var</span> _nextPrimaryChildren2 = nextProps.children;
            <span class="hljs-keyword">return</span> workInProgress.child = reconcileChildFibers(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleWorkOnFiber</span>(<span class="hljs-params">fiber, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (fiber.expirationTime &lt; renderExpirationTime) {
        fiber.expirationTime = renderExpirationTime;
      }

      <span class="hljs-keyword">var</span> alternate = fiber.alternate;

      <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.expirationTime &lt; renderExpirationTime) {
        alternate.expirationTime = renderExpirationTime;
      }

      scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propagateSuspenseContextChange</span>(<span class="hljs-params">workInProgress, firstChild, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-987" id="section-987"></a>
</div>
<p>Mark any Suspense boundaries with fallbacks as having work to do.
If they were previously forced into fallbacks, they may now be able
to unblock.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> node = firstChild;

      <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.tag === SuspenseComponent) {
          <span class="hljs-keyword">var</span> state = node.memoizedState;

          <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
            scheduleWorkOnFiber(node, renderExpirationTime);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.tag === SuspenseListComponent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-988" id="section-988"></a>
</div>
<p>If the tail is hidden there might not be an Suspense boundaries
to schedule work on. In this case we have to schedule it on the
list itself.
We don't have to traverse to the children of the list since
the list will propagate the change when it rerenders.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          scheduleWorkOnFiber(node, renderExpirationTime);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
          node.child.return = node;
          node = node.child;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === workInProgress) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === workInProgress) {
            <span class="hljs-keyword">return</span>;
          }

          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLastContentRow</span>(<span class="hljs-params">firstChild</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-989" id="section-989"></a>
</div>
<p>This is going to find the last row among these children that is already
showing content on the screen, as opposed to being in fallback state or
new. If a row has multiple Suspense boundaries, any of them being in the
fallback state, counts as the whole row being in a fallback state.
Note that the &quot;rows&quot; will be workInProgress, but any nested children
will still be current since we haven't rendered them yet. The mounted
order may not be the same as the new order. We use the new order.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> row = firstChild;
      <span class="hljs-keyword">var</span> lastContentRow = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">while</span> (row !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> currentRow = row.alternate; <span class="hljs-comment">// New rows can't be content rows.</span>

        <span class="hljs-keyword">if</span> (currentRow !== <span class="hljs-literal">null</span> &amp;&amp; findFirstSuspended(currentRow) === <span class="hljs-literal">null</span>) {
          lastContentRow = row;
        }

        row = row.sibling;
      }

      <span class="hljs-keyword">return</span> lastContentRow;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateRevealOrder</span>(<span class="hljs-params">revealOrder</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (revealOrder !== <span class="hljs-literal">undefined</span> &amp;&amp; revealOrder !== <span class="hljs-string">'forwards'</span> &amp;&amp; revealOrder !== <span class="hljs-string">'backwards'</span> &amp;&amp; revealOrder !== <span class="hljs-string">'together'</span> &amp;&amp; !didWarnAboutRevealOrder[revealOrder]) {
          didWarnAboutRevealOrder[revealOrder] = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> revealOrder === <span class="hljs-string">'string'</span>) {
            <span class="hljs-keyword">switch</span> (revealOrder.toLowerCase()) {
              <span class="hljs-keyword">case</span> <span class="hljs-string">'together'</span>:
              <span class="hljs-keyword">case</span> <span class="hljs-string">'forwards'</span>:
              <span class="hljs-keyword">case</span> <span class="hljs-string">'backwards'</span>:
                {
                  error(<span class="hljs-string">'"%s" is not a valid value for revealOrder on &lt;SuspenseList /&gt;. '</span> + <span class="hljs-string">'Use lowercase "%s" instead.'</span>, revealOrder, revealOrder.toLowerCase());
                  <span class="hljs-keyword">break</span>;
                }

              <span class="hljs-keyword">case</span> <span class="hljs-string">'forward'</span>:
              <span class="hljs-keyword">case</span> <span class="hljs-string">'backward'</span>:
                {
                  error(<span class="hljs-string">'"%s" is not a valid value for revealOrder on &lt;SuspenseList /&gt;. '</span> + <span class="hljs-string">'React uses the -s suffix in the spelling. Use "%ss" instead.'</span>, revealOrder, revealOrder.toLowerCase());
                  <span class="hljs-keyword">break</span>;
                }

              <span class="hljs-attr">default</span>:
                error(<span class="hljs-string">'"%s" is not a supported revealOrder on &lt;SuspenseList /&gt;. '</span> + <span class="hljs-string">'Did you mean "together", "forwards" or "backwards"?'</span>, revealOrder);
                <span class="hljs-keyword">break</span>;
            }
          } <span class="hljs-keyword">else</span> {
            error(<span class="hljs-string">'%s is not a supported value for revealOrder on &lt;SuspenseList /&gt;. '</span> + <span class="hljs-string">'Did you mean "together", "forwards" or "backwards"?'</span>, revealOrder);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateTailOptions</span>(<span class="hljs-params">tailMode, revealOrder</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (tailMode !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnAboutTailOptions[tailMode]) {
          <span class="hljs-keyword">if</span> (tailMode !== <span class="hljs-string">'collapsed'</span> &amp;&amp; tailMode !== <span class="hljs-string">'hidden'</span>) {
            didWarnAboutTailOptions[tailMode] = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'"%s" is not a supported value for tail on &lt;SuspenseList /&gt;. '</span> + <span class="hljs-string">'Did you mean "collapsed" or "hidden"?'</span>, tailMode);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (revealOrder !== <span class="hljs-string">'forwards'</span> &amp;&amp; revealOrder !== <span class="hljs-string">'backwards'</span>) {
            didWarnAboutTailOptions[tailMode] = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'&lt;SuspenseList tail="%s" /&gt; is only valid if revealOrder is '</span> + <span class="hljs-string">'"forwards" or "backwards". '</span> + <span class="hljs-string">'Did you mean to specify revealOrder="forwards"?'</span>, tailMode);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateSuspenseListNestedChild</span>(<span class="hljs-params">childSlot, index</span>) </span>{
      {
        <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray(childSlot);
        <span class="hljs-keyword">var</span> isIterable = !isArray &amp;&amp; <span class="hljs-keyword">typeof</span> getIteratorFn(childSlot) === <span class="hljs-string">'function'</span>;

        <span class="hljs-keyword">if</span> (isArray || isIterable) {
          <span class="hljs-keyword">var</span> type = isArray ? <span class="hljs-string">'array'</span> : <span class="hljs-string">'iterable'</span>;
          error(<span class="hljs-string">'A nested %s was passed to row #%s in &lt;SuspenseList /&gt;. Wrap it in '</span> + <span class="hljs-string">'an additional SuspenseList to configure its revealOrder: '</span> + <span class="hljs-string">'&lt;SuspenseList revealOrder=...&gt; ... '</span> + <span class="hljs-string">'&lt;SuspenseList revealOrder=...&gt;{%s}&lt;/SuspenseList&gt; ... '</span> + <span class="hljs-string">'&lt;/SuspenseList&gt;'</span>, type, index, type);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateSuspenseListChildren</span>(<span class="hljs-params">children, revealOrder</span>) </span>{
      {
        <span class="hljs-keyword">if</span> ((revealOrder === <span class="hljs-string">'forwards'</span> || revealOrder === <span class="hljs-string">'backwards'</span>) &amp;&amp; children !== <span class="hljs-literal">undefined</span> &amp;&amp; children !== <span class="hljs-literal">null</span> &amp;&amp; children !== <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(children)) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
              <span class="hljs-keyword">if</span> (!validateSuspenseListNestedChild(children[i], i)) {
                <span class="hljs-keyword">return</span>;
              }
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> iteratorFn = getIteratorFn(children);

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> iteratorFn === <span class="hljs-string">'function'</span>) {
              <span class="hljs-keyword">var</span> childrenIterator = iteratorFn.call(children);

              <span class="hljs-keyword">if</span> (childrenIterator) {
                <span class="hljs-keyword">var</span> step = childrenIterator.next();
                <span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>;

                <span class="hljs-keyword">for</span> (; !step.done; step = childrenIterator.next()) {
                  <span class="hljs-keyword">if</span> (!validateSuspenseListNestedChild(step.value, _i)) {
                    <span class="hljs-keyword">return</span>;
                  }

                  _i++;
                }
              }
            } <span class="hljs-keyword">else</span> {
              error(<span class="hljs-string">'A single row was passed to a &lt;SuspenseList revealOrder="%s" /&gt;. '</span> + <span class="hljs-string">'This is not useful since it needs multiple rows. '</span> + <span class="hljs-string">'Did you mean to pass multiple children or an array?'</span>, revealOrder);
            }
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initSuspenseListRenderState</span>(<span class="hljs-params">workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering</span>) </span>{
      <span class="hljs-keyword">var</span> renderState = workInProgress.memoizedState;

      <span class="hljs-keyword">if</span> (renderState === <span class="hljs-literal">null</span>) {
        workInProgress.memoizedState = {
          <span class="hljs-attr">isBackwards</span>: isBackwards,
          <span class="hljs-attr">rendering</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">renderingStartTime</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">last</span>: lastContentRow,
          <span class="hljs-attr">tail</span>: tail,
          <span class="hljs-attr">tailExpiration</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">tailMode</span>: tailMode,
          <span class="hljs-attr">lastEffect</span>: lastEffectBeforeRendering
        };
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-990" id="section-990"></a>
</div>
<p>We can reuse the existing object from previous renders.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        renderState.isBackwards = isBackwards;
        renderState.rendering = <span class="hljs-literal">null</span>;
        renderState.renderingStartTime = <span class="hljs-number">0</span>;
        renderState.last = lastContentRow;
        renderState.tail = tail;
        renderState.tailExpiration = <span class="hljs-number">0</span>;
        renderState.tailMode = tailMode;
        renderState.lastEffect = lastEffectBeforeRendering;
      }
    } <span class="hljs-comment">// This can end up rendering this component multiple passes.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-991" id="section-991"></a>
</div>
<p>The first pass splits the children fibers into two sets. A head and tail.
We first render the head. If anything is in fallback state, we do another
pass through beginWork to rerender all children (including the tail) with
the force suspend context. If the first render didn't have anything in
in fallback state. Then we render each row in the tail one-by-one.
That happens in the completeWork phase without going back to beginWork.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSuspenseListComponent</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> nextProps = workInProgress.pendingProps;
      <span class="hljs-keyword">var</span> revealOrder = nextProps.revealOrder;
      <span class="hljs-keyword">var</span> tailMode = nextProps.tail;
      <span class="hljs-keyword">var</span> newChildren = nextProps.children;
      validateRevealOrder(revealOrder);
      validateTailOptions(tailMode, revealOrder);
      validateSuspenseListChildren(newChildren, revealOrder);
      reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
      <span class="hljs-keyword">var</span> suspenseContext = suspenseStackCursor.current;
      <span class="hljs-keyword">var</span> shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);

      <span class="hljs-keyword">if</span> (shouldForceFallback) {
        suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
        workInProgress.effectTag |= DidCapture;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> didSuspendBefore = current !== <span class="hljs-literal">null</span> &amp;&amp; (current.effectTag &amp; DidCapture) !== NoEffect;

        <span class="hljs-keyword">if</span> (didSuspendBefore) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-992" id="section-992"></a>
</div>
<p>If we previously forced a fallback, we need to schedule work
on any nested boundaries to let them know to try to render
again. This is the same as context updating.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          propagateSuspenseContextChange(workInProgress, workInProgress.child, renderExpirationTime);
        }

        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
      }

      pushSuspenseContext(workInProgress, suspenseContext);

      <span class="hljs-keyword">if</span> ((workInProgress.mode &amp; BlockingMode) === NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-993" id="section-993"></a>
</div>
<p>Outside of blocking mode, SuspenseList doesn't work so we just
use make it a noop by treating it as the default revealOrder.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.memoizedState = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">switch</span> (revealOrder) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'forwards'</span>:
            {
              <span class="hljs-keyword">var</span> lastContentRow = findLastContentRow(workInProgress.child);
              <span class="hljs-keyword">var</span> tail;

              <span class="hljs-keyword">if</span> (lastContentRow === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-994" id="section-994"></a>
</div>
<p>The whole list is part of the tail.
TODO: We could fast path by just rendering the tail now.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                tail = workInProgress.child;
                workInProgress.child = <span class="hljs-literal">null</span>;
              } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-995" id="section-995"></a>
</div>
<p>Disconnect the tail rows after the content row.
We're going to render them separately later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                tail = lastContentRow.sibling;
                lastContentRow.sibling = <span class="hljs-literal">null</span>;
              }

              initSuspenseListRenderState(workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-comment">// isBackwards</span>
              tail, lastContentRow, tailMode, workInProgress.lastEffect);
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-string">'backwards'</span>:
            {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-996" id="section-996"></a>
</div>
<p>We're going to find the first row that has existing content.
At the same time we're going to reverse the list of everything
we pass in the meantime. That's going to be our tail in reverse
order.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> _tail = <span class="hljs-literal">null</span>;
              <span class="hljs-keyword">var</span> row = workInProgress.child;
              workInProgress.child = <span class="hljs-literal">null</span>;

              <span class="hljs-keyword">while</span> (row !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">var</span> currentRow = row.alternate; <span class="hljs-comment">// New rows can't be content rows.</span>

                <span class="hljs-keyword">if</span> (currentRow !== <span class="hljs-literal">null</span> &amp;&amp; findFirstSuspended(currentRow) === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-997" id="section-997"></a>
</div>
<p>This is the beginning of the main content.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  workInProgress.child = row;
                  <span class="hljs-keyword">break</span>;
                }

                <span class="hljs-keyword">var</span> nextRow = row.sibling;
                row.sibling = _tail;
                _tail = row;
                row = nextRow;
              } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If workInProgress.child is null, we can continue on the tail immediately.</span>


              initSuspenseListRenderState(workInProgress, <span class="hljs-literal">true</span>, <span class="hljs-comment">// isBackwards</span>
              _tail, <span class="hljs-literal">null</span>, <span class="hljs-comment">// last</span>
              tailMode, workInProgress.lastEffect);
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-string">'together'</span>:
            {
              initSuspenseListRenderState(workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-comment">// isBackwards</span>
              <span class="hljs-literal">null</span>, <span class="hljs-comment">// tail</span>
              <span class="hljs-literal">null</span>, <span class="hljs-comment">// last</span>
              <span class="hljs-literal">undefined</span>, workInProgress.lastEffect);
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-attr">default</span>:
            {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-998" id="section-998"></a>
</div>
<p>The default reveal order is the same as not having
a boundary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              workInProgress.memoizedState = <span class="hljs-literal">null</span>;
            }
        }
      }

      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePortalComponent</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      <span class="hljs-keyword">var</span> nextChildren = workInProgress.pendingProps;

      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-999" id="section-999"></a>
</div>
<p>Portals are special because we don't append the children during mount
but at commit. Therefore we need to track insertions which the normal
flow doesn't do during mount. This doesn't happen at the root because
the root always starts with a &quot;current&quot; with a null child.
TODO: Consider unifying this with how the root works.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.child = reconcileChildFibers(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderExpirationTime);
      } <span class="hljs-keyword">else</span> {
        reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);
      }

      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateContextProvider</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> providerType = workInProgress.type;
      <span class="hljs-keyword">var</span> context = providerType._context;
      <span class="hljs-keyword">var</span> newProps = workInProgress.pendingProps;
      <span class="hljs-keyword">var</span> oldProps = workInProgress.memoizedProps;
      <span class="hljs-keyword">var</span> newValue = newProps.value;
      {
        <span class="hljs-keyword">var</span> providerPropTypes = workInProgress.type.propTypes;

        <span class="hljs-keyword">if</span> (providerPropTypes) {
          checkPropTypes(providerPropTypes, newProps, <span class="hljs-string">'prop'</span>, <span class="hljs-string">'Context.Provider'</span>, getCurrentFiberStackInDev);
        }
      }
      pushProvider(workInProgress, newValue);

      <span class="hljs-keyword">if</span> (oldProps !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> oldValue = oldProps.value;
        <span class="hljs-keyword">var</span> changedBits = calculateChangedBits(context, newValue, oldValue);

        <span class="hljs-keyword">if</span> (changedBits === <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1000" id="section-1000"></a>
</div>
<p>No change. Bailout early if children are the same.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (oldProps.children === newProps.children &amp;&amp; !hasContextChanged()) {
            <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1001" id="section-1001"></a>
</div>
<p>The context value changed. Search for matching consumers and schedule
them to update.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
        }
      }

      <span class="hljs-keyword">var</span> newChildren = newProps.children;
      reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-keyword">var</span> hasWarnedAboutUsingContextAsConsumer = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateContextConsumer</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> context = workInProgress.type; <span class="hljs-comment">// The logic below for Context differs depending on PROD or DEV mode. In</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1002" id="section-1002"></a>
</div>
<p>DEV mode, we create a separate object for Context.Consumer that acts
like a proxy to Context. This proxy object adds unnecessary code in PROD
so we use the old behaviour (Context.Consumer references Context) to
reduce size and overhead. The separate object references context via
a property called &quot;_context&quot;, which also gives us the ability to check
in DEV mode if this property exists or not and warn if it does not.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      {
        <span class="hljs-keyword">if</span> (context._context === <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1003" id="section-1003"></a>
</div>
<p>This may be because it's a Context (rather than a Consumer).
Or it may be because it's older React where they're the same thing.
We only want to warn if we're sure it's a new React.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (context !== context.Consumer) {
            <span class="hljs-keyword">if</span> (!hasWarnedAboutUsingContextAsConsumer) {
              hasWarnedAboutUsingContextAsConsumer = <span class="hljs-literal">true</span>;
              error(<span class="hljs-string">'Rendering &lt;Context&gt; directly is not supported and will be removed in '</span> + <span class="hljs-string">'a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?'</span>);
            }
          }
        } <span class="hljs-keyword">else</span> {
          context = context._context;
        }
      }
      <span class="hljs-keyword">var</span> newProps = workInProgress.pendingProps;
      <span class="hljs-keyword">var</span> render = newProps.children;
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> render !== <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'A context consumer was rendered with multiple children, or a child '</span> + <span class="hljs-string">"that isn't a function. A context consumer expects a single child "</span> + <span class="hljs-string">'that is a function. If you did pass a function, make sure there '</span> + <span class="hljs-string">'is no trailing or leading whitespace around it.'</span>);
        }
      }
      prepareToReadContext(workInProgress, renderExpirationTime);
      <span class="hljs-keyword">var</span> newValue = readContext(context, newProps.unstable_observedBits);
      <span class="hljs-keyword">var</span> newChildren;
      {
        ReactCurrentOwner$<span class="hljs-number">1.</span>current = workInProgress;
        setIsRendering(<span class="hljs-literal">true</span>);
        newChildren = render(newValue);
        setIsRendering(<span class="hljs-literal">false</span>);
      } <span class="hljs-comment">// React DevTools reads this flag.</span>

      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
      <span class="hljs-keyword">return</span> workInProgress.child;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markWorkInProgressReceivedUpdate</span>(<span class="hljs-params"></span>) </span>{
      didReceiveUpdate = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bailoutOnAlreadyFinishedWork</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      cancelWorkTimer(workInProgress);

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1004" id="section-1004"></a>
</div>
<p>Reuse previous dependencies</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.dependencies = current.dependencies;
      }

      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1005" id="section-1005"></a>
</div>
<p>Don't update &quot;base&quot; render times for bailouts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        stopProfilerTimerIfRunning();
      }
      <span class="hljs-keyword">var</span> updateExpirationTime = workInProgress.expirationTime;

      <span class="hljs-keyword">if</span> (updateExpirationTime !== NoWork) {
        markUnprocessedUpdateTime(updateExpirationTime);
      } <span class="hljs-comment">// Check if the children have any pending work.</span>


      <span class="hljs-keyword">var</span> childExpirationTime = workInProgress.childExpirationTime;

      <span class="hljs-keyword">if</span> (childExpirationTime &lt; renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1006" id="section-1006"></a>
</div>
<p>The children don't have any work either. We can skip them.
TODO: Once we add back resuming, we should check if the children are
a work-in-progress set. If so, we need to transfer their effects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1007" id="section-1007"></a>
</div>
<p>This fiber doesn't have work, but its subtree does. Clone the child
fibers and continue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        cloneChildFibers(current, workInProgress);
        <span class="hljs-keyword">return</span> workInProgress.child;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remountFiber</span>(<span class="hljs-params">current, oldWorkInProgress, newWorkInProgress</span>) </span>{
      {
        <span class="hljs-keyword">var</span> returnFiber = oldWorkInProgress.return;

        <span class="hljs-keyword">if</span> (returnFiber === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Cannot swap the root fiber.'</span>);
        } <span class="hljs-comment">// Disconnect from the old current.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1008" id="section-1008"></a>
</div>
<p>It will get deleted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        current.alternate = <span class="hljs-literal">null</span>;
        oldWorkInProgress.alternate = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Connect to the new tree.</span>

        newWorkInProgress.index = oldWorkInProgress.index;
        newWorkInProgress.sibling = oldWorkInProgress.sibling;
        newWorkInProgress.return = oldWorkInProgress.return;
        newWorkInProgress.ref = oldWorkInProgress.ref; <span class="hljs-comment">// Replace the child/sibling pointers above it.</span>

        <span class="hljs-keyword">if</span> (oldWorkInProgress === returnFiber.child) {
          returnFiber.child = newWorkInProgress;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> prevSibling = returnFiber.child;

          <span class="hljs-keyword">if</span> (prevSibling === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected parent to have a child.'</span>);
          }

          <span class="hljs-keyword">while</span> (prevSibling.sibling !== oldWorkInProgress) {
            prevSibling = prevSibling.sibling;

            <span class="hljs-keyword">if</span> (prevSibling === <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected to find the previous sibling.'</span>);
            }
          }

          prevSibling.sibling = newWorkInProgress;
        } <span class="hljs-comment">// Delete the old fiber and place the new one.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1009" id="section-1009"></a>
</div>
<p>Since the old fiber is disconnected, we have to schedule it manually.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">var</span> last = returnFiber.lastEffect;

        <span class="hljs-keyword">if</span> (last !== <span class="hljs-literal">null</span>) {
          last.nextEffect = current;
          returnFiber.lastEffect = current;
        } <span class="hljs-keyword">else</span> {
          returnFiber.firstEffect = returnFiber.lastEffect = current;
        }

        current.nextEffect = <span class="hljs-literal">null</span>;
        current.effectTag = Deletion;
        newWorkInProgress.effectTag |= Placement; <span class="hljs-comment">// Restart work from the new fiber.</span>

        <span class="hljs-keyword">return</span> newWorkInProgress;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beginWork</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> updateExpirationTime = workInProgress.expirationTime;
      {
        <span class="hljs-keyword">if</span> (workInProgress._debugNeedsRemount &amp;&amp; current !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1010" id="section-1010"></a>
</div>
<p>This will restart the begin phase with a new fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || <span class="hljs-literal">null</span>, workInProgress.mode, workInProgress.expirationTime));
        }
      }

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> oldProps = current.memoizedProps;
        <span class="hljs-keyword">var</span> newProps = workInProgress.pendingProps;

        <span class="hljs-keyword">if</span> (oldProps !== newProps || hasContextChanged() || <span class="hljs-comment">// Force a re-render if the implementation changed due to hot reload:</span>
        workInProgress.type !== current.type) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1011" id="section-1011"></a>
</div>
<p>If props or context changed, mark the fiber as having performed work.
This may be unset if the props are determined to be equal later (memo).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          didReceiveUpdate = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) {
          didReceiveUpdate = <span class="hljs-literal">false</span>; <span class="hljs-comment">// This fiber does not have any pending work. Bailout without entering</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1012" id="section-1012"></a>
</div>
<p>the begin phase. There's still some bookkeeping we that needs to be done
in this optimized path, mostly pushing stuff onto the stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">switch</span> (workInProgress.tag) {
            <span class="hljs-keyword">case</span> HostRoot:
              pushHostRootContext(workInProgress);
              resetHydrationState();
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> HostComponent:
              pushHostContext(workInProgress);

              <span class="hljs-keyword">if</span> (workInProgress.mode &amp; ConcurrentMode &amp;&amp; renderExpirationTime !== Never &amp;&amp; shouldDeprioritizeSubtree(workInProgress.type, newProps)) {
                {
                  markSpawnedWork(Never);
                } <span class="hljs-comment">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>

                workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }

              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> ClassComponent:
              {
                <span class="hljs-keyword">var</span> Component = workInProgress.type;

                <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
                  pushContextProvider(workInProgress);
                }

                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-keyword">case</span> HostPortal:
              pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> ContextProvider:
              {
                <span class="hljs-keyword">var</span> newValue = workInProgress.memoizedProps.value;
                pushProvider(workInProgress, newValue);
                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-keyword">case</span> Profiler:
              {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1013" id="section-1013"></a>
</div>
<p>Profiler should only call onRender when one of its descendants actually rendered.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> hasChildWork = workInProgress.childExpirationTime &gt;= renderExpirationTime;

                <span class="hljs-keyword">if</span> (hasChildWork) {
                  workInProgress.effectTag |= Update;
                }
              }
              <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> SuspenseComponent:
              {
                <span class="hljs-keyword">var</span> state = workInProgress.memoizedState;

                <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1014" id="section-1014"></a>
</div>
<p>whether to retry the primary children, or to skip over it and
go straight to the fallback. Check the priority of the primary
child fragment.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  <span class="hljs-keyword">var</span> primaryChildFragment = workInProgress.child;
                  <span class="hljs-keyword">var</span> primaryChildExpirationTime = primaryChildFragment.childExpirationTime;

                  <span class="hljs-keyword">if</span> (primaryChildExpirationTime !== NoWork &amp;&amp; primaryChildExpirationTime &gt;= renderExpirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1015" id="section-1015"></a>
</div>
<p>The primary children have pending work. Use the normal path
to attempt to render the primary children again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    <span class="hljs-keyword">return</span> updateSuspenseComponent(current, workInProgress, renderExpirationTime);
                  } <span class="hljs-keyword">else</span> {
                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); <span class="hljs-comment">// The primary children do not have pending work with sufficient</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1016" id="section-1016"></a>
</div>
<p>priority. Bailout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                    <span class="hljs-keyword">var</span> child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);

                    <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1017" id="section-1017"></a>
</div>
<p>The fallback children have pending work. Skip over the
primary children and work on the fallback.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                      <span class="hljs-keyword">return</span> child.sibling;
                    } <span class="hljs-keyword">else</span> {
                      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                    }
                  }
                } <span class="hljs-keyword">else</span> {
                  pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }

                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-keyword">case</span> SuspenseListComponent:
              {
                <span class="hljs-keyword">var</span> didSuspendBefore = (current.effectTag &amp; DidCapture) !== NoEffect;

                <span class="hljs-keyword">var</span> _hasChildWork = workInProgress.childExpirationTime &gt;= renderExpirationTime;

                <span class="hljs-keyword">if</span> (didSuspendBefore) {
                  <span class="hljs-keyword">if</span> (_hasChildWork) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1018" id="section-1018"></a>
</div>
<p>If something was in fallback state last time, and we have all the
same children then we're still in progressive loading state.
Something might get unblocked by state updates or retries in the
tree which will affect the tail. So we need to use the normal
path to compute the correct tail.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    <span class="hljs-keyword">return</span> updateSuspenseListComponent(current, workInProgress, renderExpirationTime);
                  } <span class="hljs-comment">// If none of the children had any work, that means that none of</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1019" id="section-1019"></a>
</div>
<p>them got retried so they'll still be blocked in the same way
as before. We can fast bail out.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

                  workInProgress.effectTag |= DidCapture;
                } <span class="hljs-comment">// If nothing suspended before and we're rendering the same children,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1020" id="section-1020"></a>
</div>
<p>then the tail doesn't matter. Anything new that suspends will work
in the &quot;together&quot; mode, so we can continue from the state we had.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

                <span class="hljs-keyword">var</span> renderState = workInProgress.memoizedState;

                <span class="hljs-keyword">if</span> (renderState !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1021" id="section-1021"></a>
</div>
<p>Reset to the &quot;together&quot; mode in case we've started a different
update in the past but didn't complete it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  renderState.rendering = <span class="hljs-literal">null</span>;
                  renderState.tail = <span class="hljs-literal">null</span>;
                }

                pushSuspenseContext(workInProgress, suspenseStackCursor.current);

                <span class="hljs-keyword">if</span> (_hasChildWork) {
                  <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1022" id="section-1022"></a>
</div>
<p>If none of the children had any work, that means that none of
them got retried so they'll still be blocked in the same way
as before. We can fast bail out.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                }
              }
          }

          <span class="hljs-keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1023" id="section-1023"></a>
</div>
<p>An update was scheduled on this fiber, but there are no new props
nor legacy context. Set this to false. If an update queue or context
consumer produces a changed value, it will set this to true. Otherwise,
the component will assume the children have not changed and bail out.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          didReceiveUpdate = <span class="hljs-literal">false</span>;
        }
      } <span class="hljs-keyword">else</span> {
        didReceiveUpdate = <span class="hljs-literal">false</span>;
      } <span class="hljs-comment">// Before entering the begin phase, clear pending update priority.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1024" id="section-1024"></a>
</div>
<p>TODO: This assumes that we're about to evaluate the component and process
the update queue. However, there's an exception: SimpleMemoComponent
sometimes bails out later in the begin phase. This indicates that we should
move this assignment out of the common path and into each branch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      workInProgress.expirationTime = NoWork;

      <span class="hljs-keyword">switch</span> (workInProgress.tag) {
        <span class="hljs-keyword">case</span> IndeterminateComponent:
          {
            <span class="hljs-keyword">return</span> mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> LazyComponent:
          {
            <span class="hljs-keyword">var</span> elementType = workInProgress.elementType;
            <span class="hljs-keyword">return</span> mountLazyComponent(current, workInProgress, elementType, updateExpirationTime, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> FunctionComponent:
          {
            <span class="hljs-keyword">var</span> _Component = workInProgress.type;
            <span class="hljs-keyword">var</span> unresolvedProps = workInProgress.pendingProps;
            <span class="hljs-keyword">var</span> resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
            <span class="hljs-keyword">return</span> updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> ClassComponent:
          {
            <span class="hljs-keyword">var</span> _Component2 = workInProgress.type;
            <span class="hljs-keyword">var</span> _unresolvedProps = workInProgress.pendingProps;

            <span class="hljs-keyword">var</span> _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

            <span class="hljs-keyword">return</span> updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> HostRoot:
          <span class="hljs-keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> HostComponent:
          <span class="hljs-keyword">return</span> updateHostComponent(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> HostText:
          <span class="hljs-keyword">return</span> updateHostText(current, workInProgress);

        <span class="hljs-keyword">case</span> SuspenseComponent:
          <span class="hljs-keyword">return</span> updateSuspenseComponent(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> HostPortal:
          <span class="hljs-keyword">return</span> updatePortalComponent(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> ForwardRef:
          {
            <span class="hljs-keyword">var</span> type = workInProgress.type;
            <span class="hljs-keyword">var</span> _unresolvedProps2 = workInProgress.pendingProps;

            <span class="hljs-keyword">var</span> _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

            <span class="hljs-keyword">return</span> updateForwardRef(current, workInProgress, type, _resolvedProps2, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> Fragment:
          <span class="hljs-keyword">return</span> updateFragment(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> Mode:
          <span class="hljs-keyword">return</span> updateMode(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> Profiler:
          <span class="hljs-keyword">return</span> updateProfiler(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> ContextProvider:
          <span class="hljs-keyword">return</span> updateContextProvider(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> ContextConsumer:
          <span class="hljs-keyword">return</span> updateContextConsumer(current, workInProgress, renderExpirationTime);

        <span class="hljs-keyword">case</span> MemoComponent:
          {
            <span class="hljs-keyword">var</span> _type2 = workInProgress.type;
            <span class="hljs-keyword">var</span> _unresolvedProps3 = workInProgress.pendingProps; <span class="hljs-comment">// Resolve outer props first, then resolve inner props.</span>

            <span class="hljs-keyword">var</span> _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);

            {
              <span class="hljs-keyword">if</span> (workInProgress.type !== workInProgress.elementType) {
                <span class="hljs-keyword">var</span> outerPropTypes = _type2.propTypes;

                <span class="hljs-keyword">if</span> (outerPropTypes) {
                  checkPropTypes(outerPropTypes, _resolvedProps3, <span class="hljs-comment">// Resolved for outer only</span>
                  <span class="hljs-string">'prop'</span>, getComponentName(_type2), getCurrentFiberStackInDev);
                }
              }
            }
            _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
            <span class="hljs-keyword">return</span> updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateExpirationTime, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> SimpleMemoComponent:
          {
            <span class="hljs-keyword">return</span> updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> IncompleteClassComponent:
          {
            <span class="hljs-keyword">var</span> _Component3 = workInProgress.type;
            <span class="hljs-keyword">var</span> _unresolvedProps4 = workInProgress.pendingProps;

            <span class="hljs-keyword">var</span> _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

            <span class="hljs-keyword">return</span> mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);
          }

        <span class="hljs-keyword">case</span> SuspenseListComponent:
          {
            <span class="hljs-keyword">return</span> updateSuspenseListComponent(current, workInProgress, renderExpirationTime);
          }
      }

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown unit of work tag ("</span> + workInProgress.tag + <span class="hljs-string">"). This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUpdate</span>(<span class="hljs-params">workInProgress</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1025" id="section-1025"></a>
</div>
<p>Tag the fiber with an update effect. This turns a Placement into
a PlacementAndUpdate.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      workInProgress.effectTag |= Update;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRef$1</span>(<span class="hljs-params">workInProgress</span>) </span>{
      workInProgress.effectTag |= Ref;
    }

    <span class="hljs-keyword">var</span> appendAllChildren;
    <span class="hljs-keyword">var</span> updateHostContainer;
    <span class="hljs-keyword">var</span> updateHostComponent$<span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> updateHostText$<span class="hljs-number">1</span>;
    {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1026" id="section-1026"></a>
</div>
<p>Mutation mode</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      appendAllChildren = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, workInProgress, needsVisibilityToggle, isHidden</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1027" id="section-1027"></a>
</div>
<p>We only have the top Fiber that was created but we need recurse down its
children to find all the terminal nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> node = workInProgress.child;

        <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText) {
            appendInitialChild(parent, node.stateNode);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.tag === HostPortal) ;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
            node.child.return = node;
            node = node.child;
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (node === workInProgress) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === workInProgress) {
              <span class="hljs-keyword">return</span>;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      };

      updateHostContainer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">workInProgress</span>) </span>{<span class="hljs-comment">// Noop</span>
      };

      updateHostComponent$<span class="hljs-number">1</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">current, workInProgress, type, newProps, rootContainerInstance</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1028" id="section-1028"></a>
</div>
<p>If we have an alternate, that means this is an update and we need to
schedule a side-effect to do the updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> oldProps = current.memoizedProps;

        <span class="hljs-keyword">if</span> (oldProps === newProps) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1029" id="section-1029"></a>
</div>
<p>In mutation mode, this is sufficient for a bailout because
we won't touch this node even if children changed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// If we get updated because one of our children updated, we don't</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1030" id="section-1030"></a>
</div>
<p>have newProps so we'll have to reuse them.
TODO: Split the update API as separate for the props vs. children.
Even better would be if children weren't special cased at all tho.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;
        <span class="hljs-keyword">var</span> currentHostContext = getHostContext(); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Experiencing an error where oldProps is null. Suggests a host</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1031" id="section-1031"></a>
</div>
<p>component is hitting the resume path. Figure out why. Possibly
related to <code>hidden</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">var</span> updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Type this specific to this type of component.</span>

        workInProgress.updateQueue = updatePayload; <span class="hljs-comment">// If the update payload indicates that there is a change or if there</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1032" id="section-1032"></a>
</div>
<p>is a new ref we mark this as an update. All the work is done in commitWork.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (updatePayload) {
          markUpdate(workInProgress);
        }
      };

      updateHostText$<span class="hljs-number">1</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">current, workInProgress, oldText, newText</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1033" id="section-1033"></a>
</div>
<p>If the text differs, mark it as an update. All the work in done in commitWork.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cutOffTailIfNeeded</span>(<span class="hljs-params">renderState, hasRenderedATailFallback</span>) </span>{
      <span class="hljs-keyword">switch</span> (renderState.tailMode) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'hidden'</span>:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1034" id="section-1034"></a>
</div>
<p>Any insertions at the end of the tail list after this point
should be invisible. If there are already mounted boundaries
anything before them are not considered for collapsing.
Therefore we need to go through the whole tail to find if
there are any.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> tailNode = renderState.tail;
            <span class="hljs-keyword">var</span> lastTailNode = <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">while</span> (tailNode !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (tailNode.alternate !== <span class="hljs-literal">null</span>) {
                lastTailNode = tailNode;
              }

              tailNode = tailNode.sibling;
            } <span class="hljs-comment">// Next we're simply going to delete all insertions after the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1035" id="section-1035"></a>
</div>
<p>last rendered item.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">if</span> (lastTailNode === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1036" id="section-1036"></a>
</div>
<p>All remaining items in the tail are insertions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              renderState.tail = <span class="hljs-literal">null</span>;
            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1037" id="section-1037"></a>
</div>
<p>Detach the insertion after the last node that was already
inserted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              lastTailNode.sibling = <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'collapsed'</span>:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1038" id="section-1038"></a>
</div>
<p>Any insertions at the end of the tail list after this point
should be invisible. If there are already mounted boundaries
anything before them are not considered for collapsing.
Therefore we need to go through the whole tail to find if
there are any.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> _tailNode = renderState.tail;
            <span class="hljs-keyword">var</span> _lastTailNode = <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">while</span> (_tailNode !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (_tailNode.alternate !== <span class="hljs-literal">null</span>) {
                _lastTailNode = _tailNode;
              }

              _tailNode = _tailNode.sibling;
            } <span class="hljs-comment">// Next we're simply going to delete all insertions after the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1039" id="section-1039"></a>
</div>
<p>last rendered item.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">if</span> (_lastTailNode === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1040" id="section-1040"></a>
</div>
<p>All remaining items in the tail are insertions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (!hasRenderedATailFallback &amp;&amp; renderState.tail !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1041" id="section-1041"></a>
</div>
<p>We suspended during the head. We want to show at least one
row at the tail. So we'll keep on and cut off the rest.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                renderState.tail.sibling = <span class="hljs-literal">null</span>;
              } <span class="hljs-keyword">else</span> {
                renderState.tail = <span class="hljs-literal">null</span>;
              }
            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1042" id="section-1042"></a>
</div>
<p>Detach the insertion after the last node that was already
inserted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              _lastTailNode.sibling = <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">break</span>;
          }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeWork</span>(<span class="hljs-params">current, workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> newProps = workInProgress.pendingProps;

      <span class="hljs-keyword">switch</span> (workInProgress.tag) {
        <span class="hljs-keyword">case</span> IndeterminateComponent:
        <span class="hljs-keyword">case</span> LazyComponent:
        <span class="hljs-keyword">case</span> SimpleMemoComponent:
        <span class="hljs-keyword">case</span> FunctionComponent:
        <span class="hljs-keyword">case</span> ForwardRef:
        <span class="hljs-keyword">case</span> Fragment:
        <span class="hljs-keyword">case</span> Mode:
        <span class="hljs-keyword">case</span> Profiler:
        <span class="hljs-keyword">case</span> ContextConsumer:
        <span class="hljs-keyword">case</span> MemoComponent:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">case</span> ClassComponent:
          {
            <span class="hljs-keyword">var</span> Component = workInProgress.type;

            <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
              popContext(workInProgress);
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> HostRoot:
          {
            popHostContainer(workInProgress);
            popTopLevelContextObject(workInProgress);
            <span class="hljs-keyword">var</span> fiberRoot = workInProgress.stateNode;

            <span class="hljs-keyword">if</span> (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.child === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1043" id="section-1043"></a>
</div>
<p>If we hydrated, pop so that we can delete any remaining children
that weren't hydrated.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> wasHydrated = popHydrationState(workInProgress);

              <span class="hljs-keyword">if</span> (wasHydrated) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1044" id="section-1044"></a>
</div>
<p>If we hydrated, then we'll need to schedule an update for
the commit side-effects on the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                markUpdate(workInProgress);
              }
            }

            updateHostContainer(workInProgress);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> HostComponent:
          {
            popHostContext(workInProgress);
            <span class="hljs-keyword">var</span> rootContainerInstance = getRootHostContainer();
            <span class="hljs-keyword">var</span> type = workInProgress.type;

            <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="hljs-literal">null</span>) {
              updateHostComponent$<span class="hljs-number">1</span>(current, workInProgress, type, newProps, rootContainerInstance);

              <span class="hljs-keyword">if</span> (current.ref !== workInProgress.ref) {
                markRef$<span class="hljs-number">1</span>(workInProgress);
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (!newProps) {
                <span class="hljs-keyword">if</span> (!(workInProgress.stateNode !== <span class="hljs-literal">null</span>)) {
                  {
                    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."</span>);
                  }
                } <span class="hljs-comment">// This can happen when we abort work.</span>


                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }

              <span class="hljs-keyword">var</span> currentHostContext = getHostContext(); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move createInstance to beginWork and keep it on a context</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1045" id="section-1045"></a>
</div>
<p>&quot;stack&quot; as the parent. Then append children as we go in beginWork
or completeWork depending on whether we want to add them top-&gt;down or
bottom-&gt;up. Top-&gt;down is faster in IE11.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              <span class="hljs-keyword">var</span> _wasHydrated = popHydrationState(workInProgress);

              <span class="hljs-keyword">if</span> (_wasHydrated) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1046" id="section-1046"></a>
</div>
<p>TODO: Move this and createInstance step into the beginPhase
to consolidate.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">if</span> (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1047" id="section-1047"></a>
</div>
<p>If changes to the hydrated node need to be applied at the
commit-phase we mark this as such.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  markUpdate(workInProgress);
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
                appendAllChildren(instance, workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// This needs to be set before we mount Flare event listeners</span>

                workInProgress.stateNode = instance; <span class="hljs-comment">// (eg DOM renderer supports auto-focus for certain elements).</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1048" id="section-1048"></a>
</div>
<p>Make sure such renderers get scheduled for later work.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                <span class="hljs-keyword">if</span> (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                  markUpdate(workInProgress);
                }
              }

              <span class="hljs-keyword">if</span> (workInProgress.ref !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1049" id="section-1049"></a>
</div>
<p>If there is a ref on a host node we need to schedule a callback</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                markRef$<span class="hljs-number">1</span>(workInProgress);
              }
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> HostText:
          {
            <span class="hljs-keyword">var</span> newText = newProps;

            <span class="hljs-keyword">if</span> (current &amp;&amp; workInProgress.stateNode != <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> oldText = current.memoizedProps; <span class="hljs-comment">// If we have an alternate, that means this is an update and we need</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1050" id="section-1050"></a>
</div>
<p>to schedule a side-effect to do the updates.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              updateHostText$<span class="hljs-number">1</span>(current, workInProgress, oldText, newText);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newText !== <span class="hljs-string">'string'</span>) {
                <span class="hljs-keyword">if</span> (!(workInProgress.stateNode !== <span class="hljs-literal">null</span>)) {
                  {
                    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."</span>);
                  }
                } <span class="hljs-comment">// This can happen when we abort work.</span>

              }

              <span class="hljs-keyword">var</span> _rootContainerInstance = getRootHostContainer();

              <span class="hljs-keyword">var</span> _currentHostContext = getHostContext();

              <span class="hljs-keyword">var</span> _wasHydrated2 = popHydrationState(workInProgress);

              <span class="hljs-keyword">if</span> (_wasHydrated2) {
                <span class="hljs-keyword">if</span> (prepareToHydrateHostTextInstance(workInProgress)) {
                  markUpdate(workInProgress);
                }
              } <span class="hljs-keyword">else</span> {
                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
              }
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseComponent:
          {
            popSuspenseContext(workInProgress);
            <span class="hljs-keyword">var</span> nextState = workInProgress.memoizedState;

            <span class="hljs-keyword">if</span> ((workInProgress.effectTag &amp; DidCapture) !== NoEffect) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1051" id="section-1051"></a>
</div>
<p>Something suspended. Re-render with the fallback children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              workInProgress.expirationTime = renderExpirationTime; <span class="hljs-comment">// Do not reset the effect list.</span>

              <span class="hljs-keyword">return</span> workInProgress;
            }

            <span class="hljs-keyword">var</span> nextDidTimeout = nextState !== <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">var</span> prevDidTimeout = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (workInProgress.memoizedProps.fallback !== <span class="hljs-literal">undefined</span>) {
                popHydrationState(workInProgress);
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> prevState = current.memoizedState;
              prevDidTimeout = prevState !== <span class="hljs-literal">null</span>;

              <span class="hljs-keyword">if</span> (!nextDidTimeout &amp;&amp; prevState !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1052" id="section-1052"></a>
</div>
<p>We just switched from the fallback to the normal children.
Delete the fallback.
TODO: Would it be better to store the fallback fragment on
the stateNode during the begin phase?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> currentFallbackChild = current.child.sibling;

                <span class="hljs-keyword">if</span> (currentFallbackChild !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1053" id="section-1053"></a>
</div>
<p>Deletions go at the beginning of the return fiber's effect list</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  <span class="hljs-keyword">var</span> first = workInProgress.firstEffect;

                  <span class="hljs-keyword">if</span> (first !== <span class="hljs-literal">null</span>) {
                    workInProgress.firstEffect = currentFallbackChild;
                    currentFallbackChild.nextEffect = first;
                  } <span class="hljs-keyword">else</span> {
                    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;
                    currentFallbackChild.nextEffect = <span class="hljs-literal">null</span>;
                  }

                  currentFallbackChild.effectTag = Deletion;
                }
              }
            }

            <span class="hljs-keyword">if</span> (nextDidTimeout &amp;&amp; !prevDidTimeout) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1054" id="section-1054"></a>
</div>
<p>If this subtreee is running in blocking mode we can suspend,
otherwise we won't suspend.
TODO: This will still suspend a synchronous tree if anything
in the concurrent tree already suspended during this render.
This is a known bug.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> ((workInProgress.mode &amp; BlockingMode) !== NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1055" id="section-1055"></a>
</div>
<p>TODO: Move this back to throwException because this is too late
if this is a large tree which is common for initial loads. We
don't know if we should restart a render or not until we get
this marker, and this is too late.
If this render already had a ping or lower pri updates,
and this is the first time we know we're going to suspend we
should be able to immediately restart from within throwException.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> hasInvisibleChildContext = current === <span class="hljs-literal">null</span> &amp;&amp; workInProgress.memoizedProps.unstable_avoidThisFallback !== <span class="hljs-literal">true</span>;

                <span class="hljs-keyword">if</span> (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1056" id="section-1056"></a>
</div>
<p>If this was in an invisible tree or a new render, then showing
this boundary is ok.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  renderDidSuspend();
                } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1057" id="section-1057"></a>
</div>
<p>Otherwise, we're going to have to hide content so we should
suspend for longer if possible.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  renderDidSuspendDelayIfPossible();
                }
              }
            }

            {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1058" id="section-1058"></a>
</div>
<p>TODO: Only schedule updates if these values are non equal, i.e. it changed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (nextDidTimeout || prevDidTimeout) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1059" id="section-1059"></a>
</div>
<p>If this boundary just timed out, schedule an effect to attach a
retry listener to the promise. This flag is also used to hide the
primary children. In mutation mode, we also need the flag to
<em>unhide</em> children that were previously hidden, so check if this
is currently timed out, too.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                workInProgress.effectTag |= Update;
              }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> HostPortal:
          popHostContainer(workInProgress);
          updateHostContainer(workInProgress);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">case</span> ContextProvider:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1060" id="section-1060"></a>
</div>
<p>Pop provider fiber</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          popProvider(workInProgress);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">case</span> IncompleteClassComponent:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1061" id="section-1061"></a>
</div>
<p>Same as class component case. I put it down here so that the tags are
sequential to ensure this switch is compiled to a jump table.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> _Component = workInProgress.type;

            <span class="hljs-keyword">if</span> (isContextProvider(_Component)) {
              popContext(workInProgress);
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseListComponent:
          {
            popSuspenseContext(workInProgress);
            <span class="hljs-keyword">var</span> renderState = workInProgress.memoizedState;

            <span class="hljs-keyword">if</span> (renderState === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1062" id="section-1062"></a>
</div>
<p>We're running in the default, &quot;independent&quot; mode.
We don't do anything in this mode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">var</span> didSuspendAlready = (workInProgress.effectTag &amp; DidCapture) !== NoEffect;
            <span class="hljs-keyword">var</span> renderedTail = renderState.rendering;

            <span class="hljs-keyword">if</span> (renderedTail === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1063" id="section-1063"></a>
</div>
<p>We just rendered the head.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (!didSuspendAlready) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1064" id="section-1064"></a>
</div>
<p>This is the first pass. We need to figure out if anything is still
suspended in the rendered set.
If new content unsuspended, but there's still some content that
didn't. Then we need to do a second pass that forces everything
to keep showing their fallbacks.
We might be suspended if something in this render pass suspended, or
something in the previous committed pass suspended. Otherwise,
there's no chance so we can skip the expensive call to
findFirstSuspended.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> cannotBeSuspended = renderHasNotSuspendedYet() &amp;&amp; (current === <span class="hljs-literal">null</span> || (current.effectTag &amp; DidCapture) === NoEffect);

                <span class="hljs-keyword">if</span> (!cannotBeSuspended) {
                  <span class="hljs-keyword">var</span> row = workInProgress.child;

                  <span class="hljs-keyword">while</span> (row !== <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">var</span> suspended = findFirstSuspended(row);

                    <span class="hljs-keyword">if</span> (suspended !== <span class="hljs-literal">null</span>) {
                      didSuspendAlready = <span class="hljs-literal">true</span>;
                      workInProgress.effectTag |= DidCapture;
                      cutOffTailIfNeeded(renderState, <span class="hljs-literal">false</span>); <span class="hljs-comment">// If this is a newly suspended tree, it might not get committed as</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1065" id="section-1065"></a>
</div>
<p>part of the second pass. In that case nothing will subscribe to
its thennables. Instead, we'll transfer its thennables to the
SuspenseList so that it can retry if they resolve.
There might be multiple of these in the list but since we're
going to wait for all of them anyway, it doesn't really matter
which ones gets to ping. In theory we could get clever and keep
track of how many dependencies remain but it gets tricky because
in the meantime, we can add/remove/change items and dependencies.
We might bail out of the loop before finding any but that
doesn't matter since that means that the other boundaries that
we did find already has their listeners attached.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                      <span class="hljs-keyword">var</span> newThennables = suspended.updateQueue;

                      <span class="hljs-keyword">if</span> (newThennables !== <span class="hljs-literal">null</span>) {
                        workInProgress.updateQueue = newThennables;
                        workInProgress.effectTag |= Update;
                      } <span class="hljs-comment">// Rerender the whole list, but this time, we'll force fallbacks</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1066" id="section-1066"></a>
</div>
<p>to stay in place.
Reset the effect list before doing the second pass since that's now invalid.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

                      <span class="hljs-keyword">if</span> (renderState.lastEffect === <span class="hljs-literal">null</span>) {
                        workInProgress.firstEffect = <span class="hljs-literal">null</span>;
                      }

                      workInProgress.lastEffect = renderState.lastEffect; <span class="hljs-comment">// Reset the child fibers to their original state.</span>

                      resetChildFibers(workInProgress, renderExpirationTime); <span class="hljs-comment">// Set up the Suspense Context to force suspense and immediately</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1067" id="section-1067"></a>
</div>
<p>rerender the children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                      pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                      <span class="hljs-keyword">return</span> workInProgress.child;
                    }

                    row = row.sibling;
                  }
                }
              } <span class="hljs-keyword">else</span> {
                cutOffTailIfNeeded(renderState, <span class="hljs-literal">false</span>);
              } <span class="hljs-comment">// Next we're going to render the tail.</span>

            } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1068" id="section-1068"></a>
</div>
<p>Append the rendered row to the child list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (!didSuspendAlready) {
                <span class="hljs-keyword">var</span> _suspended = findFirstSuspended(renderedTail);

                <span class="hljs-keyword">if</span> (_suspended !== <span class="hljs-literal">null</span>) {
                  workInProgress.effectTag |= DidCapture;
                  didSuspendAlready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Ensure we transfer the update queue to the parent so that it doesn't</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1069" id="section-1069"></a>
</div>
<p>get lost if this row ends up dropped during a second pass.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                  <span class="hljs-keyword">var</span> _newThennables = _suspended.updateQueue;

                  <span class="hljs-keyword">if</span> (_newThennables !== <span class="hljs-literal">null</span>) {
                    workInProgress.updateQueue = _newThennables;
                    workInProgress.effectTag |= Update;
                  }

                  cutOffTailIfNeeded(renderState, <span class="hljs-literal">true</span>); <span class="hljs-comment">// This might have been modified.</span>

                  <span class="hljs-keyword">if</span> (renderState.tail === <span class="hljs-literal">null</span> &amp;&amp; renderState.tailMode === <span class="hljs-string">'hidden'</span> &amp;&amp; !renderedTail.alternate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1070" id="section-1070"></a>
</div>
<p>We need to delete the row we just rendered.
Reset the effect list to what it was before we rendered this
child. The nested children have already appended themselves.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    <span class="hljs-keyword">var</span> lastEffect = workInProgress.lastEffect = renderState.lastEffect; <span class="hljs-comment">// Remove any effects that were appended after this point.</span>

                    <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
                      lastEffect.nextEffect = <span class="hljs-literal">null</span>;
                    } <span class="hljs-comment">// We're done.</span>


                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                  }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// The time it took to render last row is greater than time until</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1071" id="section-1071"></a>
</div>
<p>the expiration.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                now() * <span class="hljs-number">2</span> - renderState.renderingStartTime &gt; renderState.tailExpiration &amp;&amp; renderExpirationTime &gt; Never) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1072" id="section-1072"></a>
</div>
<p>We have now passed our CPU deadline and we'll just give up further
attempts to render the main content and only render fallbacks.
The assumption is that this is usually faster.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  workInProgress.effectTag |= DidCapture;
                  didSuspendAlready = <span class="hljs-literal">true</span>;
                  cutOffTailIfNeeded(renderState, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Since nothing actually suspended, there will nothing to ping this</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1073" id="section-1073"></a>
</div>
<p>to get it started back up to attempt the next item. If we can show
them, then they really have the same priority as this render.
So we'll pick it back up the very next render pass once we've had
an opportunity to yield for paint.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                  <span class="hljs-keyword">var</span> nextPriority = renderExpirationTime - <span class="hljs-number">1</span>;
                  workInProgress.expirationTime = workInProgress.childExpirationTime = nextPriority;
                  {
                    markSpawnedWork(nextPriority);
                  }
                }
              }

              <span class="hljs-keyword">if</span> (renderState.isBackwards) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1074" id="section-1074"></a>
</div>
<p>The effect list of the backwards tail will have been added
to the end. This breaks the guarantee that life-cycles fire in
sibling order but that isn't a strong guarantee promised by React.
Especially since these might also just pop in during future commits.
Append to the beginning of the list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                renderedTail.sibling = workInProgress.child;
                workInProgress.child = renderedTail;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> previousSibling = renderState.last;

                <span class="hljs-keyword">if</span> (previousSibling !== <span class="hljs-literal">null</span>) {
                  previousSibling.sibling = renderedTail;
                } <span class="hljs-keyword">else</span> {
                  workInProgress.child = renderedTail;
                }

                renderState.last = renderedTail;
              }
            }

            <span class="hljs-keyword">if</span> (renderState.tail !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1075" id="section-1075"></a>
</div>
<p>We still have tail rows to render.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (renderState.tailExpiration === <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1076" id="section-1076"></a>
</div>
<p>Heuristic for how long we're willing to spend rendering rows
until we just give up and show what we have so far.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> TAIL_EXPIRATION_TIMEOUT_MS = <span class="hljs-number">500</span>;
                renderState.tailExpiration = now() + TAIL_EXPIRATION_TIMEOUT_MS; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is meant to mimic the train model or JND but this</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1077" id="section-1077"></a>
</div>
<p>is a per component value. It should really be since the start
of the total render or last commit. Consider using something like
globalMostRecentFallbackTime. That doesn't account for being
suspended for part of the time or when it's a new render.
It should probably use a global start time value instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              } <span class="hljs-comment">// Pop a row.</span>


              <span class="hljs-keyword">var</span> next = renderState.tail;
              renderState.rendering = next;
              renderState.tail = next.sibling;
              renderState.lastEffect = workInProgress.lastEffect;
              renderState.renderingStartTime = now();
              next.sibling = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Restore the context.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1078" id="section-1078"></a>
</div>
<p>TODO: We can probably just avoid popping it instead and only
setting it the first time we go from not suspended to suspended.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              <span class="hljs-keyword">var</span> suspenseContext = suspenseStackCursor.current;

              <span class="hljs-keyword">if</span> (didSuspendAlready) {
                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              } <span class="hljs-keyword">else</span> {
                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
              }

              pushSuspenseContext(workInProgress, suspenseContext); <span class="hljs-comment">// Do a pass over the next row.</span>

              <span class="hljs-keyword">return</span> next;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }
      }

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown unit of work tag ("</span> + workInProgress.tag + <span class="hljs-string">"). This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unwindWork</span>(<span class="hljs-params">workInProgress, renderExpirationTime</span>) </span>{
      <span class="hljs-keyword">switch</span> (workInProgress.tag) {
        <span class="hljs-keyword">case</span> ClassComponent:
          {
            <span class="hljs-keyword">var</span> Component = workInProgress.type;

            <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
              popContext(workInProgress);
            }

            <span class="hljs-keyword">var</span> effectTag = workInProgress.effectTag;

            <span class="hljs-keyword">if</span> (effectTag &amp; ShouldCapture) {
              workInProgress.effectTag = effectTag &amp; ~ShouldCapture | DidCapture;
              <span class="hljs-keyword">return</span> workInProgress;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> HostRoot:
          {
            popHostContainer(workInProgress);
            popTopLevelContextObject(workInProgress);
            <span class="hljs-keyword">var</span> _effectTag = workInProgress.effectTag;

            <span class="hljs-keyword">if</span> (!((_effectTag &amp; DidCapture) === NoEffect)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"The root failed to unmount after an error. This is likely a bug in React. Please file an issue."</span>);
              }
            }

            workInProgress.effectTag = _effectTag &amp; ~ShouldCapture | DidCapture;
            <span class="hljs-keyword">return</span> workInProgress;
          }

        <span class="hljs-keyword">case</span> HostComponent:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1079" id="section-1079"></a>
</div>
<p>TODO: popHydrationState</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            popHostContext(workInProgress);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseComponent:
          {
            popSuspenseContext(workInProgress);
            <span class="hljs-keyword">var</span> _effectTag2 = workInProgress.effectTag;

            <span class="hljs-keyword">if</span> (_effectTag2 &amp; ShouldCapture) {
              workInProgress.effectTag = _effectTag2 &amp; ~ShouldCapture | DidCapture; <span class="hljs-comment">// Captured a suspense effect. Re-render the boundary.</span>

              <span class="hljs-keyword">return</span> workInProgress;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseListComponent:
          {
            popSuspenseContext(workInProgress); <span class="hljs-comment">// SuspenseList doesn't actually catch anything. It should've been</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1080" id="section-1080"></a>
</div>
<p>caught by a nested boundary. If not, it should bubble through.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

        <span class="hljs-keyword">case</span> HostPortal:
          popHostContainer(workInProgress);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">case</span> ContextProvider:
          popProvider(workInProgress);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unwindInterruptedWork</span>(<span class="hljs-params">interruptedWork</span>) </span>{
      <span class="hljs-keyword">switch</span> (interruptedWork.tag) {
        <span class="hljs-keyword">case</span> ClassComponent:
          {
            <span class="hljs-keyword">var</span> childContextTypes = interruptedWork.type.childContextTypes;

            <span class="hljs-keyword">if</span> (childContextTypes !== <span class="hljs-literal">null</span> &amp;&amp; childContextTypes !== <span class="hljs-literal">undefined</span>) {
              popContext(interruptedWork);
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> HostRoot:
          {
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> HostComponent:
          {
            popHostContext(interruptedWork);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> HostPortal:
          popHostContainer(interruptedWork);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> SuspenseComponent:
          popSuspenseContext(interruptedWork);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> SuspenseListComponent:
          popSuspenseContext(interruptedWork);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> ContextProvider:
          popProvider(interruptedWork);
          <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCapturedValue</span>(<span class="hljs-params">value, source</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1081" id="section-1081"></a>
</div>
<p>If the value is an error, call this function immediately after it is thrown
so the stack is accurate.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">value</span>: value,
        <span class="hljs-attr">source</span>: source,
        <span class="hljs-attr">stack</span>: getStackByFiberInDevAndProd(source)
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logCapturedError</span>(<span class="hljs-params">capturedError</span>) </span>{
      <span class="hljs-keyword">var</span> error = capturedError.error;
      {
        <span class="hljs-keyword">var</span> componentName = capturedError.componentName,
            componentStack = capturedError.componentStack,
            errorBoundaryName = capturedError.errorBoundaryName,
            errorBoundaryFound = capturedError.errorBoundaryFound,
            willRetry = capturedError.willRetry; <span class="hljs-comment">// Browsers support silencing uncaught errors by calling</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1082" id="section-1082"></a>
</div>
<p><code>preventDefault()</code> in window <code>error</code> handler.
We record this information as an expando on the error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">null</span> &amp;&amp; error._suppressLogging) {
          <span class="hljs-keyword">if</span> (errorBoundaryFound &amp;&amp; willRetry) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1083" id="section-1083"></a>
</div>
<p>The error is recoverable and was silenced.
Ignore it and don't print the stack addendum.
This is handy for testing error boundaries without noise.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span>;
          } <span class="hljs-comment">// The error is fatal. Since the silencing might have</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1084" id="section-1084"></a>
</div>
<p>been accidental, we'll surface it anyway.
However, the browser would have silenced the original error
so we'll print it first, and then print the stack addendum.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          <span class="hljs-built_in">console</span>[<span class="hljs-string">'error'</span>](error); <span class="hljs-comment">// Don't transform to our wrapper</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1085" id="section-1085"></a>
</div>
<p>For a more detailed description of this block, see:
https://github.com/facebook/react/pull/13384</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        }

        <span class="hljs-keyword">var</span> componentNameMessage = componentName ? <span class="hljs-string">"The above error occurred in the &lt;"</span> + componentName + <span class="hljs-string">"&gt; component:"</span> : <span class="hljs-string">'The above error occurred in one of your React components:'</span>;
        <span class="hljs-keyword">var</span> errorBoundaryMessage; <span class="hljs-comment">// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.</span>

        <span class="hljs-keyword">if</span> (errorBoundaryFound &amp;&amp; errorBoundaryName) {
          <span class="hljs-keyword">if</span> (willRetry) {
            errorBoundaryMessage = <span class="hljs-string">"React will try to recreate this component tree from scratch "</span> + (<span class="hljs-string">"using the error boundary you provided, "</span> + errorBoundaryName + <span class="hljs-string">"."</span>);
          } <span class="hljs-keyword">else</span> {
            errorBoundaryMessage = <span class="hljs-string">"This error was initially handled by the error boundary "</span> + errorBoundaryName + <span class="hljs-string">".\n"</span> + <span class="hljs-string">"Recreating the tree from scratch failed so React will unmount the tree."</span>;
          }
        } <span class="hljs-keyword">else</span> {
          errorBoundaryMessage = <span class="hljs-string">'Consider adding an error boundary to your tree to customize error handling behavior.\n'</span> + <span class="hljs-string">'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.'</span>;
        }

        <span class="hljs-keyword">var</span> combinedMessage = <span class="hljs-string">""</span> + componentNameMessage + componentStack + <span class="hljs-string">"\n\n"</span> + (<span class="hljs-string">""</span> + errorBoundaryMessage); <span class="hljs-comment">// In development, we provide our own message with just the component stack.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1086" id="section-1086"></a>
</div>
<p>We don't include the original error message and JS stack because the browser
has already printed it. Even if the application swallows the error, it is still
displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-built_in">console</span>[<span class="hljs-string">'error'</span>](combinedMessage); <span class="hljs-comment">// Don't transform to our wrapper</span>
      }
    }

    <span class="hljs-keyword">var</span> didWarnAboutUndefinedSnapshotBeforeUpdate = <span class="hljs-literal">null</span>;
    {
      didWarnAboutUndefinedSnapshotBeforeUpdate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    }
    <span class="hljs-keyword">var</span> PossiblyWeakSet = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">WeakSet</span> === <span class="hljs-string">'function'</span> ? <span class="hljs-built_in">WeakSet</span> : <span class="hljs-built_in">Set</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logError</span>(<span class="hljs-params">boundary, errorInfo</span>) </span>{
      <span class="hljs-keyword">var</span> source = errorInfo.source;
      <span class="hljs-keyword">var</span> stack = errorInfo.stack;

      <span class="hljs-keyword">if</span> (stack === <span class="hljs-literal">null</span> &amp;&amp; source !== <span class="hljs-literal">null</span>) {
        stack = getStackByFiberInDevAndProd(source);
      }

      <span class="hljs-keyword">var</span> capturedError = {
        <span class="hljs-attr">componentName</span>: source !== <span class="hljs-literal">null</span> ? getComponentName(source.type) : <span class="hljs-literal">null</span>,
        <span class="hljs-attr">componentStack</span>: stack !== <span class="hljs-literal">null</span> ? stack : <span class="hljs-string">''</span>,
        <span class="hljs-attr">error</span>: errorInfo.value,
        <span class="hljs-attr">errorBoundary</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">errorBoundaryName</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">errorBoundaryFound</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">willRetry</span>: <span class="hljs-literal">false</span>
      };

      <span class="hljs-keyword">if</span> (boundary !== <span class="hljs-literal">null</span> &amp;&amp; boundary.tag === ClassComponent) {
        capturedError.errorBoundary = boundary.stateNode;
        capturedError.errorBoundaryName = getComponentName(boundary.type);
        capturedError.errorBoundaryFound = <span class="hljs-literal">true</span>;
        capturedError.willRetry = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">try</span> {
        logCapturedError(capturedError);
      } <span class="hljs-keyword">catch</span> (e) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1087" id="section-1087"></a>
</div>
<p>This method must not throw, or React internal state will get messed up.
If console.error is overridden, or logCapturedError() shows a dialog that throws,
we want to report this error outside of the normal stack as a last resort.
https://github.com/facebook/react/issues/13188</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">throw</span> e;
        });
      }
    }

    <span class="hljs-keyword">var</span> callComponentWillUnmountWithTimer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">current, instance</span>) </span>{
      startPhaseTimer(current, <span class="hljs-string">'componentWillUnmount'</span>);
      instance.props = current.memoizedProps;
      instance.state = current.memoizedState;
      instance.componentWillUnmount();
      stopPhaseTimer();
    }; <span class="hljs-comment">// Capture errors so they don't interrupt unmounting.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safelyCallComponentWillUnmount</span>(<span class="hljs-params">current, instance</span>) </span>{
      {
        invokeGuardedCallback(<span class="hljs-literal">null</span>, callComponentWillUnmountWithTimer, <span class="hljs-literal">null</span>, current, instance);

        <span class="hljs-keyword">if</span> (hasCaughtError()) {
          <span class="hljs-keyword">var</span> unmountError = clearCaughtError();
          captureCommitPhaseError(current, unmountError);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safelyDetachRef</span>(<span class="hljs-params">current</span>) </span>{
      <span class="hljs-keyword">var</span> ref = current.ref;

      <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">'function'</span>) {
          {
            invokeGuardedCallback(<span class="hljs-literal">null</span>, ref, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);

            <span class="hljs-keyword">if</span> (hasCaughtError()) {
              <span class="hljs-keyword">var</span> refError = clearCaughtError();
              captureCommitPhaseError(current, refError);
            }
          }
        } <span class="hljs-keyword">else</span> {
          ref.current = <span class="hljs-literal">null</span>;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safelyCallDestroy</span>(<span class="hljs-params">current, destroy</span>) </span>{
      {
        invokeGuardedCallback(<span class="hljs-literal">null</span>, destroy, <span class="hljs-literal">null</span>);

        <span class="hljs-keyword">if</span> (hasCaughtError()) {
          <span class="hljs-keyword">var</span> error = clearCaughtError();
          captureCommitPhaseError(current, error);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationLifeCycles</span>(<span class="hljs-params">current, finishedWork</span>) </span>{
      <span class="hljs-keyword">switch</span> (finishedWork.tag) {
        <span class="hljs-keyword">case</span> FunctionComponent:
        <span class="hljs-keyword">case</span> ForwardRef:
        <span class="hljs-keyword">case</span> SimpleMemoComponent:
        <span class="hljs-keyword">case</span> Block:
          {
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> ClassComponent:
          {
            <span class="hljs-keyword">if</span> (finishedWork.effectTag &amp; Snapshot) {
              <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">var</span> prevProps = current.memoizedProps;
                <span class="hljs-keyword">var</span> prevState = current.memoizedState;
                startPhaseTimer(finishedWork, <span class="hljs-string">'getSnapshotBeforeUpdate'</span>);
                <span class="hljs-keyword">var</span> instance = finishedWork.stateNode; <span class="hljs-comment">// We could update instance props and state here,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1088" id="section-1088"></a>
</div>
<p>but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                {
                  <span class="hljs-keyword">if</span> (finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {
                    <span class="hljs-keyword">if</span> (instance.props !== finishedWork.memoizedProps) {
                      error(<span class="hljs-string">'Expected %s props to match memoized props before '</span> + <span class="hljs-string">'getSnapshotBeforeUpdate. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                    }

                    <span class="hljs-keyword">if</span> (instance.state !== finishedWork.memoizedState) {
                      error(<span class="hljs-string">'Expected %s state to match memoized state before '</span> + <span class="hljs-string">'getSnapshotBeforeUpdate. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                    }
                  }
                }
                <span class="hljs-keyword">var</span> snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                {
                  <span class="hljs-keyword">var</span> didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

                  <span class="hljs-keyword">if</span> (snapshot === <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnSet.has(finishedWork.type)) {
                    didWarnSet.add(finishedWork.type);
                    error(<span class="hljs-string">'%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '</span> + <span class="hljs-string">'must be returned. You have returned undefined.'</span>, getComponentName(finishedWork.type));
                  }
                }
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                stopPhaseTimer();
              }
            }

            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostRoot:
        <span class="hljs-keyword">case</span> HostComponent:
        <span class="hljs-keyword">case</span> HostText:
        <span class="hljs-keyword">case</span> HostPortal:
        <span class="hljs-keyword">case</span> IncompleteClassComponent:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1089" id="section-1089"></a>
</div>
<p>Nothing to do for these component types</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
      }

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitHookEffectListUnmount</span>(<span class="hljs-params">tag, finishedWork</span>) </span>{
      <span class="hljs-keyword">var</span> updateQueue = finishedWork.updateQueue;
      <span class="hljs-keyword">var</span> lastEffect = updateQueue !== <span class="hljs-literal">null</span> ? updateQueue.lastEffect : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> firstEffect = lastEffect.next;
        <span class="hljs-keyword">var</span> effect = firstEffect;

        <span class="hljs-keyword">do</span> {
          <span class="hljs-keyword">if</span> ((effect.tag &amp; tag) === tag) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1090" id="section-1090"></a>
</div>
<p>Unmount</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> destroy = effect.destroy;
            effect.destroy = <span class="hljs-literal">undefined</span>;

            <span class="hljs-keyword">if</span> (destroy !== <span class="hljs-literal">undefined</span>) {
              destroy();
            }
          }

          effect = effect.next;
        } <span class="hljs-keyword">while</span> (effect !== firstEffect);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitHookEffectListMount</span>(<span class="hljs-params">tag, finishedWork</span>) </span>{
      <span class="hljs-keyword">var</span> updateQueue = finishedWork.updateQueue;
      <span class="hljs-keyword">var</span> lastEffect = updateQueue !== <span class="hljs-literal">null</span> ? updateQueue.lastEffect : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> firstEffect = lastEffect.next;
        <span class="hljs-keyword">var</span> effect = firstEffect;

        <span class="hljs-keyword">do</span> {
          <span class="hljs-keyword">if</span> ((effect.tag &amp; tag) === tag) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1091" id="section-1091"></a>
</div>
<p>Mount</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> create = effect.create;
            effect.destroy = create();
            {
              <span class="hljs-keyword">var</span> destroy = effect.destroy;

              <span class="hljs-keyword">if</span> (destroy !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> destroy !== <span class="hljs-string">'function'</span>) {
                <span class="hljs-keyword">var</span> addendum = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

                <span class="hljs-keyword">if</span> (destroy === <span class="hljs-literal">null</span>) {
                  addendum = <span class="hljs-string">' You returned null. If your effect does not require clean '</span> + <span class="hljs-string">'up, return undefined (or nothing).'</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> destroy.then === <span class="hljs-string">'function'</span>) {
                  addendum = <span class="hljs-string">'\n\nIt looks like you wrote useEffect(async () =&gt; ...) or returned a Promise. '</span> + <span class="hljs-string">'Instead, write the async function inside your effect '</span> + <span class="hljs-string">'and call it immediately:\n\n'</span> + <span class="hljs-string">'useEffect(() =&gt; {\n'</span> + <span class="hljs-string">'  async function fetchData() {\n'</span> + <span class="hljs-string">'    // You can await here\n'</span> + <span class="hljs-string">'    const response = await MyAPI.getData(someId);\n'</span> + <span class="hljs-string">'    // ...\n'</span> + <span class="hljs-string">'  }\n'</span> + <span class="hljs-string">'  fetchData();\n'</span> + <span class="hljs-string">"}, [someId]); // Or [] if effect doesn't need props or state\n\n"</span> + <span class="hljs-string">'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching'</span>;
                } <span class="hljs-keyword">else</span> {
                  addendum = <span class="hljs-string">' You returned: '</span> + destroy;
                }

                error(<span class="hljs-string">'An effect function must not return anything besides a function, '</span> + <span class="hljs-string">'which is used for clean-up.%s%s'</span>, addendum, getStackByFiberInDevAndProd(finishedWork));
              }
            }
          }

          effect = effect.next;
        } <span class="hljs-keyword">while</span> (effect !== firstEffect);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitPassiveHookEffects</span>(<span class="hljs-params">finishedWork</span>) </span>{
      <span class="hljs-keyword">if</span> ((finishedWork.effectTag &amp; Passive) !== NoEffect) {
        <span class="hljs-keyword">switch</span> (finishedWork.tag) {
          <span class="hljs-keyword">case</span> FunctionComponent:
          <span class="hljs-keyword">case</span> ForwardRef:
          <span class="hljs-keyword">case</span> SimpleMemoComponent:
          <span class="hljs-keyword">case</span> Block:
            {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1092" id="section-1092"></a>
</div>
<p>TODO (#17945) We should call all passive destroy functions (for all fibers)
before calling any create functions. The current approach only serializes
these for a single fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              commitHookEffectListUnmount(Passive$<span class="hljs-number">1</span> | HasEffect, finishedWork);
              commitHookEffectListMount(Passive$<span class="hljs-number">1</span> | HasEffect, finishedWork);
              <span class="hljs-keyword">break</span>;
            }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLifeCycles</span>(<span class="hljs-params">finishedRoot, current, finishedWork, committedExpirationTime</span>) </span>{
      <span class="hljs-keyword">switch</span> (finishedWork.tag) {
        <span class="hljs-keyword">case</span> FunctionComponent:
        <span class="hljs-keyword">case</span> ForwardRef:
        <span class="hljs-keyword">case</span> SimpleMemoComponent:
        <span class="hljs-keyword">case</span> Block:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1093" id="section-1093"></a>
</div>
<p>At this point layout effects have already been destroyed (during mutation phase).
This is done to prevent sibling component effects from interfering with each other,
e.g. a destroy function in one component should never override a ref set
by a create function in another component during the same commit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            commitHookEffectListMount(Layout | HasEffect, finishedWork);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> ClassComponent:
          {
            <span class="hljs-keyword">var</span> instance = finishedWork.stateNode;

            <span class="hljs-keyword">if</span> (finishedWork.effectTag &amp; Update) {
              <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
                startPhaseTimer(finishedWork, <span class="hljs-string">'componentDidMount'</span>); <span class="hljs-comment">// We could update instance props and state here,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1094" id="section-1094"></a>
</div>
<p>but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                {
                  <span class="hljs-keyword">if</span> (finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {
                    <span class="hljs-keyword">if</span> (instance.props !== finishedWork.memoizedProps) {
                      error(<span class="hljs-string">'Expected %s props to match memoized props before '</span> + <span class="hljs-string">'componentDidMount. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                    }

                    <span class="hljs-keyword">if</span> (instance.state !== finishedWork.memoizedState) {
                      error(<span class="hljs-string">'Expected %s state to match memoized state before '</span> + <span class="hljs-string">'componentDidMount. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                    }
                  }
                }
                instance.componentDidMount();
                stopPhaseTimer();
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
                <span class="hljs-keyword">var</span> prevState = current.memoizedState;
                startPhaseTimer(finishedWork, <span class="hljs-string">'componentDidUpdate'</span>); <span class="hljs-comment">// We could update instance props and state here,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1095" id="section-1095"></a>
</div>
<p>but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                {
                  <span class="hljs-keyword">if</span> (finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {
                    <span class="hljs-keyword">if</span> (instance.props !== finishedWork.memoizedProps) {
                      error(<span class="hljs-string">'Expected %s props to match memoized props before '</span> + <span class="hljs-string">'componentDidUpdate. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                    }

                    <span class="hljs-keyword">if</span> (instance.state !== finishedWork.memoizedState) {
                      error(<span class="hljs-string">'Expected %s state to match memoized state before '</span> + <span class="hljs-string">'componentDidUpdate. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                    }
                  }
                }
                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                stopPhaseTimer();
              }
            }

            <span class="hljs-keyword">var</span> updateQueue = finishedWork.updateQueue;

            <span class="hljs-keyword">if</span> (updateQueue !== <span class="hljs-literal">null</span>) {
              {
                <span class="hljs-keyword">if</span> (finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {
                  <span class="hljs-keyword">if</span> (instance.props !== finishedWork.memoizedProps) {
                    error(<span class="hljs-string">'Expected %s props to match memoized props before '</span> + <span class="hljs-string">'processing the update queue. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                  }

                  <span class="hljs-keyword">if</span> (instance.state !== finishedWork.memoizedState) {
                    error(<span class="hljs-string">'Expected %s state to match memoized state before '</span> + <span class="hljs-string">'processing the update queue. '</span> + <span class="hljs-string">'This might either be because of a bug in React, or because '</span> + <span class="hljs-string">'a component reassigns its own `this.props`. '</span> + <span class="hljs-string">'Please file an issue.'</span>, getComponentName(finishedWork.type) || <span class="hljs-string">'instance'</span>);
                  }
                }
              } <span class="hljs-comment">// We could update instance props and state here,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1096" id="section-1096"></a>
</div>
<p>but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              commitUpdateQueue(finishedWork, updateQueue, instance);
            }

            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostRoot:
          {
            <span class="hljs-keyword">var</span> _updateQueue = finishedWork.updateQueue;

            <span class="hljs-keyword">if</span> (_updateQueue !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> _instance = <span class="hljs-literal">null</span>;

              <span class="hljs-keyword">if</span> (finishedWork.child !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">switch</span> (finishedWork.child.tag) {
                  <span class="hljs-keyword">case</span> HostComponent:
                    _instance = getPublicInstance(finishedWork.child.stateNode);
                    <span class="hljs-keyword">break</span>;

                  <span class="hljs-keyword">case</span> ClassComponent:
                    _instance = finishedWork.child.stateNode;
                    <span class="hljs-keyword">break</span>;
                }
              }

              commitUpdateQueue(finishedWork, _updateQueue, _instance);
            }

            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostComponent:
          {
            <span class="hljs-keyword">var</span> _instance2 = finishedWork.stateNode; <span class="hljs-comment">// Renderers may schedule work to be done after host components are mounted</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1097" id="section-1097"></a>
</div>
<p>(eg DOM renderer may schedule auto-focus for inputs and form controls).
These effects should only be committed when components are first mounted,
aka when there is no current/alternate.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> &amp;&amp; finishedWork.effectTag &amp; Update) {
              <span class="hljs-keyword">var</span> type = finishedWork.type;
              <span class="hljs-keyword">var</span> props = finishedWork.memoizedProps;
              commitMount(_instance2, type, props);
            }

            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostText:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1098" id="section-1098"></a>
</div>
<p>We have no life-cycles associated with text.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostPortal:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1099" id="section-1099"></a>
</div>
<p>We have no life-cycles associated with portals.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> Profiler:
          {
            {
              <span class="hljs-keyword">var</span> onRender = finishedWork.memoizedProps.onRender;

              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRender === <span class="hljs-string">'function'</span>) {
                {
                  onRender(finishedWork.memoizedProps.id, current === <span class="hljs-literal">null</span> ? <span class="hljs-string">'mount'</span> : <span class="hljs-string">'update'</span>, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
                }
              }
            }
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseComponent:
          {
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseListComponent:
        <span class="hljs-keyword">case</span> IncompleteClassComponent:
        <span class="hljs-keyword">case</span> FundamentalComponent:
        <span class="hljs-keyword">case</span> ScopeComponent:
          <span class="hljs-keyword">return</span>;
      }

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideOrUnhideAllChildren</span>(<span class="hljs-params">finishedWork, isHidden</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1100" id="section-1100"></a>
</div>
<p>We only have the top Fiber that was inserted but we need to recurse down its
children to find all the terminal nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> node = finishedWork;

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">if</span> (node.tag === HostComponent) {
            <span class="hljs-keyword">var</span> instance = node.stateNode;

            <span class="hljs-keyword">if</span> (isHidden) {
              hideInstance(instance);
            } <span class="hljs-keyword">else</span> {
              unhideInstance(node.stateNode, node.memoizedProps);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.tag === HostText) {
            <span class="hljs-keyword">var</span> _instance3 = node.stateNode;

            <span class="hljs-keyword">if</span> (isHidden) {
              hideTextInstance(_instance3);
            } <span class="hljs-keyword">else</span> {
              unhideTextInstance(_instance3, node.memoizedProps);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.tag === SuspenseComponent &amp;&amp; node.memoizedState !== <span class="hljs-literal">null</span> &amp;&amp; node.memoizedState.dehydrated === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1101" id="section-1101"></a>
</div>
<p>Found a nested Suspense component that timed out. Skip over the
primary child fragment, which should remain hidden.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> fallbackChildFragment = node.child.sibling;
            fallbackChildFragment.return = node;
            node = fallbackChildFragment;
            <span class="hljs-keyword">continue</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
            node.child.return = node;
            node = node.child;
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (node === finishedWork) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === finishedWork) {
              <span class="hljs-keyword">return</span>;
            }

            node = node.return;
          }

          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitAttachRef</span>(<span class="hljs-params">finishedWork</span>) </span>{
      <span class="hljs-keyword">var</span> ref = finishedWork.ref;

      <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> instance = finishedWork.stateNode;
        <span class="hljs-keyword">var</span> instanceToUse;

        <span class="hljs-keyword">switch</span> (finishedWork.tag) {
          <span class="hljs-keyword">case</span> HostComponent:
            instanceToUse = getPublicInstance(instance);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
            instanceToUse = instance;
        } <span class="hljs-comment">// Moved outside to ensure DCE works with this flag</span>


        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">'function'</span>) {
          ref(instanceToUse);
        } <span class="hljs-keyword">else</span> {
          {
            <span class="hljs-keyword">if</span> (!ref.hasOwnProperty(<span class="hljs-string">'current'</span>)) {
              error(<span class="hljs-string">'Unexpected ref object provided for %s. '</span> + <span class="hljs-string">'Use either a ref-setter function or React.createRef().%s'</span>, getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
            }
          }
          ref.current = instanceToUse;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitDetachRef</span>(<span class="hljs-params">current</span>) </span>{
      <span class="hljs-keyword">var</span> currentRef = current.ref;

      <span class="hljs-keyword">if</span> (currentRef !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> currentRef === <span class="hljs-string">'function'</span>) {
          currentRef(<span class="hljs-literal">null</span>);
        } <span class="hljs-keyword">else</span> {
          currentRef.current = <span class="hljs-literal">null</span>;
        }
      }
    } <span class="hljs-comment">// User-originating errors (lifecycles and refs) should not interrupt</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1102" id="section-1102"></a>
</div>
<p>deletion, so don't let them throw. Host-originating errors should
interrupt deletion, so it's okay</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitUnmount</span>(<span class="hljs-params">finishedRoot, current, renderPriorityLevel</span>) </span>{
      onCommitUnmount(current);

      <span class="hljs-keyword">switch</span> (current.tag) {
        <span class="hljs-keyword">case</span> FunctionComponent:
        <span class="hljs-keyword">case</span> ForwardRef:
        <span class="hljs-keyword">case</span> MemoComponent:
        <span class="hljs-keyword">case</span> SimpleMemoComponent:
        <span class="hljs-keyword">case</span> Block:
          {
            <span class="hljs-keyword">var</span> updateQueue = current.updateQueue;

            <span class="hljs-keyword">if</span> (updateQueue !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> lastEffect = updateQueue.lastEffect;

              <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">var</span> firstEffect = lastEffect.next;
                {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1103" id="section-1103"></a>
</div>
<p>When the owner fiber is deleted, the destroy function of a passive
effect hook is called during the synchronous commit phase. This is
a concession to implementation complexity. Calling it in the
passive effect phase (like they usually are, when dependencies
change during an update) would require either traversing the
children of the deleted fiber again, or including unmount effects
as part of the fiber effect list.</p>
<p>Because this is during the sync commit phase, we need to change
the priority.</p>
<p>TODO: Reconsider this implementation trade off.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  <span class="hljs-keyword">var</span> priorityLevel = renderPriorityLevel &gt; NormalPriority ? NormalPriority : renderPriorityLevel;
                  runWithPriority$<span class="hljs-number">1</span>(priorityLevel, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> effect = firstEffect;

                    <span class="hljs-keyword">do</span> {
                      <span class="hljs-keyword">var</span> _destroy = effect.destroy;

                      <span class="hljs-keyword">if</span> (_destroy !== <span class="hljs-literal">undefined</span>) {
                        safelyCallDestroy(current, _destroy);
                      }

                      effect = effect.next;
                    } <span class="hljs-keyword">while</span> (effect !== firstEffect);
                  });
                }
              }
            }

            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> ClassComponent:
          {
            safelyDetachRef(current);
            <span class="hljs-keyword">var</span> instance = current.stateNode;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.componentWillUnmount === <span class="hljs-string">'function'</span>) {
              safelyCallComponentWillUnmount(current, instance);
            }

            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostComponent:
          {
            safelyDetachRef(current);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostPortal:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1104" id="section-1104"></a>
</div>
<p>TODO: this is recursive.
We are also not using this parent because
the portal will get pushed immediately.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            {
              unmountHostComponents(finishedRoot, current, renderPriorityLevel);
            }
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> FundamentalComponent:
          {
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> DehydratedFragment:
          {
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> ScopeComponent:
          {
            <span class="hljs-keyword">return</span>;
          }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitNestedUnmounts</span>(<span class="hljs-params">finishedRoot, root, renderPriorityLevel</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1105" id="section-1105"></a>
</div>
<p>While we're inside a removed host node we don't want to call
removeChild on the inner nodes because they're removed by the top
call anyway. We also want to call componentWillUnmount on all
composites before this host node is removed from the tree. Therefore
we do an inner loop while we're still inside the host node.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> node = root;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        commitUnmount(finishedRoot, node, renderPriorityLevel); <span class="hljs-comment">// Visit children because they may contain more composite or host nodes.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1106" id="section-1106"></a>
</div>
<p>Skip portals because commitUnmount() currently visits them recursively.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-comment">// If we use mutation we drill down into portals using commitUnmount above.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1107" id="section-1107"></a>
</div>
<p>If we don't use mutation we drill down into portals here instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        node.tag !== HostPortal) {
          node.child.return = node;
          node = node.child;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === root) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === root) {
            <span class="hljs-keyword">return</span>;
          }

          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detachFiber</span>(<span class="hljs-params">current</span>) </span>{
      <span class="hljs-keyword">var</span> alternate = current.alternate; <span class="hljs-comment">// Cut off the return pointers to disconnect it from the tree. Ideally, we</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1108" id="section-1108"></a>
</div>
<p>should clear the child pointer of the parent alternate to let this
get GC:ed but we don't know which for sure which parent is the current
one so we'll settle for GC:ing the subtree of this child. This child
itself will be GC:ed when the parent updates the next time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      current.return = <span class="hljs-literal">null</span>;
      current.child = <span class="hljs-literal">null</span>;
      current.memoizedState = <span class="hljs-literal">null</span>;
      current.updateQueue = <span class="hljs-literal">null</span>;
      current.dependencies = <span class="hljs-literal">null</span>;
      current.alternate = <span class="hljs-literal">null</span>;
      current.firstEffect = <span class="hljs-literal">null</span>;
      current.lastEffect = <span class="hljs-literal">null</span>;
      current.pendingProps = <span class="hljs-literal">null</span>;
      current.memoizedProps = <span class="hljs-literal">null</span>;
      current.stateNode = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
        detachFiber(alternate);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHostParentFiber</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> parent = fiber.return;

      <span class="hljs-keyword">while</span> (parent !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (isHostParent(parent)) {
          <span class="hljs-keyword">return</span> parent;
        }

        parent = parent.return;
      }

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isHostParent</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">return</span> fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHostSibling</span>(<span class="hljs-params">fiber</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1109" id="section-1109"></a>
</div>
<p>We're going to search forward into the tree until we find a sibling host
node. Unfortunately, if multiple insertions are done in a row we have to
search past them. This leads to exponential search for the next sibling.
TODO: Find a more efficient way to do this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> node = fiber;

      siblings: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1110" id="section-1110"></a>
</div>
<p>If we didn't find anything, let's try the next sibling.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || isHostParent(node.return)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1111" id="section-1111"></a>
</div>
<p>If we pop out of the root or hit the parent the fiber we are the
last sibling.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          node = node.return;
        }

        node.sibling.return = node.return;
        node = node.sibling;

        <span class="hljs-keyword">while</span> (node.tag !== HostComponent &amp;&amp; node.tag !== HostText &amp;&amp; node.tag !== DehydratedFragment) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1112" id="section-1112"></a>
</div>
<p>If it is not host node and, we might have a host node inside it.
Try to search down until we find one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (node.effectTag &amp; Placement) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1113" id="section-1113"></a>
</div>
<p>If we don't have a child, try the siblings instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">continue</span> siblings;
          } <span class="hljs-comment">// If we don't have a child, try the siblings instead.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1114" id="section-1114"></a>
</div>
<p>We also skip portals because they are not part of this host tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          <span class="hljs-keyword">if</span> (node.child === <span class="hljs-literal">null</span> || node.tag === HostPortal) {
            <span class="hljs-keyword">continue</span> siblings;
          } <span class="hljs-keyword">else</span> {
            node.child.return = node;
            node = node.child;
          }
        } <span class="hljs-comment">// Check if this host node is stable or about to be placed.</span>


        <span class="hljs-keyword">if</span> (!(node.effectTag &amp; Placement)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1115" id="section-1115"></a>
</div>
<p>Found it!</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> node.stateNode;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitPlacement</span>(<span class="hljs-params">finishedWork</span>) </span>{
      <span class="hljs-keyword">var</span> parentFiber = getHostParentFiber(finishedWork); <span class="hljs-comment">// Note: these two variables *must* always be updated together.</span>

      <span class="hljs-keyword">var</span> parent;
      <span class="hljs-keyword">var</span> isContainer;
      <span class="hljs-keyword">var</span> parentStateNode = parentFiber.stateNode;

      <span class="hljs-keyword">switch</span> (parentFiber.tag) {
        <span class="hljs-keyword">case</span> HostComponent:
          parent = parentStateNode;
          isContainer = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> HostRoot:
          parent = parentStateNode.containerInfo;
          isContainer = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> HostPortal:
          parent = parentStateNode.containerInfo;
          isContainer = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> FundamentalComponent: <span class="hljs-comment">// eslint-disable-next-line-no-fallthrough</span>

        <span class="hljs-keyword">default</span>:
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."</span>);
            }
          }
      }

      <span class="hljs-keyword">if</span> (parentFiber.effectTag &amp; ContentReset) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1116" id="section-1116"></a>
</div>
<p>Reset the text content of the parent before doing any insertions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        resetTextContent(parent); <span class="hljs-comment">// Clear ContentReset from the effect tag</span>

        parentFiber.effectTag &amp;= ~ContentReset;
      }

      <span class="hljs-keyword">var</span> before = getHostSibling(finishedWork); <span class="hljs-comment">// We only have the top Fiber that was inserted but we need to recurse down its</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1117" id="section-1117"></a>
</div>
<p>children to find all the terminal nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (isContainer) {
        insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
      } <span class="hljs-keyword">else</span> {
        insertOrAppendPlacementNode(finishedWork, before, parent);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertOrAppendPlacementNodeIntoContainer</span>(<span class="hljs-params">node, before, parent</span>) </span>{
      <span class="hljs-keyword">var</span> tag = node.tag;
      <span class="hljs-keyword">var</span> isHost = tag === HostComponent || tag === HostText;

      <span class="hljs-keyword">if</span> (isHost || enableFundamentalAPI) {
        <span class="hljs-keyword">var</span> stateNode = isHost ? node.stateNode : node.stateNode.instance;

        <span class="hljs-keyword">if</span> (before) {
          insertInContainerBefore(parent, stateNode, before);
        } <span class="hljs-keyword">else</span> {
          appendChildToContainer(parent, stateNode);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === HostPortal) ;<span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> child = node.child;

        <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
          insertOrAppendPlacementNodeIntoContainer(child, before, parent);
          <span class="hljs-keyword">var</span> sibling = child.sibling;

          <span class="hljs-keyword">while</span> (sibling !== <span class="hljs-literal">null</span>) {
            insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
            sibling = sibling.sibling;
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertOrAppendPlacementNode</span>(<span class="hljs-params">node, before, parent</span>) </span>{
      <span class="hljs-keyword">var</span> tag = node.tag;
      <span class="hljs-keyword">var</span> isHost = tag === HostComponent || tag === HostText;

      <span class="hljs-keyword">if</span> (isHost || enableFundamentalAPI) {
        <span class="hljs-keyword">var</span> stateNode = isHost ? node.stateNode : node.stateNode.instance;

        <span class="hljs-keyword">if</span> (before) {
          insertBefore(parent, stateNode, before);
        } <span class="hljs-keyword">else</span> {
          appendChild(parent, stateNode);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === HostPortal) ;<span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> child = node.child;

        <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
          insertOrAppendPlacementNode(child, before, parent);
          <span class="hljs-keyword">var</span> sibling = child.sibling;

          <span class="hljs-keyword">while</span> (sibling !== <span class="hljs-literal">null</span>) {
            insertOrAppendPlacementNode(sibling, before, parent);
            sibling = sibling.sibling;
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmountHostComponents</span>(<span class="hljs-params">finishedRoot, current, renderPriorityLevel</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1118" id="section-1118"></a>
</div>
<p>We only have the top Fiber that was deleted but we need to recurse down its
children to find all the terminal nodes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> node = current; <span class="hljs-comment">// Each iteration, currentParent is populated with node's host parent if not</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1119" id="section-1119"></a>
</div>
<p>currentParentIsValid.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> currentParentIsValid = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Note: these two variables *must* always be updated together.</span>

      <span class="hljs-keyword">var</span> currentParent;
      <span class="hljs-keyword">var</span> currentParentIsContainer;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (!currentParentIsValid) {
          <span class="hljs-keyword">var</span> parent = node.return;

          findParent: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">if</span> (!(parent !== <span class="hljs-literal">null</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."</span>);
              }
            }

            <span class="hljs-keyword">var</span> parentStateNode = parent.stateNode;

            <span class="hljs-keyword">switch</span> (parent.tag) {
              <span class="hljs-keyword">case</span> HostComponent:
                currentParent = parentStateNode;
                currentParentIsContainer = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">break</span> findParent;

              <span class="hljs-keyword">case</span> HostRoot:
                currentParent = parentStateNode.containerInfo;
                currentParentIsContainer = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span> findParent;

              <span class="hljs-keyword">case</span> HostPortal:
                currentParent = parentStateNode.containerInfo;
                currentParentIsContainer = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span> findParent;
            }

            parent = parent.return;
          }

          currentParentIsValid = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (node.tag === HostComponent || node.tag === HostText) {
          commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); <span class="hljs-comment">// After all the children have unmounted, it is now safe to remove the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1120" id="section-1120"></a>
</div>
<p>node from the tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          <span class="hljs-keyword">if</span> (currentParentIsContainer) {
            removeChildFromContainer(currentParent, node.stateNode);
          } <span class="hljs-keyword">else</span> {
            removeChild(currentParent, node.stateNode);
          } <span class="hljs-comment">// Don't visit children because we already visited them.</span>

        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.tag === HostPortal) {
          <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1121" id="section-1121"></a>
</div>
<p>When we go into a portal, it becomes the parent to remove from.
We will reassign it back when we pop the portal on the way up.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            currentParent = node.stateNode.containerInfo;
            currentParentIsContainer = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Visit children because portals might contain host components.</span>

            node.child.return = node;
            node = node.child;
            <span class="hljs-keyword">continue</span>;
          }
        } <span class="hljs-keyword">else</span> {
          commitUnmount(finishedRoot, node, renderPriorityLevel); <span class="hljs-comment">// Visit children because we may find more host components below.</span>

          <span class="hljs-keyword">if</span> (node.child !== <span class="hljs-literal">null</span>) {
            node.child.return = node;
            node = node.child;
            <span class="hljs-keyword">continue</span>;
          }
        }

        <span class="hljs-keyword">if</span> (node === current) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">while</span> (node.sibling === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> || node.return === current) {
            <span class="hljs-keyword">return</span>;
          }

          node = node.return;

          <span class="hljs-keyword">if</span> (node.tag === HostPortal) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1122" id="section-1122"></a>
</div>
<p>When we go out of the portal, we need to restore the parent.
Since we don't keep a stack of them, we will search for it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            currentParentIsValid = <span class="hljs-literal">false</span>;
          }
        }

        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitDeletion</span>(<span class="hljs-params">finishedRoot, current, renderPriorityLevel</span>) </span>{
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1123" id="section-1123"></a>
</div>
<p>Recursively delete all host nodes from the parent.
Detach refs and call componentWillUnmount() on the whole subtree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        unmountHostComponents(finishedRoot, current, renderPriorityLevel);
      }
      detachFiber(current);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitWork</span>(<span class="hljs-params">current, finishedWork</span>) </span>{
      <span class="hljs-keyword">switch</span> (finishedWork.tag) {
        <span class="hljs-keyword">case</span> FunctionComponent:
        <span class="hljs-keyword">case</span> ForwardRef:
        <span class="hljs-keyword">case</span> MemoComponent:
        <span class="hljs-keyword">case</span> SimpleMemoComponent:
        <span class="hljs-keyword">case</span> Block:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1124" id="section-1124"></a>
</div>
<p>Layout effects are destroyed during the mutation phase so that all
destroy functions for all fibers are called before any create functions.
This prevents sibling component effects from interfering with each other,
e.g. a destroy function in one component should never override a ref set
by a create function in another component during the same commit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> ClassComponent:
          {
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostComponent:
          {
            <span class="hljs-keyword">var</span> instance = finishedWork.stateNode;

            <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1125" id="section-1125"></a>
</div>
<p>Commit the work prepared earlier.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> newProps = finishedWork.memoizedProps; <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1126" id="section-1126"></a>
</div>
<p>as the newProps. The updatePayload will contain the real change in
this case.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              <span class="hljs-keyword">var</span> oldProps = current !== <span class="hljs-literal">null</span> ? current.memoizedProps : newProps;
              <span class="hljs-keyword">var</span> type = finishedWork.type; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Type the updateQueue to be specific to host components.</span>

              <span class="hljs-keyword">var</span> updatePayload = finishedWork.updateQueue;
              finishedWork.updateQueue = <span class="hljs-literal">null</span>;

              <span class="hljs-keyword">if</span> (updatePayload !== <span class="hljs-literal">null</span>) {
                commitUpdate(instance, updatePayload, type, oldProps, newProps);
              }
            }

            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostText:
          {
            <span class="hljs-keyword">if</span> (!(finishedWork.stateNode !== <span class="hljs-literal">null</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."</span>);
              }
            }

            <span class="hljs-keyword">var</span> textInstance = finishedWork.stateNode;
            <span class="hljs-keyword">var</span> newText = finishedWork.memoizedProps; <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1127" id="section-1127"></a>
</div>
<p>as the newProps. The updatePayload will contain the real change in
this case.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">var</span> oldText = current !== <span class="hljs-literal">null</span> ? current.memoizedProps : newText;
            commitTextUpdate(textInstance, oldText, newText);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> HostRoot:
          {
            {
              <span class="hljs-keyword">var</span> _root = finishedWork.stateNode;

              <span class="hljs-keyword">if</span> (_root.hydrate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1128" id="section-1128"></a>
</div>
<p>We've just hydrated. No need to hydrate again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                _root.hydrate = <span class="hljs-literal">false</span>;
                commitHydratedContainer(_root.containerInfo);
              }
            }
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> Profiler:
          {
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseComponent:
          {
            commitSuspenseComponent(finishedWork);
            attachSuspenseRetryListeners(finishedWork);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> SuspenseListComponent:
          {
            attachSuspenseRetryListeners(finishedWork);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> IncompleteClassComponent:
          {
            <span class="hljs-keyword">return</span>;
          }
      }

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitSuspenseComponent</span>(<span class="hljs-params">finishedWork</span>) </span>{
      <span class="hljs-keyword">var</span> newState = finishedWork.memoizedState;
      <span class="hljs-keyword">var</span> newDidTimeout;
      <span class="hljs-keyword">var</span> primaryChildParent = finishedWork;

      <span class="hljs-keyword">if</span> (newState === <span class="hljs-literal">null</span>) {
        newDidTimeout = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> {
        newDidTimeout = <span class="hljs-literal">true</span>;
        primaryChildParent = finishedWork.child;
        markCommitTimeOfFallback();
      }

      <span class="hljs-keyword">if</span> (primaryChildParent !== <span class="hljs-literal">null</span>) {
        hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitSuspenseHydrationCallbacks</span>(<span class="hljs-params">finishedRoot, finishedWork</span>) </span>{
      <span class="hljs-keyword">var</span> newState = finishedWork.memoizedState;

      <span class="hljs-keyword">if</span> (newState === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> current = finishedWork.alternate;

        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> prevState = current.memoizedState;

          <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> suspenseInstance = prevState.dehydrated;

            <span class="hljs-keyword">if</span> (suspenseInstance !== <span class="hljs-literal">null</span>) {
              commitHydratedSuspenseInstance(suspenseInstance);
            }
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attachSuspenseRetryListeners</span>(<span class="hljs-params">finishedWork</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1129" id="section-1129"></a>
</div>
<p>If this boundary just timed out, then it will have a set of thenables.
For each thenable, attach a listener so that when it resolves, React
attempts to re-render the boundary in the primary (pre-timeout) state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> thenables = finishedWork.updateQueue;

      <span class="hljs-keyword">if</span> (thenables !== <span class="hljs-literal">null</span>) {
        finishedWork.updateQueue = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> retryCache = finishedWork.stateNode;

        <span class="hljs-keyword">if</span> (retryCache === <span class="hljs-literal">null</span>) {
          retryCache = finishedWork.stateNode = <span class="hljs-keyword">new</span> PossiblyWeakSet();
        }

        thenables.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thenable</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1130" id="section-1130"></a>
</div>
<p>Memoize using the boundary fiber to prevent redundant listeners.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> retry = resolveRetryThenable.bind(<span class="hljs-literal">null</span>, finishedWork, thenable);

          <span class="hljs-keyword">if</span> (!retryCache.has(thenable)) {
            {
              <span class="hljs-keyword">if</span> (thenable.__reactDoNotTraceInteractions !== <span class="hljs-literal">true</span>) {
                retry = tracing.unstable_wrap(retry);
              }
            }
            retryCache.add(thenable);
            thenable.then(retry, retry);
          }
        });
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitResetTextContent</span>(<span class="hljs-params">current</span>) </span>{
      resetTextContent(current.stateNode);
    }

    <span class="hljs-keyword">var</span> PossiblyWeakMap$<span class="hljs-number">1</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">WeakMap</span> === <span class="hljs-string">'function'</span> ? <span class="hljs-built_in">WeakMap</span> : <span class="hljs-built_in">Map</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRootErrorUpdate</span>(<span class="hljs-params">fiber, errorInfo, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> update = createUpdate(expirationTime, <span class="hljs-literal">null</span>); <span class="hljs-comment">// Unmount the root by rendering null.</span>

      update.tag = CaptureUpdate; <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1131" id="section-1131"></a>
</div>
<p>being called &quot;element&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      update.payload = {
        <span class="hljs-attr">element</span>: <span class="hljs-literal">null</span>
      };
      <span class="hljs-keyword">var</span> error = errorInfo.value;

      update.callback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        onUncaughtError(error);
        logError(fiber, errorInfo);
      };

      <span class="hljs-keyword">return</span> update;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createClassErrorUpdate</span>(<span class="hljs-params">fiber, errorInfo, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> update = createUpdate(expirationTime, <span class="hljs-literal">null</span>);
      update.tag = CaptureUpdate;
      <span class="hljs-keyword">var</span> getDerivedStateFromError = fiber.type.getDerivedStateFromError;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromError === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">var</span> error$<span class="hljs-number">1</span> = errorInfo.value;

        update.payload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          logError(fiber, errorInfo);
          <span class="hljs-keyword">return</span> getDerivedStateFromError(error$<span class="hljs-number">1</span>);
        };
      }

      <span class="hljs-keyword">var</span> inst = fiber.stateNode;

      <span class="hljs-keyword">if</span> (inst !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> inst.componentDidCatch === <span class="hljs-string">'function'</span>) {
        update.callback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>) </span>{
          {
            markFailedErrorBoundaryForHotReloading(fiber);
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromError !== <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1132" id="section-1132"></a>
</div>
<p>To preserve the preexisting retry behavior of error boundaries,
we keep track of which ones already failed during this batch.
This gets reset before we yield back to the browser.
TODO: Warn in strict mode if getDerivedStateFromError is
not defined.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            markLegacyErrorBoundaryAsFailed(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// Only log here if componentDidCatch is the only error boundary method defined</span>

            logError(fiber, errorInfo);
          }

          <span class="hljs-keyword">var</span> error$<span class="hljs-number">1</span> = errorInfo.value;
          <span class="hljs-keyword">var</span> stack = errorInfo.stack;
          <span class="hljs-keyword">this</span>.componentDidCatch(error$<span class="hljs-number">1</span>, {
            <span class="hljs-attr">componentStack</span>: stack !== <span class="hljs-literal">null</span> ? stack : <span class="hljs-string">''</span>
          });
          {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromError !== <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1133" id="section-1133"></a>
</div>
<p>If componentDidCatch is the only error boundary method defined,
then it needs to call setState to recover from errors.
If no state update is scheduled then the boundary will swallow the error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (fiber.expirationTime !== Sync) {
                error(<span class="hljs-string">'%s: Error boundaries should implement getDerivedStateFromError(). '</span> + <span class="hljs-string">'In that method, return a state update to display an error message or fallback UI.'</span>, getComponentName(fiber.type) || <span class="hljs-string">'Unknown'</span>);
              }
            }
          }
        };
      } <span class="hljs-keyword">else</span> {
        update.callback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          markFailedErrorBoundaryForHotReloading(fiber);
        };
      }

      <span class="hljs-keyword">return</span> update;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attachPingListener</span>(<span class="hljs-params">root, renderExpirationTime, thenable</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1134" id="section-1134"></a>
</div>
<p>Attach a listener to the promise to &quot;ping&quot; the root and retry. But
only if one does not already exist for the current render expiration
time (which acts like a &quot;thread ID&quot; here).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> pingCache = root.pingCache;
      <span class="hljs-keyword">var</span> threadIDs;

      <span class="hljs-keyword">if</span> (pingCache === <span class="hljs-literal">null</span>) {
        pingCache = root.pingCache = <span class="hljs-keyword">new</span> PossiblyWeakMap$<span class="hljs-number">1</span>();
        threadIDs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
        pingCache.set(thenable, threadIDs);
      } <span class="hljs-keyword">else</span> {
        threadIDs = pingCache.get(thenable);

        <span class="hljs-keyword">if</span> (threadIDs === <span class="hljs-literal">undefined</span>) {
          threadIDs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
          pingCache.set(thenable, threadIDs);
        }
      }

      <span class="hljs-keyword">if</span> (!threadIDs.has(renderExpirationTime)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1135" id="section-1135"></a>
</div>
<p>Memoize using the thread ID to prevent redundant listeners.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        threadIDs.add(renderExpirationTime);
        <span class="hljs-keyword">var</span> ping = pingSuspendedRoot.bind(<span class="hljs-literal">null</span>, root, thenable, renderExpirationTime);
        thenable.then(ping, ping);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwException</span>(<span class="hljs-params">root, returnFiber, sourceFiber, value, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1136" id="section-1136"></a>
</div>
<p>The source fiber did not complete.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      sourceFiber.effectTag |= Incomplete; <span class="hljs-comment">// Its effect list is no longer valid.</span>

      sourceFiber.firstEffect = sourceFiber.lastEffect = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.then === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1137" id="section-1137"></a>
</div>
<p>This is a thenable.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> thenable = value;

        <span class="hljs-keyword">if</span> ((sourceFiber.mode &amp; BlockingMode) === NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1138" id="section-1138"></a>
</div>
<p>Reset the memoizedState to what it was before we attempted
to render it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> currentSource = sourceFiber.alternate;

          <span class="hljs-keyword">if</span> (currentSource) {
            sourceFiber.updateQueue = currentSource.updateQueue;
            sourceFiber.memoizedState = currentSource.memoizedState;
            sourceFiber.expirationTime = currentSource.expirationTime;
          } <span class="hljs-keyword">else</span> {
            sourceFiber.updateQueue = <span class="hljs-literal">null</span>;
            sourceFiber.memoizedState = <span class="hljs-literal">null</span>;
          }
        }

        <span class="hljs-keyword">var</span> hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); <span class="hljs-comment">// Schedule the nearest Suspense to re-render the timed out view.</span>

        <span class="hljs-keyword">var</span> _workInProgress = returnFiber;

        <span class="hljs-keyword">do</span> {
          <span class="hljs-keyword">if</span> (_workInProgress.tag === SuspenseComponent &amp;&amp; shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1139" id="section-1139"></a>
</div>
<p>Found the nearest boundary.
Stash the promise on the boundary fiber. If the boundary times out, we'll
attach another listener to flip the boundary back to its normal state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> thenables = _workInProgress.updateQueue;

            <span class="hljs-keyword">if</span> (thenables === <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> updateQueue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
              updateQueue.add(thenable);
              _workInProgress.updateQueue = updateQueue;
            } <span class="hljs-keyword">else</span> {
              thenables.add(thenable);
            } <span class="hljs-comment">// If the boundary is outside of blocking mode, we should *not*</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1140" id="section-1140"></a>
</div>
<p>suspend the commit. Pretend as if the suspended component rendered
null and keep rendering. In the commit phase, we'll schedule a
subsequent synchronous update to re-render the Suspense.</p>
<p>Note: It doesn't matter whether the component that suspended was
inside a blocking mode tree. If the Suspense is outside of it, we
should <em>not</em> suspend the commit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">if</span> ((_workInProgress.mode &amp; BlockingMode) === NoMode) {
              _workInProgress.effectTag |= DidCapture; <span class="hljs-comment">// We're going to commit this fiber even though it didn't complete.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1141" id="section-1141"></a>
</div>
<p>But we shouldn't call any lifecycle methods or callbacks. Remove
all lifecycle effect tags.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              sourceFiber.effectTag &amp;= ~(LifecycleEffectMask | Incomplete);

              <span class="hljs-keyword">if</span> (sourceFiber.tag === ClassComponent) {
                <span class="hljs-keyword">var</span> currentSourceFiber = sourceFiber.alternate;

                <span class="hljs-keyword">if</span> (currentSourceFiber === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1142" id="section-1142"></a>
</div>
<p>This is a new mount. Change the tag so it's not mistaken for a
completed class component. For example, we should not call
componentWillUnmount if it is deleted.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  sourceFiber.tag = IncompleteClassComponent;
                } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1143" id="section-1143"></a>
</div>
<p>When we try rendering again, we should not reuse the current fiber,
since it's known to be in an inconsistent state. Use a force update to
prevent a bail out.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  <span class="hljs-keyword">var</span> update = createUpdate(Sync, <span class="hljs-literal">null</span>);
                  update.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update);
                }
              } <span class="hljs-comment">// The source fiber did not complete. Mark it with Sync priority to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1144" id="section-1144"></a>
</div>
<p>indicate that it still has pending work.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

              sourceFiber.expirationTime = Sync; <span class="hljs-comment">// Exit without suspending.</span>

              <span class="hljs-keyword">return</span>;
            } <span class="hljs-comment">// Confirmed that the boundary is in a concurrent mode tree. Continue</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1145" id="section-1145"></a>
</div>
<p>with the normal suspend path.</p>
<p>After this we'll use a set of heuristics to determine whether this
render pass will run to completion or restart or &quot;suspend&quot; the commit.
The actual logic for this is spread out in different places.</p>
<p>This first principle is that if we're going to suspend when we complete
a root, then we should also restart if we get an update or ping that
might unsuspend it, and vice versa. The only reason to suspend is
because you think you might want to restart before committing. However,
it doesn't make sense to restart only while in the period we're suspended.</p>
<p>Restarting too aggressively is also not good because it starves out any
intermediate loading state. So we use heuristics to determine when.
Suspense Heuristics</p>
<p>If nothing threw a Promise or all the same fallbacks are already showing,
then don't suspend/restart.</p>
<p>If this is an initial render of a new tree of Suspense boundaries and
those trigger a fallback, then don't suspend/restart. We want to ensure
that we can show the initial loading state as quickly as possible.</p>
<p>If we hit a &quot;Delayed&quot; case, such as when we'd switch from content back into
a fallback, then we should always suspend/restart. SuspenseConfig applies to
this case. If none is defined, JND is used instead.</p>
<p>If we're already showing a fallback and it gets &quot;retried&quot;, allowing us to show
another level, but there's still an inner boundary that would show a fallback,
then we suspend/restart for 500ms since the last time we showed a fallback
anywhere in the tree. This effectively throttles progressive loading into a
consistent train of commits. This also gives us an opportunity to restart to
get to the completed state slightly earlier.</p>
<p>If there's ambiguity due to batching it's resolved in preference of:</p>
<ol>
<li>&quot;delayed&quot;, 2) &quot;initial render&quot;, 3) &quot;retry&quot;.</li>
</ol>
<p>We want to ensure that a &quot;busy&quot; state doesn't get force committed. We want to
ensure that new initial loading states can commit as soon as possible.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            attachPingListener(root, renderExpirationTime, thenable);
            _workInProgress.effectTag |= ShouldCapture;
            _workInProgress.expirationTime = renderExpirationTime;
            <span class="hljs-keyword">return</span>;
          } <span class="hljs-comment">// This boundary already captured during this render. Continue to the next</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1146" id="section-1146"></a>
</div>
<p>boundary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          _workInProgress = _workInProgress.return;
        } <span class="hljs-keyword">while</span> (_workInProgress !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// No boundary was found. Fallthrough to error mode.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1147" id="section-1147"></a>
</div>
<p>TODO: Use invariant so the message is stripped in prod?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>((getComponentName(sourceFiber.type) || <span class="hljs-string">'A React component'</span>) + <span class="hljs-string">' suspended while rendering, but no fallback UI was specified.\n'</span> + <span class="hljs-string">'\n'</span> + <span class="hljs-string">'Add a &lt;Suspense fallback=...&gt; component higher in the tree to '</span> + <span class="hljs-string">'provide a loading indicator or placeholder to display.'</span> + getStackByFiberInDevAndProd(sourceFiber));
      } <span class="hljs-comment">// We didn't find a boundary that could handle this type of exception. Start</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1148" id="section-1148"></a>
</div>
<p>over and traverse parent path again, this time treating the exception
as an error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      renderDidError();
      value = createCapturedValue(value, sourceFiber);
      <span class="hljs-keyword">var</span> workInProgress = returnFiber;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">switch</span> (workInProgress.tag) {
          <span class="hljs-keyword">case</span> HostRoot:
            {
              <span class="hljs-keyword">var</span> _errorInfo = value;
              workInProgress.effectTag |= ShouldCapture;
              workInProgress.expirationTime = renderExpirationTime;

              <span class="hljs-keyword">var</span> _update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);

              enqueueCapturedUpdate(workInProgress, _update);
              <span class="hljs-keyword">return</span>;
            }

          <span class="hljs-keyword">case</span> ClassComponent:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1149" id="section-1149"></a>
</div>
<p>Capture and retry</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> errorInfo = value;
            <span class="hljs-keyword">var</span> ctor = workInProgress.type;
            <span class="hljs-keyword">var</span> instance = workInProgress.stateNode;

            <span class="hljs-keyword">if</span> ((workInProgress.effectTag &amp; DidCapture) === NoEffect &amp;&amp; (<span class="hljs-keyword">typeof</span> ctor.getDerivedStateFromError === <span class="hljs-string">'function'</span> || instance !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.componentDidCatch === <span class="hljs-string">'function'</span> &amp;&amp; !isAlreadyFailedLegacyErrorBoundary(instance))) {
              workInProgress.effectTag |= ShouldCapture;
              workInProgress.expirationTime = renderExpirationTime; <span class="hljs-comment">// Schedule the error boundary to re-render using updated state</span>

              <span class="hljs-keyword">var</span> _update2 = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);

              enqueueCapturedUpdate(workInProgress, _update2);
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">break</span>;
        }

        workInProgress = workInProgress.return;
      } <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>);
    }

    <span class="hljs-keyword">var</span> ceil = <span class="hljs-built_in">Math</span>.ceil;
    <span class="hljs-keyword">var</span> ReactCurrentDispatcher$<span class="hljs-number">1</span> = ReactSharedInternals.ReactCurrentDispatcher,
        ReactCurrentOwner$<span class="hljs-number">2</span> = ReactSharedInternals.ReactCurrentOwner,
        IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
    <span class="hljs-keyword">var</span> NoContext =
    <span class="hljs-comment">/*                    */</span>
    <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> BatchedContext =
    <span class="hljs-comment">/*               */</span>
    <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> EventContext =
    <span class="hljs-comment">/*                 */</span>
    <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> DiscreteEventContext =
    <span class="hljs-comment">/*         */</span>
    <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> LegacyUnbatchedContext =
    <span class="hljs-comment">/*       */</span>
    <span class="hljs-number">8</span>;
    <span class="hljs-keyword">var</span> RenderContext =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">16</span>;
    <span class="hljs-keyword">var</span> CommitContext =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">32</span>;
    <span class="hljs-keyword">var</span> RootIncomplete = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> RootFatalErrored = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> RootErrored = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> RootSuspended = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">var</span> RootSuspendedWithDelay = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">var</span> RootCompleted = <span class="hljs-number">5</span>; <span class="hljs-comment">// Describes where we are in the React execution stack</span>

    <span class="hljs-keyword">var</span> executionContext = NoContext; <span class="hljs-comment">// The root we're working on</span>

    <span class="hljs-keyword">var</span> workInProgressRoot = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The fiber we're working on</span>

    <span class="hljs-keyword">var</span> workInProgress = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The expiration time we're rendering</span>

    <span class="hljs-keyword">var</span> renderExpirationTime$<span class="hljs-number">1</span> = NoWork; <span class="hljs-comment">// Whether to root completed, errored, suspended, etc.</span>

    <span class="hljs-keyword">var</span> workInProgressRootExitStatus = RootIncomplete; <span class="hljs-comment">// A fatal error, if one is thrown</span>

    <span class="hljs-keyword">var</span> workInProgressRootFatalError = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Most recent event time among processed updates during this render.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1150" id="section-1150"></a>
</div>
<p>This is conceptually a time stamp but expressed in terms of an ExpirationTime
because we deal mostly with expiration times in the hot path, so this avoids
the conversion happening in the hot path.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> workInProgressRootLatestProcessedExpirationTime = Sync;
    <span class="hljs-keyword">var</span> workInProgressRootLatestSuspenseTimeout = Sync;
    <span class="hljs-keyword">var</span> workInProgressRootCanSuspendUsingConfig = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The work left over by components that were visited during this render. Only</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1151" id="section-1151"></a>
</div>
<p>includes unprocessed updates, not work in bailed out children.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> workInProgressRootNextUnprocessedUpdateTime = NoWork; <span class="hljs-comment">// If we're pinged while rendering we don't always restart immediately.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1152" id="section-1152"></a>
</div>
<p>This flag determines if it might be worthwhile to restart if an opportunity
happens latere.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> workInProgressRootHasPendingPing = <span class="hljs-literal">false</span>; <span class="hljs-comment">// The most recent time we committed a fallback. This lets us ensure a train</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1153" id="section-1153"></a>
</div>
<p>model where we don't commit new loading states in too quick succession.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> globalMostRecentFallbackTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> FALLBACK_THROTTLE_MS = <span class="hljs-number">500</span>;
    <span class="hljs-keyword">var</span> nextEffect = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> hasUncaughtError = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> firstUncaughtError = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> legacyErrorBoundariesThatAlreadyFailed = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> rootDoesHavePassiveEffects = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> rootWithPendingPassiveEffects = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> pendingPassiveEffectsRenderPriority = NoPriority;
    <span class="hljs-keyword">var</span> pendingPassiveEffectsExpirationTime = NoWork;
    <span class="hljs-keyword">var</span> rootsWithPendingDiscreteUpdates = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Use these to prevent an infinite loop of nested updates</span>

    <span class="hljs-keyword">var</span> NESTED_UPDATE_LIMIT = <span class="hljs-number">50</span>;
    <span class="hljs-keyword">var</span> nestedUpdateCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> rootWithNestedUpdates = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> NESTED_PASSIVE_UPDATE_LIMIT = <span class="hljs-number">50</span>;
    <span class="hljs-keyword">var</span> nestedPassiveUpdateCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> interruptedBy = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Marks the need to reschedule pending interactions at these expiration times</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1154" id="section-1154"></a>
</div>
<p>during the commit phase. This enables them to be traced across components
that spawn new work during render. E.g. hidden boundaries, suspended SSR
hydration or SuspenseList.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> spawnedWorkDuringRender = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Expiration times are computed by adding to the current time (the start</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1155" id="section-1155"></a>
</div>
<p>time). However, if two updates are scheduled within the same event, we
should treat their start times as simultaneous, even if the actual clock
time has advanced between the first and second call.
In other words, because expiration times determine how updates are batched,
we want all updates of like priority that occur within the same event to
receive the same expiration time. Otherwise we get tearing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> currentEventTime = NoWork;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestCurrentTimeForUpdate</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1156" id="section-1156"></a>
</div>
<p>We're inside React, so it's fine to read the actual time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> msToExpirationTime(now());
      } <span class="hljs-comment">// We're not inside React, so we may be in the middle of a browser event.</span>


      <span class="hljs-keyword">if</span> (currentEventTime !== NoWork) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1157" id="section-1157"></a>
</div>
<p>Use the same start time for all updates until we enter React again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> currentEventTime;
      } <span class="hljs-comment">// This is the first update since React yielded. Compute a new start time.</span>


      currentEventTime = msToExpirationTime(now());
      <span class="hljs-keyword">return</span> currentEventTime;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrentTime</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> msToExpirationTime(now());
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeExpirationForFiber</span>(<span class="hljs-params">currentTime, fiber, suspenseConfig</span>) </span>{
      <span class="hljs-keyword">var</span> mode = fiber.mode;

      <span class="hljs-keyword">if</span> ((mode &amp; BlockingMode) === NoMode) {
        <span class="hljs-keyword">return</span> Sync;
      }

      <span class="hljs-keyword">var</span> priorityLevel = getCurrentPriorityLevel();

      <span class="hljs-keyword">if</span> ((mode &amp; ConcurrentMode) === NoMode) {
        <span class="hljs-keyword">return</span> priorityLevel === ImmediatePriority ? Sync : Batched;
      }

      <span class="hljs-keyword">if</span> ((executionContext &amp; RenderContext) !== NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1158" id="section-1158"></a>
</div>
<p>Use whatever time we're already rendering
TODO: Should there be a way to opt out, like with <code>runWithPriority</code>?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> renderExpirationTime$<span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">var</span> expirationTime;

      <span class="hljs-keyword">if</span> (suspenseConfig !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1159" id="section-1159"></a>
</div>
<p>Compute an expiration time based on the Suspense timeout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        expirationTime = computeSuspenseExpiration(currentTime, suspenseConfig.timeoutMs | <span class="hljs-number">0</span> || LOW_PRIORITY_EXPIRATION);
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1160" id="section-1160"></a>
</div>
<p>Compute an expiration time based on the Scheduler priority.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">switch</span> (priorityLevel) {
          <span class="hljs-keyword">case</span> ImmediatePriority:
            expirationTime = Sync;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> UserBlockingPriority$<span class="hljs-number">1</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1161" id="section-1161"></a>
</div>
<p>TODO: Rename this to computeUserBlockingExpiration</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            expirationTime = computeInteractiveExpiration(currentTime);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> NormalPriority:
          <span class="hljs-keyword">case</span> LowPriority:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1162" id="section-1162"></a>
</div>
<p>TODO: Handle LowPriority
TODO: Rename this to... something better.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            expirationTime = computeAsyncExpiration(currentTime);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> IdlePriority:
            expirationTime = Idle;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
            {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expected a valid priority level"</span>);
              }
            }
        }
      } <span class="hljs-comment">// If we're in the middle of rendering a tree, do not update at the same</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1163" id="section-1163"></a>
</div>
<p>expiration time that is already rendering.
TODO: We shouldn't have to do this if the update is on a different root.
Refactor computeExpirationForFiber + scheduleUpdate so we have access to
the root when we check for this condition.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (workInProgressRoot !== <span class="hljs-literal">null</span> &amp;&amp; expirationTime === renderExpirationTime$<span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1164" id="section-1164"></a>
</div>
<p>This is a trick to move this update into a separate batch</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        expirationTime -= <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">return</span> expirationTime;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleUpdateOnFiber</span>(<span class="hljs-params">fiber, expirationTime</span>) </span>{
      checkForNestedUpdates();
      warnAboutRenderPhaseUpdatesInDEV(fiber);
      <span class="hljs-keyword">var</span> root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);

      <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
        warnAboutUpdateOnUnmountedFiberInDEV(fiber);
        <span class="hljs-keyword">return</span>;
      }

      checkForInterruption(fiber, expirationTime);
      recordScheduleUpdate(); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> computeExpirationForFiber also reads the priority. Pass the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1165" id="section-1165"></a>
</div>
<p>priority as an argument to that function and this one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> priorityLevel = getCurrentPriorityLevel();

      <span class="hljs-keyword">if</span> (expirationTime === Sync) {
        <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Check if we're inside unbatchedUpdates</span>
        (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; <span class="hljs-comment">// Check if we're not already rendering</span>
        (executionContext &amp; (RenderContext | CommitContext)) === NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1166" id="section-1166"></a>
</div>
<p>Register pending interactions on the root to avoid losing traced interaction data.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          schedulePendingInteractions(root, expirationTime); <span class="hljs-comment">// This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1167" id="section-1167"></a>
</div>
<p>root inside of batchedUpdates should be synchronous, but layout updates
should be deferred until the end of the batch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          performSyncWorkOnRoot(root);
        } <span class="hljs-keyword">else</span> {
          ensureRootIsScheduled(root);
          schedulePendingInteractions(root, expirationTime);

          <span class="hljs-keyword">if</span> (executionContext === NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1168" id="section-1168"></a>
</div>
<p>Flush the synchronous work now, unless we're already working or inside
a batch. This is intentionally inside scheduleUpdateOnFiber instead of
scheduleCallbackForFiber to preserve the ability to schedule a callback
without immediately flushing it. We only do this for user-initiated
updates, to preserve historical behavior of legacy mode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            flushSyncCallbackQueue();
          }
        }
      } <span class="hljs-keyword">else</span> {
        ensureRootIsScheduled(root);
        schedulePendingInteractions(root, expirationTime);
      }

      <span class="hljs-keyword">if</span> ((executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; ( <span class="hljs-comment">// Only updates at user-blocking priority or greater are considered</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1169" id="section-1169"></a>
</div>
<p>discrete, even inside a discrete event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      priorityLevel === UserBlockingPriority$<span class="hljs-number">1</span> || priorityLevel === ImmediatePriority)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1170" id="section-1170"></a>
</div>
<p>This is the result of a discrete event. Track the lowest priority
discrete update per root so we can flush them early, if needed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (rootsWithPendingDiscreteUpdates === <span class="hljs-literal">null</span>) {
          rootsWithPendingDiscreteUpdates = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[root, expirationTime]]);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);

          <span class="hljs-keyword">if</span> (lastDiscreteTime === <span class="hljs-literal">undefined</span> || lastDiscreteTime &gt; expirationTime) {
            rootsWithPendingDiscreteUpdates.set(root, expirationTime);
          }
        }
      }
    }

    <span class="hljs-keyword">var</span> scheduleWork = scheduleUpdateOnFiber; <span class="hljs-comment">// This is split into a separate function so we can mark a fiber with pending</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1171" id="section-1171"></a>
</div>
<p>work without treating it as a typical update that originates from an event;
e.g. retrying a Suspense boundary isn't an update, but it does schedule work
on a fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUpdateTimeFromFiberToRoot</span>(<span class="hljs-params">fiber, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1172" id="section-1172"></a>
</div>
<p>Update the source fiber's expiration time</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (fiber.expirationTime &lt; expirationTime) {
        fiber.expirationTime = expirationTime;
      }

      <span class="hljs-keyword">var</span> alternate = fiber.alternate;

      <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.expirationTime &lt; expirationTime) {
        alternate.expirationTime = expirationTime;
      } <span class="hljs-comment">// Walk the parent path to the root and update the child expiration time.</span>


      <span class="hljs-keyword">var</span> node = fiber.return;
      <span class="hljs-keyword">var</span> root = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span> &amp;&amp; fiber.tag === HostRoot) {
        root = fiber.stateNode;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
          alternate = node.alternate;

          <span class="hljs-keyword">if</span> (node.childExpirationTime &lt; expirationTime) {
            node.childExpirationTime = expirationTime;

            <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.childExpirationTime &lt; expirationTime) {
              alternate.childExpirationTime = expirationTime;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.childExpirationTime &lt; expirationTime) {
            alternate.childExpirationTime = expirationTime;
          }

          <span class="hljs-keyword">if</span> (node.return === <span class="hljs-literal">null</span> &amp;&amp; node.tag === HostRoot) {
            root = node.stateNode;
            <span class="hljs-keyword">break</span>;
          }

          node = node.return;
        }
      }

      <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (workInProgressRoot === root) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1173" id="section-1173"></a>
</div>
<p>Received an update to a tree that's in the middle of rendering. Mark
that's unprocessed work on this root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          markUnprocessedUpdateTime(expirationTime);

          <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === RootSuspendedWithDelay) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1174" id="section-1174"></a>
</div>
<p>The root already suspended with a delay, which means this render
definitely won't finish. Since we have a new update, let's mark it as
suspended now, right before marking the incoming update. This has the
effect of interrupting the current render and switching to the update.
TODO: This happens to work when receiving an update during the render
phase, because of the trick inside computeExpirationForFiber to
subtract 1 from <code>renderExpirationTime</code> to move it into a
separate bucket. But we should probably model it with an exception,
using the same mechanism we use to force hydration of a subtree.
TODO: This does not account for low pri updates that were already
scheduled before the root started rendering. Need to track the next
pending expiration time (perhaps by backtracking the return path) and
then trigger a restart in the <code>renderDidSuspendDelayIfPossible</code> path.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            markRootSuspendedAtTime(root, renderExpirationTime$<span class="hljs-number">1</span>);
          }
        } <span class="hljs-comment">// Mark that the root has a pending update.</span>


        markRootUpdatedAtTime(root, expirationTime);
      }

      <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextRootExpirationTimeToWorkOn</span>(<span class="hljs-params">root</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1175" id="section-1175"></a>
</div>
<p>Determines the next expiration time that the root should render, taking
into account levels that may be suspended, or levels that may have
received a ping.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> lastExpiredTime = root.lastExpiredTime;

      <span class="hljs-keyword">if</span> (lastExpiredTime !== NoWork) {
        <span class="hljs-keyword">return</span> lastExpiredTime;
      } <span class="hljs-comment">// "Pending" refers to any update that hasn't committed yet, including if it</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1176" id="section-1176"></a>
</div>
<p>suspended. The &quot;suspended&quot; range is therefore a subset.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> firstPendingTime = root.firstPendingTime;

      <span class="hljs-keyword">if</span> (!isRootSuspendedAtTime(root, firstPendingTime)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1177" id="section-1177"></a>
</div>
<p>The highest priority pending time is not suspended. Let's work on that.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> firstPendingTime;
      } <span class="hljs-comment">// If the first pending time is suspended, check if there's a lower priority</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1178" id="section-1178"></a>
</div>
<p>pending level that we know about. Or check if we received a ping. Work
on whichever is higher priority.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> lastPingedTime = root.lastPingedTime;
      <span class="hljs-keyword">var</span> nextKnownPendingLevel = root.nextKnownPendingLevel;
      <span class="hljs-keyword">var</span> nextLevel = lastPingedTime &gt; nextKnownPendingLevel ? lastPingedTime : nextKnownPendingLevel;

      <span class="hljs-keyword">if</span> (nextLevel &lt;= Idle &amp;&amp; firstPendingTime !== nextLevel) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1179" id="section-1179"></a>
</div>
<p>Don't work on Idle/Never priority unless everything else is committed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> NoWork;
      }

      <span class="hljs-keyword">return</span> nextLevel;
    } <span class="hljs-comment">// Use this function to schedule a task for a root. There's only one task per</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1180" id="section-1180"></a>
</div>
<p>root; if a task was already scheduled, we'll check to make sure the
expiration time of the existing task is the same as the expiration time of
the next level that the root has work on. This function is called on every
update, and right before exiting a task.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureRootIsScheduled</span>(<span class="hljs-params">root</span>) </span>{
      <span class="hljs-keyword">var</span> lastExpiredTime = root.lastExpiredTime;

      <span class="hljs-keyword">if</span> (lastExpiredTime !== NoWork) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1181" id="section-1181"></a>
</div>
<p>Special case: Expired work should flush synchronously.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root.callbackExpirationTime = Sync;
        root.callbackPriority = ImmediatePriority;
        root.callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(<span class="hljs-literal">null</span>, root));
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> expirationTime = getNextRootExpirationTimeToWorkOn(root);
      <span class="hljs-keyword">var</span> existingCallbackNode = root.callbackNode;

      <span class="hljs-keyword">if</span> (expirationTime === NoWork) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1182" id="section-1182"></a>
</div>
<p>There's nothing to work on.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) {
          root.callbackNode = <span class="hljs-literal">null</span>;
          root.callbackExpirationTime = NoWork;
          root.callbackPriority = NoPriority;
        }

        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If this is an update, we already read the current time. Pass the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1183" id="section-1183"></a>
</div>
<p>time as an argument.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> currentTime = requestCurrentTimeForUpdate();
      <span class="hljs-keyword">var</span> priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime); <span class="hljs-comment">// If there's an existing render task, confirm it has the correct priority and</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1184" id="section-1184"></a>
</div>
<p>expiration time. Otherwise, we'll cancel it and schedule a new one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> existingCallbackPriority = root.callbackPriority;
        <span class="hljs-keyword">var</span> existingCallbackExpirationTime = root.callbackExpirationTime;

        <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Callback must have the exact same expiration time.</span>
        existingCallbackExpirationTime === expirationTime &amp;&amp; <span class="hljs-comment">// Callback must have greater or equal priority.</span>
        existingCallbackPriority &gt;= priorityLevel) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1185" id="section-1185"></a>
</div>
<p>Existing callback is sufficient.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// Need to schedule a new task.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1186" id="section-1186"></a>
</div>
<p>TODO: Instead of scheduling a new task, we should be able to change the
priority of the existing one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        cancelCallback(existingCallbackNode);
      }

      root.callbackExpirationTime = expirationTime;
      root.callbackPriority = priorityLevel;
      <span class="hljs-keyword">var</span> callbackNode;

      <span class="hljs-keyword">if</span> (expirationTime === Sync) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1187" id="section-1187"></a>
</div>
<p>Sync React callbacks are scheduled on a special internal queue</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(<span class="hljs-literal">null</span>, root));
      } <span class="hljs-keyword">else</span> {
        callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(<span class="hljs-literal">null</span>, root), <span class="hljs-comment">// Compute a task timeout based on the expiration time. This also affects</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1188" id="section-1188"></a>
</div>
<p>ordering because tasks are processed in timeout order.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        {
          <span class="hljs-attr">timeout</span>: expirationTimeToMs(expirationTime) - now()
        });
      }

      root.callbackNode = callbackNode;
    } <span class="hljs-comment">// This is the entry point for every concurrent task, i.e. anything that</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1189" id="section-1189"></a>
</div>
<p>goes through Scheduler.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performConcurrentWorkOnRoot</span>(<span class="hljs-params">root, didTimeout</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1190" id="section-1190"></a>
</div>
<p>Since we know we're in a React event, we can clear the current
event time. The next update will compute a new event time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      currentEventTime = NoWork;

      <span class="hljs-keyword">if</span> (didTimeout) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1191" id="section-1191"></a>
</div>
<p>The render task took too long to complete. Mark the current time as
expired to synchronously render all expired work in a single batch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> currentTime = requestCurrentTimeForUpdate();
        markRootExpiredAtTime(root, currentTime); <span class="hljs-comment">// This will schedule a synchronous callback.</span>

        ensureRootIsScheduled(root);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// Determine the next expiration time to work on, using the fields stored</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1192" id="section-1192"></a>
</div>
<p>on the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> expirationTime = getNextRootExpirationTimeToWorkOn(root);

      <span class="hljs-keyword">if</span> (expirationTime !== NoWork) {
        <span class="hljs-keyword">var</span> originalCallbackNode = root.callbackNode;

        <span class="hljs-keyword">if</span> (!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should not already be working."</span>);
          }
        }

        flushPassiveEffects(); <span class="hljs-comment">// If the root or expiration time have changed, throw out the existing stack</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1193" id="section-1193"></a>
</div>
<p>and prepare a fresh one. Otherwise we'll continue where we left off.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">if</span> (root !== workInProgressRoot || expirationTime !== renderExpirationTime$<span class="hljs-number">1</span>) {
          prepareFreshStack(root, expirationTime);
          startWorkOnPendingInteractions(root, expirationTime);
        } <span class="hljs-comment">// If we have a work-in-progress fiber, it means there's still work to do</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1194" id="section-1194"></a>
</div>
<p>in this root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          <span class="hljs-keyword">var</span> prevDispatcher = pushDispatcher();
          <span class="hljs-keyword">var</span> prevInteractions = pushInteractions(root);
          startWorkLoopTimer(workInProgress);

          <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">try</span> {
              workLoopConcurrent();
              <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">catch</span> (thrownValue) {
              handleError(root, thrownValue);
            }
          } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);

          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          {
            popInteractions(prevInteractions);
          }

          <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === RootFatalErrored) {
            <span class="hljs-keyword">var</span> fatalError = workInProgressRootFatalError;
            stopInterruptedWorkLoopTimer();
            prepareFreshStack(root, expirationTime);
            markRootSuspendedAtTime(root, expirationTime);
            ensureRootIsScheduled(root);
            <span class="hljs-keyword">throw</span> fatalError;
          }

          <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1195" id="section-1195"></a>
</div>
<p>There's still work left over. Exit without committing.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            stopInterruptedWorkLoopTimer();
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1196" id="section-1196"></a>
</div>
<p>We now have a consistent tree. The next step is either to commit it,
or, if something suspended, wait to commit it after a timeout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            stopFinishedWorkLoopTimer();
            <span class="hljs-keyword">var</span> finishedWork = root.finishedWork = root.current.alternate;
            root.finishedExpirationTime = expirationTime;
            finishConcurrentRender(root, finishedWork, workInProgressRootExitStatus, expirationTime);
          }

          ensureRootIsScheduled(root);

          <span class="hljs-keyword">if</span> (root.callbackNode === originalCallbackNode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1197" id="section-1197"></a>
</div>
<p>The task node scheduled for this root is the same one that's
currently executed. Need to return a continuation.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="hljs-literal">null</span>, root);
          }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishConcurrentRender</span>(<span class="hljs-params">root, finishedWork, exitStatus, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1198" id="section-1198"></a>
</div>
<p>Set this to null to indicate there's no in-progress render.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      workInProgressRoot = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">switch</span> (exitStatus) {
        <span class="hljs-keyword">case</span> RootIncomplete:
        <span class="hljs-keyword">case</span> RootFatalErrored:
          {
            {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Root did not complete. This is a bug in React."</span>);
              }
            }
          }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1199" id="section-1199"></a>
</div>
<p>Flow knows about invariant, so it complains if I add a break
statement, but eslint doesn't know about invariant, so it complains
if I do. eslint-disable-next-line no-fallthrough</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">case</span> RootErrored:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1200" id="section-1200"></a>
</div>
<p>If this was an async render, the error may have happened due to
a mutation in a concurrent event. Try rendering one more time,
synchronously, to see if the error goes away. If there are
lower priority updates, let's include those, too, in case they
fix the inconsistency. Render at Idle to include all updates.
If it was Idle or Never or some not-yet-invented time, render
at that time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            markRootExpiredAtTime(root, expirationTime &gt; Idle ? Idle : expirationTime); <span class="hljs-comment">// We assume that this second render pass will be synchronous</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1201" id="section-1201"></a>
</div>
<p>and therefore not hit this path again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> RootSuspended:
          {
            markRootSuspendedAtTime(root, expirationTime);
            <span class="hljs-keyword">var</span> lastSuspendedTime = root.lastSuspendedTime;

            <span class="hljs-keyword">if</span> (expirationTime === lastSuspendedTime) {
              root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
            } <span class="hljs-comment">// We have an acceptable loading state. We need to figure out if we</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1202" id="section-1202"></a>
</div>
<p>should immediately commit it or wait a bit.
If we have processed new updates during this render, we may now
have a new loading state ready. We want to ensure that we commit
that as soon as possible.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">var</span> hasNotProcessedNewUpdates = workInProgressRootLatestProcessedExpirationTime === Sync;

            <span class="hljs-keyword">if</span> (hasNotProcessedNewUpdates &amp;&amp; <span class="hljs-comment">// do not delay if we're inside an act() scope</span>
            !IsThisRendererActing.current) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1203" id="section-1203"></a>
</div>
<p>If we have not processed any new updates during this pass, then
this is either a retry of an existing fallback state or a
hidden tree. Hidden trees shouldn't be batched with other work
and after that's fixed it can only be a retry. We're going to
throttle committing retries so that we don't show too many
loading states too quickly.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); <span class="hljs-comment">// Don't bother with a very short suspense time.</span>

              <span class="hljs-keyword">if</span> (msUntilTimeout &gt; <span class="hljs-number">10</span>) {
                <span class="hljs-keyword">if</span> (workInProgressRootHasPendingPing) {
                  <span class="hljs-keyword">var</span> lastPingedTime = root.lastPingedTime;

                  <span class="hljs-keyword">if</span> (lastPingedTime === NoWork || lastPingedTime &gt;= expirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1204" id="section-1204"></a>
</div>
<p>This render was pinged but we didn't get to restart
earlier so try restarting now instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    root.lastPingedTime = expirationTime;
                    prepareFreshStack(root, expirationTime);
                    <span class="hljs-keyword">break</span>;
                  }
                }

                <span class="hljs-keyword">var</span> nextTime = getNextRootExpirationTimeToWorkOn(root);

                <span class="hljs-keyword">if</span> (nextTime !== NoWork &amp;&amp; nextTime !== expirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1205" id="section-1205"></a>
</div>
<p>There's additional work on this root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  <span class="hljs-keyword">break</span>;
                }

                <span class="hljs-keyword">if</span> (lastSuspendedTime !== NoWork &amp;&amp; lastSuspendedTime !== expirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1206" id="section-1206"></a>
</div>
<p>We should prefer to render the fallback of at the last
suspended level. Ping the last suspended level to try
rendering it again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  root.lastPingedTime = lastSuspendedTime;
                  <span class="hljs-keyword">break</span>;
                } <span class="hljs-comment">// The render is suspended, it hasn't timed out, and there's no</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1207" id="section-1207"></a>
</div>
<p>lower priority work to do. Instead of committing the fallback
immediately, wait for more data to arrive.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

                root.timeoutHandle = scheduleTimeout(commitRoot.bind(<span class="hljs-literal">null</span>, root), msUntilTimeout);
                <span class="hljs-keyword">break</span>;
              }
            } <span class="hljs-comment">// The work expired. Commit immediately.</span>


            commitRoot(root);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> RootSuspendedWithDelay:
          {
            markRootSuspendedAtTime(root, expirationTime);
            <span class="hljs-keyword">var</span> _lastSuspendedTime = root.lastSuspendedTime;

            <span class="hljs-keyword">if</span> (expirationTime === _lastSuspendedTime) {
              root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
            }

            <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// do not delay if we're inside an act() scope</span>
            !IsThisRendererActing.current) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1208" id="section-1208"></a>
</div>
<p>We're suspended in a state that should be avoided. We'll try to
avoid committing it for as long as the timeouts let us.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">if</span> (workInProgressRootHasPendingPing) {
                <span class="hljs-keyword">var</span> _lastPingedTime = root.lastPingedTime;

                <span class="hljs-keyword">if</span> (_lastPingedTime === NoWork || _lastPingedTime &gt;= expirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1209" id="section-1209"></a>
</div>
<p>This render was pinged but we didn't get to restart earlier
so try restarting now instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  root.lastPingedTime = expirationTime;
                  prepareFreshStack(root, expirationTime);
                  <span class="hljs-keyword">break</span>;
                }
              }

              <span class="hljs-keyword">var</span> _nextTime = getNextRootExpirationTimeToWorkOn(root);

              <span class="hljs-keyword">if</span> (_nextTime !== NoWork &amp;&amp; _nextTime !== expirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1210" id="section-1210"></a>
</div>
<p>There's additional work on this root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">if</span> (_lastSuspendedTime !== NoWork &amp;&amp; _lastSuspendedTime !== expirationTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1211" id="section-1211"></a>
</div>
<p>We should prefer to render the fallback of at the last
suspended level. Ping the last suspended level to try
rendering it again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                root.lastPingedTime = _lastSuspendedTime;
                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">var</span> _msUntilTimeout;

              <span class="hljs-keyword">if</span> (workInProgressRootLatestSuspenseTimeout !== Sync) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1212" id="section-1212"></a>
</div>
<p>We have processed a suspense config whose expiration time we
can use as the timeout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                _msUntilTimeout = expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workInProgressRootLatestProcessedExpirationTime === Sync) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1213" id="section-1213"></a>
</div>
<p>This should never normally happen because only new updates
cause delayed states, so we should have processed something.
However, this could also happen in an offscreen tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                _msUntilTimeout = <span class="hljs-number">0</span>;
              } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1214" id="section-1214"></a>
</div>
<p>If we don't have a suspense config, we're going to use a
heuristic to determine how long we can suspend.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                <span class="hljs-keyword">var</span> eventTimeMs = inferTimeFromExpirationTime(workInProgressRootLatestProcessedExpirationTime);
                <span class="hljs-keyword">var</span> currentTimeMs = now();
                <span class="hljs-keyword">var</span> timeUntilExpirationMs = expirationTimeToMs(expirationTime) - currentTimeMs;
                <span class="hljs-keyword">var</span> timeElapsed = currentTimeMs - eventTimeMs;

                <span class="hljs-keyword">if</span> (timeElapsed &lt; <span class="hljs-number">0</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1215" id="section-1215"></a>
</div>
<p>We get this wrong some time since we estimate the time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  timeElapsed = <span class="hljs-number">0</span>;
                }

                _msUntilTimeout = jnd(timeElapsed) - timeElapsed; <span class="hljs-comment">// Clamp the timeout to the expiration time. <span class="hljs-doctag">TODO:</span> Once the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1216" id="section-1216"></a>
</div>
<p>event time is exact instead of inferred from expiration time
we don't need this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
                <span class="hljs-keyword">if</span> (timeUntilExpirationMs &lt; _msUntilTimeout) {
                  _msUntilTimeout = timeUntilExpirationMs;
                }
              } <span class="hljs-comment">// Don't bother with a very short suspense time.</span>


              <span class="hljs-keyword">if</span> (_msUntilTimeout &gt; <span class="hljs-number">10</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1217" id="section-1217"></a>
</div>
<p>The render is suspended, it hasn't timed out, and there's no
lower priority work to do. Instead of committing the fallback
immediately, wait for more data to arrive.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                root.timeoutHandle = scheduleTimeout(commitRoot.bind(<span class="hljs-literal">null</span>, root), _msUntilTimeout);
                <span class="hljs-keyword">break</span>;
              }
            } <span class="hljs-comment">// The work expired. Commit immediately.</span>


            commitRoot(root);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> RootCompleted:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1218" id="section-1218"></a>
</div>
<p>The work completed. Ready to commit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// do not delay if we're inside an act() scope</span>
            !IsThisRendererActing.current &amp;&amp; workInProgressRootLatestProcessedExpirationTime !== Sync &amp;&amp; workInProgressRootCanSuspendUsingConfig !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1219" id="section-1219"></a>
</div>
<p>If we have exceeded the minimum loading delay, which probably
means we have shown a spinner already, we might have to suspend
a bit longer to ensure that the spinner is shown for
enough time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">var</span> _msUntilTimeout2 = computeMsUntilSuspenseLoadingDelay(workInProgressRootLatestProcessedExpirationTime, expirationTime, workInProgressRootCanSuspendUsingConfig);

              <span class="hljs-keyword">if</span> (_msUntilTimeout2 &gt; <span class="hljs-number">10</span>) {
                markRootSuspendedAtTime(root, expirationTime);
                root.timeoutHandle = scheduleTimeout(commitRoot.bind(<span class="hljs-literal">null</span>, root), _msUntilTimeout2);
                <span class="hljs-keyword">break</span>;
              }
            }

            commitRoot(root);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-attr">default</span>:
          {
            {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unknown root exit status."</span>);
              }
            }
          }
      }
    } <span class="hljs-comment">// This is the entry point for synchronous tasks that don't go</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1220" id="section-1220"></a>
</div>
<p>through Scheduler</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performSyncWorkOnRoot</span>(<span class="hljs-params">root</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1221" id="section-1221"></a>
</div>
<p>Check if there's expired work on this root. Otherwise, render at Sync.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> lastExpiredTime = root.lastExpiredTime;
      <span class="hljs-keyword">var</span> expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;

      <span class="hljs-keyword">if</span> (!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should not already be working."</span>);
        }
      }

      flushPassiveEffects(); <span class="hljs-comment">// If the root or expiration time have changed, throw out the existing stack</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1222" id="section-1222"></a>
</div>
<p>and prepare a fresh one. Otherwise we'll continue where we left off.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (root !== workInProgressRoot || expirationTime !== renderExpirationTime$<span class="hljs-number">1</span>) {
        prepareFreshStack(root, expirationTime);
        startWorkOnPendingInteractions(root, expirationTime);
      } <span class="hljs-comment">// If we have a work-in-progress fiber, it means there's still work to do</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1223" id="section-1223"></a>
</div>
<p>in this root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        <span class="hljs-keyword">var</span> prevDispatcher = pushDispatcher();
        <span class="hljs-keyword">var</span> prevInteractions = pushInteractions(root);
        startWorkLoopTimer(workInProgress);

        <span class="hljs-keyword">do</span> {
          <span class="hljs-keyword">try</span> {
            workLoopSync();
            <span class="hljs-keyword">break</span>;
          } <span class="hljs-keyword">catch</span> (thrownValue) {
            handleError(root, thrownValue);
          }
        } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);

        resetContextDependencies();
        executionContext = prevExecutionContext;
        popDispatcher(prevDispatcher);
        {
          popInteractions(prevInteractions);
        }

        <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === RootFatalErrored) {
          <span class="hljs-keyword">var</span> fatalError = workInProgressRootFatalError;
          stopInterruptedWorkLoopTimer();
          prepareFreshStack(root, expirationTime);
          markRootSuspendedAtTime(root, expirationTime);
          ensureRootIsScheduled(root);
          <span class="hljs-keyword">throw</span> fatalError;
        }

        <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1224" id="section-1224"></a>
</div>
<p>This is a sync render, so we should have finished the whole tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."</span>);
            }
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1225" id="section-1225"></a>
</div>
<p>We now have a consistent tree. Because this is a sync render, we
will commit it even if something suspended.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          stopFinishedWorkLoopTimer();
          root.finishedWork = root.current.alternate;
          root.finishedExpirationTime = expirationTime;
          finishSyncRender(root);
        } <span class="hljs-comment">// Before exiting, make sure there's a callback scheduled for the next</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1226" id="section-1226"></a>
</div>
<p>pending level.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        ensureRootIsScheduled(root);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishSyncRender</span>(<span class="hljs-params">root</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1227" id="section-1227"></a>
</div>
<p>Set this to null to indicate there's no in-progress render.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      workInProgressRoot = <span class="hljs-literal">null</span>;
      commitRoot(root);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushDiscreteUpdates</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1228" id="section-1228"></a>
</div>
<p>TODO: Should be able to flush inside batchedUpdates, but not inside <code>act</code>.
However, <code>act</code> uses <code>batchedUpdates</code>, so there's no way to distinguish
those two cases. Need to fix this before exposing flushDiscreteUpdates
as a public API.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> ((executionContext &amp; (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
        {
          <span class="hljs-keyword">if</span> ((executionContext &amp; RenderContext) !== NoContext) {
            error(<span class="hljs-string">'unstable_flushDiscreteUpdates: Cannot flush updates when React is '</span> + <span class="hljs-string">'already rendering.'</span>);
          }
        } <span class="hljs-comment">// We're already rendering, so we can't synchronously flush pending work.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1229" id="section-1229"></a>
</div>
<p>This is probably a nested event dispatch triggered by a lifecycle/effect,
like <code>el.focus()</code>. Exit.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">return</span>;
      }

      flushPendingDiscreteUpdates(); <span class="hljs-comment">// If the discrete updates scheduled passive effects, flush them now so that</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1230" id="section-1230"></a>
</div>
<p>they fire before the next serial event.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      flushPassiveEffects();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syncUpdates</span>(<span class="hljs-params">fn, a, b, c</span>) </span>{
      <span class="hljs-keyword">return</span> runWithPriority$<span class="hljs-number">1</span>(ImmediatePriority, fn.bind(<span class="hljs-literal">null</span>, a, b, c));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushPendingDiscreteUpdates</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (rootsWithPendingDiscreteUpdates !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1231" id="section-1231"></a>
</div>
<p>For each root with pending discrete updates, schedule a callback to
immediately flush them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> roots = rootsWithPendingDiscreteUpdates;
        rootsWithPendingDiscreteUpdates = <span class="hljs-literal">null</span>;
        roots.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expirationTime, root</span>) </span>{
          markRootExpiredAtTime(root, expirationTime);
          ensureRootIsScheduled(root);
        }); <span class="hljs-comment">// Now flush the immediate queue.</span>

        flushSyncCallbackQueue();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">batchedUpdates$1</span>(<span class="hljs-params">fn, a</span>) </span>{
      <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
      executionContext |= BatchedContext;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> fn(a);
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext;

        <span class="hljs-keyword">if</span> (executionContext === NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1232" id="section-1232"></a>
</div>
<p>Flush the immediate callbacks that were scheduled during this batch</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          flushSyncCallbackQueue();
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">batchedEventUpdates$1</span>(<span class="hljs-params">fn, a</span>) </span>{
      <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
      executionContext |= EventContext;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> fn(a);
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext;

        <span class="hljs-keyword">if</span> (executionContext === NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1233" id="section-1233"></a>
</div>
<p>Flush the immediate callbacks that were scheduled during this batch</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          flushSyncCallbackQueue();
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">discreteUpdates$1</span>(<span class="hljs-params">fn, a, b, c, d</span>) </span>{
      <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
      executionContext |= DiscreteEventContext;

      <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1234" id="section-1234"></a>
</div>
<p>Should this</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> runWithPriority$<span class="hljs-number">1</span>(UserBlockingPriority$<span class="hljs-number">1</span>, fn.bind(<span class="hljs-literal">null</span>, a, b, c, d));
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext;

        <span class="hljs-keyword">if</span> (executionContext === NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1235" id="section-1235"></a>
</div>
<p>Flush the immediate callbacks that were scheduled during this batch</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          flushSyncCallbackQueue();
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unbatchedUpdates</span>(<span class="hljs-params">fn, a</span>) </span>{
      <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
      executionContext &amp;= ~BatchedContext;
      executionContext |= LegacyUnbatchedContext;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> fn(a);
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext;

        <span class="hljs-keyword">if</span> (executionContext === NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1236" id="section-1236"></a>
</div>
<p>Flush the immediate callbacks that were scheduled during this batch</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          flushSyncCallbackQueue();
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSync</span>(<span class="hljs-params">fn, a</span>) </span>{
      <span class="hljs-keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering."</span>);
          }
        }
      }

      <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
      executionContext |= BatchedContext;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> runWithPriority$<span class="hljs-number">1</span>(ImmediatePriority, fn.bind(<span class="hljs-literal">null</span>, a));
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext; <span class="hljs-comment">// Flush the immediate callbacks that were scheduled during this batch.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1237" id="section-1237"></a>
</div>
<p>Note that this will happen even if batchedUpdates is higher up
the stack.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        flushSyncCallbackQueue();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareFreshStack</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
      root.finishedWork = <span class="hljs-literal">null</span>;
      root.finishedExpirationTime = NoWork;
      <span class="hljs-keyword">var</span> timeoutHandle = root.timeoutHandle;

      <span class="hljs-keyword">if</span> (timeoutHandle !== noTimeout) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1238" id="section-1238"></a>
</div>
<p>The root previous suspended and scheduled a timeout to commit a fallback
state. Now that we have additional work, cancel the timeout.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root.timeoutHandle = noTimeout; <span class="hljs-comment">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span>

        cancelTimeout(timeoutHandle);
      }

      <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> interruptedWork = workInProgress.return;

        <span class="hljs-keyword">while</span> (interruptedWork !== <span class="hljs-literal">null</span>) {
          unwindInterruptedWork(interruptedWork);
          interruptedWork = interruptedWork.return;
        }
      }

      workInProgressRoot = root;
      workInProgress = createWorkInProgress(root.current, <span class="hljs-literal">null</span>);
      renderExpirationTime$<span class="hljs-number">1</span> = expirationTime;
      workInProgressRootExitStatus = RootIncomplete;
      workInProgressRootFatalError = <span class="hljs-literal">null</span>;
      workInProgressRootLatestProcessedExpirationTime = Sync;
      workInProgressRootLatestSuspenseTimeout = Sync;
      workInProgressRootCanSuspendUsingConfig = <span class="hljs-literal">null</span>;
      workInProgressRootNextUnprocessedUpdateTime = NoWork;
      workInProgressRootHasPendingPing = <span class="hljs-literal">false</span>;
      {
        spawnedWorkDuringRender = <span class="hljs-literal">null</span>;
      }
      {
        ReactStrictModeWarnings.discardPendingWarnings();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleError</span>(<span class="hljs-params">root, thrownValue</span>) </span>{
      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1239" id="section-1239"></a>
</div>
<p>Reset module-level state that was set during the render phase.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          resetContextDependencies();
          resetHooksAfterThrow();
          resetCurrentFiber();

          <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-literal">null</span> || workInProgress.return === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1240" id="section-1240"></a>
</div>
<p>Expected to be working on a non-root fiber. This is a fatal error
because there's no ancestor that can handle it; the root is
supposed to capture all errors that weren't caught by an error
boundary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            workInProgressRootExitStatus = RootFatalErrored;
            workInProgressRootFatalError = thrownValue; <span class="hljs-comment">// Set `workInProgress` to null. This represents advancing to the next</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1241" id="section-1241"></a>
</div>
<p>sibling, or the parent if there are no siblings. But since the root
has no siblings nor a parent, we set it to null. Usually this is
handled by <code>completeUnitOfWork</code> or <code>unwindWork</code>, but since we're
interntionally not calling those, we need set it here.
TODO: Consider calling <code>unwindWork</code> to pop the contexts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            workInProgress = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">if</span> (enableProfilerTimer &amp;&amp; workInProgress.mode &amp; ProfileMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1242" id="section-1242"></a>
</div>
<p>Record the time spent rendering before an error was thrown. This
avoids inaccurate Profiler durations in the case of a
suspended render.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, <span class="hljs-literal">true</span>);
          }

          throwException(root, workInProgress.return, workInProgress, thrownValue, renderExpirationTime$<span class="hljs-number">1</span>);
          workInProgress = completeUnitOfWork(workInProgress);
        } <span class="hljs-keyword">catch</span> (yetAnotherThrownValue) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1243" id="section-1243"></a>
</div>
<p>Something in the return path also threw.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          thrownValue = yetAnotherThrownValue;
          <span class="hljs-keyword">continue</span>;
        } <span class="hljs-comment">// Return to the normal work loop.</span>


        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushDispatcher</span>(<span class="hljs-params">root</span>) </span>{
      <span class="hljs-keyword">var</span> prevDispatcher = ReactCurrentDispatcher$<span class="hljs-number">1.</span>current;
      ReactCurrentDispatcher$<span class="hljs-number">1.</span>current = ContextOnlyDispatcher;

      <span class="hljs-keyword">if</span> (prevDispatcher === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1244" id="section-1244"></a>
</div>
<p>The React isomorphic package does not include a default dispatcher.
Instead the first renderer will lazily attach one, in order to give
nicer error messages.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> ContextOnlyDispatcher;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> prevDispatcher;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popDispatcher</span>(<span class="hljs-params">prevDispatcher</span>) </span>{
      ReactCurrentDispatcher$<span class="hljs-number">1.</span>current = prevDispatcher;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushInteractions</span>(<span class="hljs-params">root</span>) </span>{
      {
        <span class="hljs-keyword">var</span> prevInteractions = tracing.__interactionsRef.current;
        tracing.__interactionsRef.current = root.memoizedInteractions;
        <span class="hljs-keyword">return</span> prevInteractions;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popInteractions</span>(<span class="hljs-params">prevInteractions</span>) </span>{
      {
        tracing.__interactionsRef.current = prevInteractions;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markCommitTimeOfFallback</span>(<span class="hljs-params"></span>) </span>{
      globalMostRecentFallbackTime = now();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRenderEventTimeAndConfig</span>(<span class="hljs-params">expirationTime, suspenseConfig</span>) </span>{
      <span class="hljs-keyword">if</span> (expirationTime &lt; workInProgressRootLatestProcessedExpirationTime &amp;&amp; expirationTime &gt; Idle) {
        workInProgressRootLatestProcessedExpirationTime = expirationTime;
      }

      <span class="hljs-keyword">if</span> (suspenseConfig !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (expirationTime &lt; workInProgressRootLatestSuspenseTimeout &amp;&amp; expirationTime &gt; Idle) {
          workInProgressRootLatestSuspenseTimeout = expirationTime; <span class="hljs-comment">// Most of the time we only have one config and getting wrong is not bad.</span>

          workInProgressRootCanSuspendUsingConfig = suspenseConfig;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUnprocessedUpdateTime</span>(<span class="hljs-params">expirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (expirationTime &gt; workInProgressRootNextUnprocessedUpdateTime) {
        workInProgressRootNextUnprocessedUpdateTime = expirationTime;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderDidSuspend</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === RootIncomplete) {
        workInProgressRootExitStatus = RootSuspended;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderDidSuspendDelayIfPossible</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
        workInProgressRootExitStatus = RootSuspendedWithDelay;
      } <span class="hljs-comment">// Check if there's a lower priority update somewhere else in the tree.</span>


      <span class="hljs-keyword">if</span> (workInProgressRootNextUnprocessedUpdateTime !== NoWork &amp;&amp; workInProgressRoot !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1245" id="section-1245"></a>
</div>
<p>Mark the current render as suspended, and then mark that there's a
pending update.
TODO: This should immediately interrupt the current render, instead
of waiting until the next time we yield.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime$<span class="hljs-number">1</span>);
        markRootUpdatedAtTime(workInProgressRoot, workInProgressRootNextUnprocessedUpdateTime);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderDidError</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus !== RootCompleted) {
        workInProgressRootExitStatus = RootErrored;
      }
    } <span class="hljs-comment">// Called during render to determine if anything has suspended.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1246" id="section-1246"></a>
</div>
<p>Returns false if we're not sure.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderHasNotSuspendedYet</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1247" id="section-1247"></a>
</div>
<p>If something errored or completed, we can't really be sure,
so those are false.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> workInProgressRootExitStatus === RootIncomplete;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferTimeFromExpirationTime</span>(<span class="hljs-params">expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1248" id="section-1248"></a>
</div>
<p>We don't know exactly when the update was scheduled, but we can infer an
approximate start time from the expiration time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
      <span class="hljs-keyword">return</span> earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferTimeFromExpirationTimeWithSuspenseConfig</span>(<span class="hljs-params">expirationTime, suspenseConfig</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1249" id="section-1249"></a>
</div>
<p>We don't know exactly when the update was scheduled, but we can infer an
approximate start time from the expiration time by subtracting the timeout
that was added to the event time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
      <span class="hljs-keyword">return</span> earliestExpirationTimeMs - (suspenseConfig.timeoutMs | <span class="hljs-number">0</span> || LOW_PRIORITY_EXPIRATION);
    } <span class="hljs-comment">// The work loop is an extremely hot path. Tell Closure not to inline it.</span>

    <span class="hljs-comment">/** <span class="hljs-doctag">@noinline </span>*/</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoopSync</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1250" id="section-1250"></a>
</div>
<p>Already timed out, so perform work without checking if we need to yield.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>) {
        workInProgress = performUnitOfWork(workInProgress);
      }
    }
    <span class="hljs-comment">/** <span class="hljs-doctag">@noinline </span>*/</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workLoopConcurrent</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1251" id="section-1251"></a>
</div>
<p>Perform work until Scheduler asks us to yield</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !shouldYield()) {
        workInProgress = performUnitOfWork(workInProgress);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1252" id="section-1252"></a>
</div>
<p>The current, flushed, state of this fiber is the alternate. Ideally
nothing should rely on this, but relying on it here means that we don't
need an additional field on the work in progress.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> current = unitOfWork.alternate;
      startWorkTimer(unitOfWork);
      setCurrentFiber(unitOfWork);
      <span class="hljs-keyword">var</span> next;

      <span class="hljs-keyword">if</span> ((unitOfWork.mode &amp; ProfileMode) !== NoMode) {
        startProfilerTimer(unitOfWork);
        next = beginWork$<span class="hljs-number">1</span>(current, unitOfWork, renderExpirationTime$<span class="hljs-number">1</span>);
        stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> {
        next = beginWork$<span class="hljs-number">1</span>(current, unitOfWork, renderExpirationTime$<span class="hljs-number">1</span>);
      }

      resetCurrentFiber();
      unitOfWork.memoizedProps = unitOfWork.pendingProps;

      <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1253" id="section-1253"></a>
</div>
<p>If this doesn't spawn new work, complete the current work.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        next = completeUnitOfWork(unitOfWork);
      }

      ReactCurrentOwner$<span class="hljs-number">2.</span>current = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> next;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1254" id="section-1254"></a>
</div>
<p>Attempt to complete the current unit of work, then move to the next
sibling. If there are no more siblings, return to the parent fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      workInProgress = unitOfWork;

      <span class="hljs-keyword">do</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1255" id="section-1255"></a>
</div>
<p>The current, flushed, state of this fiber is the alternate. Ideally
nothing should rely on this, but relying on it here means that we don't
need an additional field on the work in progress.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> current = workInProgress.alternate;
        <span class="hljs-keyword">var</span> returnFiber = workInProgress.return; <span class="hljs-comment">// Check if the work completed or if something threw.</span>

        <span class="hljs-keyword">if</span> ((workInProgress.effectTag &amp; Incomplete) === NoEffect) {
          setCurrentFiber(workInProgress);
          <span class="hljs-keyword">var</span> next = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

          <span class="hljs-keyword">if</span> ((workInProgress.mode &amp; ProfileMode) === NoMode) {
            next = completeWork(current, workInProgress, renderExpirationTime$<span class="hljs-number">1</span>);
          } <span class="hljs-keyword">else</span> {
            startProfilerTimer(workInProgress);
            next = completeWork(current, workInProgress, renderExpirationTime$<span class="hljs-number">1</span>); <span class="hljs-comment">// Update render duration assuming we didn't error.</span>

            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, <span class="hljs-literal">false</span>);
          }

          stopWorkTimer(workInProgress);
          resetCurrentFiber();
          resetChildExpirationTime(workInProgress);

          <span class="hljs-keyword">if</span> (next !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1256" id="section-1256"></a>
</div>
<p>Completing this fiber spawned new work. Work on that next.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> next;
          }

          <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-comment">// Do not append effects to parents if a sibling failed to complete</span>
          (returnFiber.effectTag &amp; Incomplete) === NoEffect) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1257" id="section-1257"></a>
</div>
<p>Append all the effects of the subtree and this fiber onto the effect
list of the parent. The completion order of the children affects the
side-effect order.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">if</span> (returnFiber.firstEffect === <span class="hljs-literal">null</span>) {
              returnFiber.firstEffect = workInProgress.firstEffect;
            }

            <span class="hljs-keyword">if</span> (workInProgress.lastEffect !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (returnFiber.lastEffect !== <span class="hljs-literal">null</span>) {
                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
              }

              returnFiber.lastEffect = workInProgress.lastEffect;
            } <span class="hljs-comment">// If this fiber had side-effects, we append it AFTER the children's</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1258" id="section-1258"></a>
</div>
<p>side-effects. We can perform certain side-effects earlier if needed,
by doing multiple passes over the effect list. We don't want to
schedule our own side-effect on our own list because if end up
reusing children we'll schedule this effect onto itself since we're
at the end.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

            <span class="hljs-keyword">var</span> effectTag = workInProgress.effectTag; <span class="hljs-comment">// Skip both NoWork and PerformedWork tags when creating the effect</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1259" id="section-1259"></a>
</div>
<p>list. PerformedWork effect is read by React DevTools but shouldn't be
committed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">if</span> (effectTag &gt; PerformedWork) {
              <span class="hljs-keyword">if</span> (returnFiber.lastEffect !== <span class="hljs-literal">null</span>) {
                returnFiber.lastEffect.nextEffect = workInProgress;
              } <span class="hljs-keyword">else</span> {
                returnFiber.firstEffect = workInProgress;
              }

              returnFiber.lastEffect = workInProgress;
            }
          }
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1260" id="section-1260"></a>
</div>
<p>This fiber did not complete because something threw. Pop values off
the stack without entering the complete phase. If this is a boundary,
capture values if possible.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> _next = unwindWork(workInProgress); <span class="hljs-comment">// Because this fiber did not complete, don't reset its expiration time.</span>


          <span class="hljs-keyword">if</span> ((workInProgress.mode &amp; ProfileMode) !== NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1261" id="section-1261"></a>
</div>
<p>Record the render duration for the fiber that errored.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Include the time spent working on failed children before continuing.</span>

            <span class="hljs-keyword">var</span> actualDuration = workInProgress.actualDuration;
            <span class="hljs-keyword">var</span> child = workInProgress.child;

            <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
              actualDuration += child.actualDuration;
              child = child.sibling;
            }

            workInProgress.actualDuration = actualDuration;
          }

          <span class="hljs-keyword">if</span> (_next !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1262" id="section-1262"></a>
</div>
<p>If completing this work spawned new work, do that next. We'll come
back here again.
Since we're restarting, remove anything that is not a host effect
from the effect tag.
TODO: The name stopFailedWorkTimer is misleading because Suspense
also captures and restarts.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            stopFailedWorkTimer(workInProgress);
            _next.effectTag &amp;= HostEffectMask;
            <span class="hljs-keyword">return</span> _next;
          }

          stopWorkTimer(workInProgress);

          <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1263" id="section-1263"></a>
</div>
<p>Mark the parent fiber as incomplete and clear its effect list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            returnFiber.firstEffect = returnFiber.lastEffect = <span class="hljs-literal">null</span>;
            returnFiber.effectTag |= Incomplete;
          }
        }

        <span class="hljs-keyword">var</span> siblingFiber = workInProgress.sibling;

        <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1264" id="section-1264"></a>
</div>
<p>If there is more work to do in this returnFiber, do that next.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> siblingFiber;
        } <span class="hljs-comment">// Otherwise, return to the parent</span>


        workInProgress = returnFiber;
      } <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// We've reached the root.</span>


      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === RootIncomplete) {
        workInProgressRootExitStatus = RootCompleted;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRemainingExpirationTime</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> updateExpirationTime = fiber.expirationTime;
      <span class="hljs-keyword">var</span> childExpirationTime = fiber.childExpirationTime;
      <span class="hljs-keyword">return</span> updateExpirationTime &gt; childExpirationTime ? updateExpirationTime : childExpirationTime;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetChildExpirationTime</span>(<span class="hljs-params">completedWork</span>) </span>{
      <span class="hljs-keyword">if</span> (renderExpirationTime$<span class="hljs-number">1</span> !== Never &amp;&amp; completedWork.childExpirationTime === Never) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1265" id="section-1265"></a>
</div>
<p>The children of this component are hidden. Don't bubble their
expiration times.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> newChildExpirationTime = NoWork; <span class="hljs-comment">// Bubble up the earliest expiration time.</span>

      <span class="hljs-keyword">if</span> ((completedWork.mode &amp; ProfileMode) !== NoMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1266" id="section-1266"></a>
</div>
<p>In profiling mode, resetChildExpirationTime is also used to reset
profiler durations.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> actualDuration = completedWork.actualDuration;
        <span class="hljs-keyword">var</span> treeBaseDuration = completedWork.selfBaseDuration; <span class="hljs-comment">// When a fiber is cloned, its actualDuration is reset to 0. This value will</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1267" id="section-1267"></a>
</div>
<p>only be updated if work is done on the fiber (i.e. it doesn't bailout).
When work is done, it should bubble to the parent's actualDuration. If
the fiber has not been cloned though, (meaning no work was done), then
this value will reflect the amount of time spent working on a previous
render. In that case it should not bubble. We determine whether it was
cloned by comparing the child pointer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">var</span> shouldBubbleActualDurations = completedWork.alternate === <span class="hljs-literal">null</span> || completedWork.child !== completedWork.alternate.child;
        <span class="hljs-keyword">var</span> child = completedWork.child;

        <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> childUpdateExpirationTime = child.expirationTime;
          <span class="hljs-keyword">var</span> childChildExpirationTime = child.childExpirationTime;

          <span class="hljs-keyword">if</span> (childUpdateExpirationTime &gt; newChildExpirationTime) {
            newChildExpirationTime = childUpdateExpirationTime;
          }

          <span class="hljs-keyword">if</span> (childChildExpirationTime &gt; newChildExpirationTime) {
            newChildExpirationTime = childChildExpirationTime;
          }

          <span class="hljs-keyword">if</span> (shouldBubbleActualDurations) {
            actualDuration += child.actualDuration;
          }

          treeBaseDuration += child.treeBaseDuration;
          child = child.sibling;
        }

        completedWork.actualDuration = actualDuration;
        completedWork.treeBaseDuration = treeBaseDuration;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> _child = completedWork.child;

        <span class="hljs-keyword">while</span> (_child !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> _childUpdateExpirationTime = _child.expirationTime;
          <span class="hljs-keyword">var</span> _childChildExpirationTime = _child.childExpirationTime;

          <span class="hljs-keyword">if</span> (_childUpdateExpirationTime &gt; newChildExpirationTime) {
            newChildExpirationTime = _childUpdateExpirationTime;
          }

          <span class="hljs-keyword">if</span> (_childChildExpirationTime &gt; newChildExpirationTime) {
            newChildExpirationTime = _childChildExpirationTime;
          }

          _child = _child.sibling;
        }
      }

      completedWork.childExpirationTime = newChildExpirationTime;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitRoot</span>(<span class="hljs-params">root</span>) </span>{
      <span class="hljs-keyword">var</span> renderPriorityLevel = getCurrentPriorityLevel();
      runWithPriority$<span class="hljs-number">1</span>(ImmediatePriority, commitRootImpl.bind(<span class="hljs-literal">null</span>, root, renderPriorityLevel));
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitRootImpl</span>(<span class="hljs-params">root, renderPriorityLevel</span>) </span>{
      <span class="hljs-keyword">do</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1268" id="section-1268"></a>
</div>
<p><code>flushPassiveEffects</code> will call <code>flushSyncUpdateQueue</code> at the end, which
means <code>flushPassiveEffects</code> will sometimes result in additional
passive effects. So we need to keep flushing in a loop until there are
no more pending effects.
TODO: Might be better if <code>flushPassiveEffects</code> did not automatically
flush synchronous work at the end, to avoid factoring hazards like this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        flushPassiveEffects();
      } <span class="hljs-keyword">while</span> (rootWithPendingPassiveEffects !== <span class="hljs-literal">null</span>);

      flushRenderPhaseStrictModeWarningsInDEV();

      <span class="hljs-keyword">if</span> (!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should not already be working."</span>);
        }
      }

      <span class="hljs-keyword">var</span> finishedWork = root.finishedWork;
      <span class="hljs-keyword">var</span> expirationTime = root.finishedExpirationTime;

      <span class="hljs-keyword">if</span> (finishedWork === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      root.finishedWork = <span class="hljs-literal">null</span>;
      root.finishedExpirationTime = NoWork;

      <span class="hljs-keyword">if</span> (!(finishedWork !== root.current)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."</span>);
        }
      } <span class="hljs-comment">// commitRoot never returns a continuation; it always finishes synchronously.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1269" id="section-1269"></a>
</div>
<p>So we can clear these now to allow a new callback to be scheduled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      root.callbackNode = <span class="hljs-literal">null</span>;
      root.callbackExpirationTime = NoWork;
      root.callbackPriority = NoPriority;
      root.nextKnownPendingLevel = NoWork;
      startCommitTimer(); <span class="hljs-comment">// Update the first and last pending times on this root. The new first</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1270" id="section-1270"></a>
</div>
<p>pending time is whatever is left on the root fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(finishedWork);
      markRootFinishedAtTime(root, expirationTime, remainingExpirationTimeBeforeCommit);

      <span class="hljs-keyword">if</span> (root === workInProgressRoot) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1271" id="section-1271"></a>
</div>
<p>We can reset these now that they are finished.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgressRoot = <span class="hljs-literal">null</span>;
        workInProgress = <span class="hljs-literal">null</span>;
        renderExpirationTime$<span class="hljs-number">1</span> = NoWork;
      } <span class="hljs-comment">// This indicates that the last root we worked on is not the same one that</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1272" id="section-1272"></a>
</div>
<p>we're committing now. This most commonly happens when a suspended root
times out.
Get the list of effects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> firstEffect;

      <span class="hljs-keyword">if</span> (finishedWork.effectTag &gt; PerformedWork) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1273" id="section-1273"></a>
</div>
<p>A fiber's effect list consists only of its children, not itself. So if
the root has an effect, we need to add it to the end of the list. The
resulting list is the set that would belong to the root's parent, if it
had one; that is, all the effects in the tree including the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (finishedWork.lastEffect !== <span class="hljs-literal">null</span>) {
          finishedWork.lastEffect.nextEffect = finishedWork;
          firstEffect = finishedWork.firstEffect;
        } <span class="hljs-keyword">else</span> {
          firstEffect = finishedWork;
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1274" id="section-1274"></a>
</div>
<p>There is no effect on the root.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        firstEffect = finishedWork.firstEffect;
      }

      <span class="hljs-keyword">if</span> (firstEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        <span class="hljs-keyword">var</span> prevInteractions = pushInteractions(root); <span class="hljs-comment">// Reset this to null before calling lifecycles</span>

        ReactCurrentOwner$<span class="hljs-number">2.</span>current = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The commit phase is broken into several sub-phases. We do a separate pass</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1275" id="section-1275"></a>
</div>
<p>of the effect list for each phase: all mutation effects come before all
layout effects, and so on.
The first phase a &quot;before mutation&quot; phase. We use this phase to read the
state of the host tree right before we mutate it. This is where
getSnapshotBeforeUpdate is called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        startCommitSnapshotEffectsTimer();
        prepareForCommit(root.containerInfo);
        nextEffect = firstEffect;

        <span class="hljs-keyword">do</span> {
          {
            invokeGuardedCallback(<span class="hljs-literal">null</span>, commitBeforeMutationEffects, <span class="hljs-literal">null</span>);

            <span class="hljs-keyword">if</span> (hasCaughtError()) {
              <span class="hljs-keyword">if</span> (!(nextEffect !== <span class="hljs-literal">null</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should be working on an effect."</span>);
                }
              }

              <span class="hljs-keyword">var</span> error = clearCaughtError();
              captureCommitPhaseError(nextEffect, error);
              nextEffect = nextEffect.nextEffect;
            }
          }
        } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);

        stopCommitSnapshotEffectsTimer();
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1276" id="section-1276"></a>
</div>
<p>Mark the current commit time to be shared by all Profilers in this
batch. This enables them to be grouped later.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          recordCommitTime();
        } <span class="hljs-comment">// The next phase is the mutation phase, where we mutate the host tree.</span>

        startCommitHostEffectsTimer();
        nextEffect = firstEffect;

        <span class="hljs-keyword">do</span> {
          {
            invokeGuardedCallback(<span class="hljs-literal">null</span>, commitMutationEffects, <span class="hljs-literal">null</span>, root, renderPriorityLevel);

            <span class="hljs-keyword">if</span> (hasCaughtError()) {
              <span class="hljs-keyword">if</span> (!(nextEffect !== <span class="hljs-literal">null</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should be working on an effect."</span>);
                }
              }

              <span class="hljs-keyword">var</span> _error = clearCaughtError();

              captureCommitPhaseError(nextEffect, _error);
              nextEffect = nextEffect.nextEffect;
            }
          }
        } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);

        stopCommitHostEffectsTimer();
        resetAfterCommit(root.containerInfo); <span class="hljs-comment">// The work-in-progress tree is now the current tree. This must come after</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1277" id="section-1277"></a>
</div>
<p>the mutation phase, so that the previous tree is still current during
componentWillUnmount, but before the layout phase, so that the finished
work is current during componentDidMount/Update.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        root.current = finishedWork; <span class="hljs-comment">// The next phase is the layout phase, where we call effects that read</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1278" id="section-1278"></a>
</div>
<p>the host tree after it's been mutated. The idiomatic use case for this is
layout, but class component lifecycles also fire here for legacy reasons.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        startCommitLifeCyclesTimer();
        nextEffect = firstEffect;

        <span class="hljs-keyword">do</span> {
          {
            invokeGuardedCallback(<span class="hljs-literal">null</span>, commitLayoutEffects, <span class="hljs-literal">null</span>, root, expirationTime);

            <span class="hljs-keyword">if</span> (hasCaughtError()) {
              <span class="hljs-keyword">if</span> (!(nextEffect !== <span class="hljs-literal">null</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should be working on an effect."</span>);
                }
              }

              <span class="hljs-keyword">var</span> _error2 = clearCaughtError();

              captureCommitPhaseError(nextEffect, _error2);
              nextEffect = nextEffect.nextEffect;
            }
          }
        } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);

        stopCommitLifeCyclesTimer();
        nextEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Tell Scheduler to yield at the end of the frame, so the browser has an</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1279" id="section-1279"></a>
</div>
<p>opportunity to paint.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        requestPaint();
        {
          popInteractions(prevInteractions);
        }
        executionContext = prevExecutionContext;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1280" id="section-1280"></a>
</div>
<p>No effects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root.current = finishedWork; <span class="hljs-comment">// Measure these anyway so the flamegraph explicitly shows that there were</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1281" id="section-1281"></a>
</div>
<p>no effects.
TODO: Maybe there's a better way to report this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        startCommitSnapshotEffectsTimer();
        stopCommitSnapshotEffectsTimer();
        {
          recordCommitTime();
        }
        startCommitHostEffectsTimer();
        stopCommitHostEffectsTimer();
        startCommitLifeCyclesTimer();
        stopCommitLifeCyclesTimer();
      }

      stopCommitTimer();
      <span class="hljs-keyword">var</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

      <span class="hljs-keyword">if</span> (rootDoesHavePassiveEffects) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1282" id="section-1282"></a>
</div>
<p>This commit has passive effects. Stash a reference to them. But don't
schedule a callback until after flushing layout work.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        rootDoesHavePassiveEffects = <span class="hljs-literal">false</span>;
        rootWithPendingPassiveEffects = root;
        pendingPassiveEffectsExpirationTime = expirationTime;
        pendingPassiveEffectsRenderPriority = renderPriorityLevel;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1283" id="section-1283"></a>
</div>
<p>We are done with the effect chain at this point so let's clear the
nextEffect pointers to assist with GC. If we have passive effects, we'll
clear this in flushPassiveEffects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        nextEffect = firstEffect;

        <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> nextNextEffect = nextEffect.nextEffect;
          nextEffect.nextEffect = <span class="hljs-literal">null</span>;
          nextEffect = nextNextEffect;
        }
      } <span class="hljs-comment">// Check if there's remaining work on this root</span>


      <span class="hljs-keyword">var</span> remainingExpirationTime = root.firstPendingTime;

      <span class="hljs-keyword">if</span> (remainingExpirationTime !== NoWork) {
        {
          <span class="hljs-keyword">if</span> (spawnedWorkDuringRender !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> expirationTimes = spawnedWorkDuringRender;
            spawnedWorkDuringRender = <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; expirationTimes.length; i++) {
              scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);
            }
          }

          schedulePendingInteractions(root, remainingExpirationTime);
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1284" id="section-1284"></a>
</div>
<p>If there's no remaining work, we can clear the set of already failed
error boundaries.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        legacyErrorBoundariesThatAlreadyFailed = <span class="hljs-literal">null</span>;
      }

      {
        <span class="hljs-keyword">if</span> (!rootDidHavePassiveEffects) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1285" id="section-1285"></a>
</div>
<p>If there are no passive effects, then we can complete the pending interactions.
Otherwise, we'll wait until after the passive effects are flushed.
Wait to do this until after remaining work has been scheduled,
so that we don't prematurely signal complete for interactions when there's e.g. hidden work.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          finishPendingInteractions(root, expirationTime);
        }
      }

      <span class="hljs-keyword">if</span> (remainingExpirationTime === Sync) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1286" id="section-1286"></a>
</div>
<p>Count the number of times the root synchronously re-renders without
finishing. If there are too many, it indicates an infinite update loop.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (root === rootWithNestedUpdates) {
          nestedUpdateCount++;
        } <span class="hljs-keyword">else</span> {
          nestedUpdateCount = <span class="hljs-number">0</span>;
          rootWithNestedUpdates = root;
        }
      } <span class="hljs-keyword">else</span> {
        nestedUpdateCount = <span class="hljs-number">0</span>;
      }

      onCommitRoot(finishedWork.stateNode, expirationTime); <span class="hljs-comment">// Always call this before exiting `commitRoot`, to ensure that any</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1287" id="section-1287"></a>
</div>
<p>additional work on this root is scheduled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      ensureRootIsScheduled(root);

      <span class="hljs-keyword">if</span> (hasUncaughtError) {
        hasUncaughtError = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> _error3 = firstUncaughtError;
        firstUncaughtError = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">throw</span> _error3;
      }

      <span class="hljs-keyword">if</span> ((executionContext &amp; LegacyUnbatchedContext) !== NoContext) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1288" id="section-1288"></a>
</div>
<p>This is a legacy edge case. We just committed the initial mount of
a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
synchronously, but layout updates should be deferred until the end
of the batch.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// If layout work was scheduled, flush it now.</span>


      flushSyncCallbackQueue();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitBeforeMutationEffects</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> effectTag = nextEffect.effectTag;

        <span class="hljs-keyword">if</span> ((effectTag &amp; Snapshot) !== NoEffect) {
          setCurrentFiber(nextEffect);
          recordEffect();
          <span class="hljs-keyword">var</span> current = nextEffect.alternate;
          commitBeforeMutationLifeCycles(current, nextEffect);
          resetCurrentFiber();
        }

        <span class="hljs-keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1289" id="section-1289"></a>
</div>
<p>If there are passive effects, schedule a callback to flush at
the earliest opportunity.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;
            scheduleCallback(NormalPriority, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              flushPassiveEffects();
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            });
          }
        }

        nextEffect = nextEffect.nextEffect;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitMutationEffects</span>(<span class="hljs-params">root, renderPriorityLevel</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1290" id="section-1290"></a>
</div>
<p>TODO: Should probably move the bulk of this function to commitWork.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        setCurrentFiber(nextEffect);
        <span class="hljs-keyword">var</span> effectTag = nextEffect.effectTag;

        <span class="hljs-keyword">if</span> (effectTag &amp; ContentReset) {
          commitResetTextContent(nextEffect);
        }

        <span class="hljs-keyword">if</span> (effectTag &amp; Ref) {
          <span class="hljs-keyword">var</span> current = nextEffect.alternate;

          <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
            commitDetachRef(current);
          }
        } <span class="hljs-comment">// The following switch statement is only concerned about placement,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1291" id="section-1291"></a>
</div>
<p>updates, and deletions. To avoid needing to add a case for every possible
bitmap value, we remove the secondary effects from the effect tag and
switch on that value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">var</span> primaryEffectTag = effectTag &amp; (Placement | Update | Deletion | Hydrating);

        <span class="hljs-keyword">switch</span> (primaryEffectTag) {
          <span class="hljs-keyword">case</span> Placement:
            {
              commitPlacement(nextEffect); <span class="hljs-comment">// Clear the "placement" from effect tag so that we know that this is</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1292" id="section-1292"></a>
</div>
<p>inserted, before any life-cycles like componentDidMount gets called.
TODO: findDOMNode doesn't rely on this any more but isMounted does
and isMounted is deprecated anyway so we should be able to kill this.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              nextEffect.effectTag &amp;= ~Placement;
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> PlacementAndUpdate:
            {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1293" id="section-1293"></a>
</div>
<p>Placement</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              commitPlacement(nextEffect); <span class="hljs-comment">// Clear the "placement" from effect tag so that we know that this is</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1294" id="section-1294"></a>
</div>
<p>inserted, before any life-cycles like componentDidMount gets called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
              nextEffect.effectTag &amp;= ~Placement; <span class="hljs-comment">// Update</span>

              <span class="hljs-keyword">var</span> _current = nextEffect.alternate;
              commitWork(_current, nextEffect);
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> Hydrating:
            {
              nextEffect.effectTag &amp;= ~Hydrating;
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> HydratingAndUpdate:
            {
              nextEffect.effectTag &amp;= ~Hydrating; <span class="hljs-comment">// Update</span>

              <span class="hljs-keyword">var</span> _current2 = nextEffect.alternate;
              commitWork(_current2, nextEffect);
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> Update:
            {
              <span class="hljs-keyword">var</span> _current3 = nextEffect.alternate;
              commitWork(_current3, nextEffect);
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> Deletion:
            {
              commitDeletion(root, nextEffect, renderPriorityLevel);
              <span class="hljs-keyword">break</span>;
            }
        } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Only record a mutation effect if primaryEffectTag is non-zero.</span>


        recordEffect();
        resetCurrentFiber();
        nextEffect = nextEffect.nextEffect;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commitLayoutEffects</span>(<span class="hljs-params">root, committedExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1295" id="section-1295"></a>
</div>
<p>TODO: Should probably move the bulk of this function to commitWork.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        setCurrentFiber(nextEffect);
        <span class="hljs-keyword">var</span> effectTag = nextEffect.effectTag;

        <span class="hljs-keyword">if</span> (effectTag &amp; (Update | Callback)) {
          recordEffect();
          <span class="hljs-keyword">var</span> current = nextEffect.alternate;
          commitLifeCycles(root, current, nextEffect);
        }

        <span class="hljs-keyword">if</span> (effectTag &amp; Ref) {
          recordEffect();
          commitAttachRef(nextEffect);
        }

        resetCurrentFiber();
        nextEffect = nextEffect.nextEffect;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushPassiveEffects</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (pendingPassiveEffectsRenderPriority !== NoPriority) {
        <span class="hljs-keyword">var</span> priorityLevel = pendingPassiveEffectsRenderPriority &gt; NormalPriority ? NormalPriority : pendingPassiveEffectsRenderPriority;
        pendingPassiveEffectsRenderPriority = NoPriority;
        <span class="hljs-keyword">return</span> runWithPriority$<span class="hljs-number">1</span>(priorityLevel, flushPassiveEffectsImpl);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushPassiveEffectsImpl</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (rootWithPendingPassiveEffects === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> root = rootWithPendingPassiveEffects;
      <span class="hljs-keyword">var</span> expirationTime = pendingPassiveEffectsExpirationTime;
      rootWithPendingPassiveEffects = <span class="hljs-literal">null</span>;
      pendingPassiveEffectsExpirationTime = NoWork;

      <span class="hljs-keyword">if</span> (!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot flush passive effects while already rendering."</span>);
        }
      }

      <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
      executionContext |= CommitContext;
      <span class="hljs-keyword">var</span> prevInteractions = pushInteractions(root);
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1296" id="section-1296"></a>
</div>
<p>Note: This currently assumes there are no passive effects on the root fiber
because the root is not part of its own effect list.
This could change in the future.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> _effect2 = root.current.firstEffect;

        <span class="hljs-keyword">while</span> (_effect2 !== <span class="hljs-literal">null</span>) {
          {
            setCurrentFiber(_effect2);
            invokeGuardedCallback(<span class="hljs-literal">null</span>, commitPassiveHookEffects, <span class="hljs-literal">null</span>, _effect2);

            <span class="hljs-keyword">if</span> (hasCaughtError()) {
              <span class="hljs-keyword">if</span> (!(_effect2 !== <span class="hljs-literal">null</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Should be working on an effect."</span>);
                }
              }

              <span class="hljs-keyword">var</span> _error5 = clearCaughtError();

              captureCommitPhaseError(_effect2, _error5);
            }

            resetCurrentFiber();
          }
          <span class="hljs-keyword">var</span> nextNextEffect = _effect2.nextEffect; <span class="hljs-comment">// Remove nextEffect pointer to assist GC</span>

          _effect2.nextEffect = <span class="hljs-literal">null</span>;
          _effect2 = nextNextEffect;
        }
      }
      {
        popInteractions(prevInteractions);
        finishPendingInteractions(root, expirationTime);
      }
      executionContext = prevExecutionContext;
      flushSyncCallbackQueue(); <span class="hljs-comment">// If additional passive effects were scheduled, increment a counter. If this</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1297" id="section-1297"></a>
</div>
<p>exceeds the limit, we'll fire a warning.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      nestedPassiveUpdateCount = rootWithPendingPassiveEffects === <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : nestedPassiveUpdateCount + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAlreadyFailedLegacyErrorBoundary</span>(<span class="hljs-params">instance</span>) </span>{
      <span class="hljs-keyword">return</span> legacyErrorBoundariesThatAlreadyFailed !== <span class="hljs-literal">null</span> &amp;&amp; legacyErrorBoundariesThatAlreadyFailed.has(instance);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markLegacyErrorBoundaryAsFailed</span>(<span class="hljs-params">instance</span>) </span>{
      <span class="hljs-keyword">if</span> (legacyErrorBoundariesThatAlreadyFailed === <span class="hljs-literal">null</span>) {
        legacyErrorBoundariesThatAlreadyFailed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([instance]);
      } <span class="hljs-keyword">else</span> {
        legacyErrorBoundariesThatAlreadyFailed.add(instance);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepareToThrowUncaughtError</span>(<span class="hljs-params">error</span>) </span>{
      <span class="hljs-keyword">if</span> (!hasUncaughtError) {
        hasUncaughtError = <span class="hljs-literal">true</span>;
        firstUncaughtError = error;
      }
    }

    <span class="hljs-keyword">var</span> onUncaughtError = prepareToThrowUncaughtError;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">captureCommitPhaseErrorOnRoot</span>(<span class="hljs-params">rootFiber, sourceFiber, error</span>) </span>{
      <span class="hljs-keyword">var</span> errorInfo = createCapturedValue(error, sourceFiber);
      <span class="hljs-keyword">var</span> update = createRootErrorUpdate(rootFiber, errorInfo, Sync);
      enqueueUpdate(rootFiber, update);
      <span class="hljs-keyword">var</span> root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);

      <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
        ensureRootIsScheduled(root);
        schedulePendingInteractions(root, Sync);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">captureCommitPhaseError</span>(<span class="hljs-params">sourceFiber, error</span>) </span>{
      <span class="hljs-keyword">if</span> (sourceFiber.tag === HostRoot) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1298" id="section-1298"></a>
</div>
<p>Error was thrown at the root. There is no parent, so the root
itself should capture it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> fiber = sourceFiber.return;

      <span class="hljs-keyword">while</span> (fiber !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (fiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fiber.tag === ClassComponent) {
          <span class="hljs-keyword">var</span> ctor = fiber.type;
          <span class="hljs-keyword">var</span> instance = fiber.stateNode;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.getDerivedStateFromError === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> instance.componentDidCatch === <span class="hljs-string">'function'</span> &amp;&amp; !isAlreadyFailedLegacyErrorBoundary(instance)) {
            <span class="hljs-keyword">var</span> errorInfo = createCapturedValue(error, sourceFiber);
            <span class="hljs-keyword">var</span> update = createClassErrorUpdate(fiber, errorInfo, <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is always sync</span>
            Sync);
            enqueueUpdate(fiber, update);
            <span class="hljs-keyword">var</span> root = markUpdateTimeFromFiberToRoot(fiber, Sync);

            <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
              ensureRootIsScheduled(root);
              schedulePendingInteractions(root, Sync);
            }

            <span class="hljs-keyword">return</span>;
          }
        }

        fiber = fiber.return;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pingSuspendedRoot</span>(<span class="hljs-params">root, thenable, suspendedTime</span>) </span>{
      <span class="hljs-keyword">var</span> pingCache = root.pingCache;

      <span class="hljs-keyword">if</span> (pingCache !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1299" id="section-1299"></a>
</div>
<p>The thenable resolved, so we no longer need to memoize, because it will
never be thrown again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        pingCache.delete(thenable);
      }

      <span class="hljs-keyword">if</span> (workInProgressRoot === root &amp;&amp; renderExpirationTime$<span class="hljs-number">1</span> === suspendedTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1300" id="section-1300"></a>
</div>
<p>Received a ping at the same priority level at which we're currently
rendering. We might want to restart this render. This should mirror
the logic of whether or not a root suspends once it completes.
TODO: If we're rendering sync either due to Sync, Batched or expired,
we should probably never restart.
If we're suspended with delay, we'll always suspend so we can always
restart. If we're suspended without any updates, it might be a retry.
If it's early in the retry we can restart. We can't know for sure
whether we'll eventually process an update during this render pass,
but it's somewhat unlikely that we get to a ping before that, since
getting to the root most update is usually very fast.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended &amp;&amp; workInProgressRootLatestProcessedExpirationTime === Sync &amp;&amp; now() - globalMostRecentFallbackTime &lt; FALLBACK_THROTTLE_MS) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1301" id="section-1301"></a>
</div>
<p>Restart from the root. Don't need to schedule a ping because
we're already working on this tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          prepareFreshStack(root, renderExpirationTime$<span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1302" id="section-1302"></a>
</div>
<p>Even though we can't restart right now, we might get an
opportunity later. So we mark this render as having a ping.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          workInProgressRootHasPendingPing = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (!isRootSuspendedAtTime(root, suspendedTime)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1303" id="section-1303"></a>
</div>
<p>The root is no longer suspended at this time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> lastPingedTime = root.lastPingedTime;

      <span class="hljs-keyword">if</span> (lastPingedTime !== NoWork &amp;&amp; lastPingedTime &lt; suspendedTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1304" id="section-1304"></a>
</div>
<p>There's already a lower priority ping scheduled.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// Mark the time at which this ping was scheduled.</span>


      root.lastPingedTime = suspendedTime;
      ensureRootIsScheduled(root);
      schedulePendingInteractions(root, suspendedTime);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retryTimedOutBoundary</span>(<span class="hljs-params">boundaryFiber, retryTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1305" id="section-1305"></a>
</div>
<p>The boundary fiber (a Suspense component or SuspenseList component)
previously was rendered in its fallback state. One of the promises that
suspended it has resolved, which means at least part of the tree was
likely unblocked. Try rendering again, at a new expiration time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (retryTime === NoWork) {
        <span class="hljs-keyword">var</span> suspenseConfig = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Retries don't carry over the already committed update.</span>

        <span class="hljs-keyword">var</span> currentTime = requestCurrentTimeForUpdate();
        retryTime = computeExpirationForFiber(currentTime, boundaryFiber, suspenseConfig);
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Special case idle priority?</span>


      <span class="hljs-keyword">var</span> root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);

      <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
        ensureRootIsScheduled(root);
        schedulePendingInteractions(root, retryTime);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveRetryThenable</span>(<span class="hljs-params">boundaryFiber, thenable</span>) </span>{
      <span class="hljs-keyword">var</span> retryTime = NoWork; <span class="hljs-comment">// Default</span>

      <span class="hljs-keyword">var</span> retryCache;
      {
        retryCache = boundaryFiber.stateNode;
      }

      <span class="hljs-keyword">if</span> (retryCache !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1306" id="section-1306"></a>
</div>
<p>The thenable resolved, so we no longer need to memoize, because it will
never be thrown again.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        retryCache.delete(thenable);
      }

      retryTimedOutBoundary(boundaryFiber, retryTime);
    } <span class="hljs-comment">// Computes the next Just Noticeable Difference (JND) boundary.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1307" id="section-1307"></a>
</div>
<p>The theory is that a person can't tell the difference between small differences in time.
Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
difference in the experience. However, waiting for longer might mean that we can avoid
showing an intermediate loading state. The longer we have already waited, the harder it
is to tell small differences in time. Therefore, the longer we've already waited,
the longer we can wait additionally. At some point we have to give up though.
We pick a train model where the next boundary commits at a consistent schedule.
These particular numbers are vague estimates. We expect to adjust them based on research.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jnd</span>(<span class="hljs-params">timeElapsed</span>) </span>{
      <span class="hljs-keyword">return</span> timeElapsed &lt; <span class="hljs-number">120</span> ? <span class="hljs-number">120</span> : timeElapsed &lt; <span class="hljs-number">480</span> ? <span class="hljs-number">480</span> : timeElapsed &lt; <span class="hljs-number">1080</span> ? <span class="hljs-number">1080</span> : timeElapsed &lt; <span class="hljs-number">1920</span> ? <span class="hljs-number">1920</span> : timeElapsed &lt; <span class="hljs-number">3000</span> ? <span class="hljs-number">3000</span> : timeElapsed &lt; <span class="hljs-number">4320</span> ? <span class="hljs-number">4320</span> : ceil(timeElapsed / <span class="hljs-number">1960</span>) * <span class="hljs-number">1960</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeMsUntilSuspenseLoadingDelay</span>(<span class="hljs-params">mostRecentEventTime, committedExpirationTime, suspenseConfig</span>) </span>{
      <span class="hljs-keyword">var</span> busyMinDurationMs = suspenseConfig.busyMinDurationMs | <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (busyMinDurationMs &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }

      <span class="hljs-keyword">var</span> busyDelayMs = suspenseConfig.busyDelayMs | <span class="hljs-number">0</span>; <span class="hljs-comment">// Compute the time until this render pass would expire.</span>

      <span class="hljs-keyword">var</span> currentTimeMs = now();
      <span class="hljs-keyword">var</span> eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(mostRecentEventTime, suspenseConfig);
      <span class="hljs-keyword">var</span> timeElapsed = currentTimeMs - eventTimeMs;

      <span class="hljs-keyword">if</span> (timeElapsed &lt;= busyDelayMs) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1308" id="section-1308"></a>
</div>
<p>If we haven't yet waited longer than the initial delay, we don't
have to wait any additional time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }

      <span class="hljs-keyword">var</span> msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; <span class="hljs-comment">// This is the value that is passed to `setTimeout`.</span>

      <span class="hljs-keyword">return</span> msUntilTimeout;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkForNestedUpdates</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {
        nestedUpdateCount = <span class="hljs-number">0</span>;
        rootWithNestedUpdates = <span class="hljs-literal">null</span>;
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."</span>);
          }
        }
      }

      {
        <span class="hljs-keyword">if</span> (nestedPassiveUpdateCount &gt; NESTED_PASSIVE_UPDATE_LIMIT) {
          nestedPassiveUpdateCount = <span class="hljs-number">0</span>;
          error(<span class="hljs-string">'Maximum update depth exceeded. This can happen when a component '</span> + <span class="hljs-string">"calls setState inside useEffect, but useEffect either doesn't "</span> + <span class="hljs-string">'have a dependency array, or one of the dependencies changes on '</span> + <span class="hljs-string">'every render.'</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushRenderPhaseStrictModeWarningsInDEV</span>(<span class="hljs-params"></span>) </span>{
      {
        ReactStrictModeWarnings.flushLegacyContextWarning();
        {
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopFinishedWorkLoopTimer</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> didCompleteRoot = <span class="hljs-literal">true</span>;
      stopWorkLoopTimer(interruptedBy, didCompleteRoot);
      interruptedBy = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopInterruptedWorkLoopTimer</span>(<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1309" id="section-1309"></a>
</div>
<p>TODO: Track which fiber caused the interruption.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> didCompleteRoot = <span class="hljs-literal">false</span>;
      stopWorkLoopTimer(interruptedBy, didCompleteRoot);
      interruptedBy = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkForInterruption</span>(<span class="hljs-params">fiberThatReceivedUpdate, updateExpirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (workInProgressRoot !== <span class="hljs-literal">null</span> &amp;&amp; updateExpirationTime &gt; renderExpirationTime$<span class="hljs-number">1</span>) {
        interruptedBy = fiberThatReceivedUpdate;
      }
    }

    <span class="hljs-keyword">var</span> didWarnStateUpdateForUnmountedComponent = <span class="hljs-literal">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnAboutUpdateOnUnmountedFiberInDEV</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">var</span> tag = fiber.tag;

        <span class="hljs-keyword">if</span> (tag !== HostRoot &amp;&amp; tag !== ClassComponent &amp;&amp; tag !== FunctionComponent &amp;&amp; tag !== ForwardRef &amp;&amp; tag !== MemoComponent &amp;&amp; tag !== SimpleMemoComponent &amp;&amp; tag !== Block) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1310" id="section-1310"></a>
</div>
<p>Only warn for user-defined components, not internal ones like Suspense.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// the problematic code almost always lies inside that component.</span>


        <span class="hljs-keyword">var</span> componentName = getComponentName(fiber.type) || <span class="hljs-string">'ReactComponent'</span>;

        <span class="hljs-keyword">if</span> (didWarnStateUpdateForUnmountedComponent !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
            <span class="hljs-keyword">return</span>;
          }

          didWarnStateUpdateForUnmountedComponent.add(componentName);
        } <span class="hljs-keyword">else</span> {
          didWarnStateUpdateForUnmountedComponent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([componentName]);
        }

        error(<span class="hljs-string">"Can't perform a React state update on an unmounted component. This "</span> + <span class="hljs-string">'is a no-op, but it indicates a memory leak in your application. To '</span> + <span class="hljs-string">'fix, cancel all subscriptions and asynchronous tasks in %s.%s'</span>, tag === ClassComponent ? <span class="hljs-string">'the componentWillUnmount method'</span> : <span class="hljs-string">'a useEffect cleanup function'</span>, getStackByFiberInDevAndProd(fiber));
      }
    }

    <span class="hljs-keyword">var</span> beginWork$<span class="hljs-number">1</span>;
    {
      <span class="hljs-keyword">var</span> dummyFiber = <span class="hljs-literal">null</span>;

      beginWork$<span class="hljs-number">1</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">current, unitOfWork, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1311" id="section-1311"></a>
</div>
<p>If a component throws an error, we replay it again in a synchronously
dispatched event, so that the debugger will treat it as an uncaught
error See ReactErrorUtils for more information.
Before entering the begin phase, copy the work-in-progress onto a dummy
fiber. If beginWork throws, we'll use this to reset the state.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> beginWork(current, unitOfWork, expirationTime);
        } <span class="hljs-keyword">catch</span> (originalError) {
          <span class="hljs-keyword">if</span> (originalError !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> originalError === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> originalError.then === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1312" id="section-1312"></a>
</div>
<p>Don't replay promises. Treat everything else like an error.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">throw</span> originalError;
          } <span class="hljs-comment">// Keep this code in sync with handleError; any changes here must have</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1313" id="section-1313"></a>
</div>
<p>corresponding changes there.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

          resetContextDependencies();
          resetHooksAfterThrow(); <span class="hljs-comment">// Don't reset current debug fiber, since we're about to work on the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1314" id="section-1314"></a>
</div>
<p>same fiber again.
Unwind the failed stack frame</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          unwindInterruptedWork(unitOfWork); <span class="hljs-comment">// Restore the original properties of the fiber.</span>

          assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);

          <span class="hljs-keyword">if</span> (unitOfWork.mode &amp; ProfileMode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1315" id="section-1315"></a>
</div>
<p>Reset the profiler timer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            startProfilerTimer(unitOfWork);
          } <span class="hljs-comment">// Run beginWork again.</span>


          invokeGuardedCallback(<span class="hljs-literal">null</span>, beginWork, <span class="hljs-literal">null</span>, current, unitOfWork, expirationTime);

          <span class="hljs-keyword">if</span> (hasCaughtError()) {
            <span class="hljs-keyword">var</span> replayError = clearCaughtError(); <span class="hljs-comment">// `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1316" id="section-1316"></a>
</div>
<p>Rethrow this error instead of the original one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
            <span class="hljs-keyword">throw</span> replayError;
          } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1317" id="section-1317"></a>
</div>
<p>This branch is reachable if the render phase is impure.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">throw</span> originalError;
          }
        }
      };
    }
    <span class="hljs-keyword">var</span> didWarnAboutUpdateInRender = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didWarnAboutUpdateInRenderForAnotherComponent;
    {
      didWarnAboutUpdateInRenderForAnotherComponent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnAboutRenderPhaseUpdatesInDEV</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (isRendering &amp;&amp; (executionContext &amp; RenderContext) !== NoContext) {
          <span class="hljs-keyword">switch</span> (fiber.tag) {
            <span class="hljs-keyword">case</span> FunctionComponent:
            <span class="hljs-keyword">case</span> ForwardRef:
            <span class="hljs-keyword">case</span> SimpleMemoComponent:
              {
                <span class="hljs-keyword">var</span> renderingComponentName = workInProgress &amp;&amp; getComponentName(workInProgress.type) || <span class="hljs-string">'Unknown'</span>; <span class="hljs-comment">// Dedupe by the rendering component because it's the one that needs to be fixed.</span>

                <span class="hljs-keyword">var</span> dedupeKey = renderingComponentName;

                <span class="hljs-keyword">if</span> (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                  didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                  <span class="hljs-keyword">var</span> setStateComponentName = getComponentName(fiber.type) || <span class="hljs-string">'Unknown'</span>;
                  error(<span class="hljs-string">'Cannot update a component (`%s`) while rendering a '</span> + <span class="hljs-string">'different component (`%s`). To locate the bad setState() call inside `%s`, '</span> + <span class="hljs-string">'follow the stack trace as described in https://fb.me/setstate-in-render'</span>, setStateComponentName, renderingComponentName, renderingComponentName);
                }

                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-keyword">case</span> ClassComponent:
              {
                <span class="hljs-keyword">if</span> (!didWarnAboutUpdateInRender) {
                  error(<span class="hljs-string">'Cannot update during an existing state transition (such as '</span> + <span class="hljs-string">'within `render`). Render methods should be a pure '</span> + <span class="hljs-string">'function of props and state.'</span>);
                  didWarnAboutUpdateInRender = <span class="hljs-literal">true</span>;
                }

                <span class="hljs-keyword">break</span>;
              }
          }
        }
      }
    } <span class="hljs-comment">// a 'shared' variable that changes when act() opens/closes in tests.</span>


    <span class="hljs-keyword">var</span> IsThisRendererActing = {
      <span class="hljs-attr">current</span>: <span class="hljs-literal">false</span>
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnIfNotScopedWithMatchingAct</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (IsSomeRendererActing.current === <span class="hljs-literal">true</span> &amp;&amp; IsThisRendererActing.current !== <span class="hljs-literal">true</span>) {
          error(<span class="hljs-string">"It looks like you're using the wrong act() around your test interactions.\n"</span> + <span class="hljs-string">'Be sure to use the matching version of act() corresponding to your renderer:\n\n'</span> + <span class="hljs-string">'// for react-dom:\n'</span> + <span class="hljs-string">"import {act} from 'react-dom/test-utils';\n"</span> + <span class="hljs-string">'// ...\n'</span> + <span class="hljs-string">'act(() =&gt; ...);\n\n'</span> + <span class="hljs-string">'// for react-test-renderer:\n'</span> + <span class="hljs-string">"import TestRenderer from 'react-test-renderer';\n"</span> + <span class="hljs-string">'const {act} = TestRenderer;\n'</span> + <span class="hljs-string">'// ...\n'</span> + <span class="hljs-string">'act(() =&gt; ...);'</span> + <span class="hljs-string">'%s'</span>, getStackByFiberInDevAndProd(fiber));
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnIfNotCurrentlyActingEffectsInDEV</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> ((fiber.mode &amp; StrictMode) !== NoMode &amp;&amp; IsSomeRendererActing.current === <span class="hljs-literal">false</span> &amp;&amp; IsThisRendererActing.current === <span class="hljs-literal">false</span>) {
          error(<span class="hljs-string">'An update to %s ran an effect, but was not wrapped in act(...).\n\n'</span> + <span class="hljs-string">'When testing, code that causes React state updates should be '</span> + <span class="hljs-string">'wrapped into act(...):\n\n'</span> + <span class="hljs-string">'act(() =&gt; {\n'</span> + <span class="hljs-string">'  /* fire events that update state */\n'</span> + <span class="hljs-string">'});\n'</span> + <span class="hljs-string">'/* assert on the output */\n\n'</span> + <span class="hljs-string">"This ensures that you're testing the behavior the user would see "</span> + <span class="hljs-string">'in the browser.'</span> + <span class="hljs-string">' Learn more at https://fb.me/react-wrap-tests-with-act'</span> + <span class="hljs-string">'%s'</span>, getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnIfNotCurrentlyActingUpdatesInDEV</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (executionContext === NoContext &amp;&amp; IsSomeRendererActing.current === <span class="hljs-literal">false</span> &amp;&amp; IsThisRendererActing.current === <span class="hljs-literal">false</span>) {
          error(<span class="hljs-string">'An update to %s inside a test was not wrapped in act(...).\n\n'</span> + <span class="hljs-string">'When testing, code that causes React state updates should be '</span> + <span class="hljs-string">'wrapped into act(...):\n\n'</span> + <span class="hljs-string">'act(() =&gt; {\n'</span> + <span class="hljs-string">'  /* fire events that update state */\n'</span> + <span class="hljs-string">'});\n'</span> + <span class="hljs-string">'/* assert on the output */\n\n'</span> + <span class="hljs-string">"This ensures that you're testing the behavior the user would see "</span> + <span class="hljs-string">'in the browser.'</span> + <span class="hljs-string">' Learn more at https://fb.me/react-wrap-tests-with-act'</span> + <span class="hljs-string">'%s'</span>, getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));
        }
      }
    }

    <span class="hljs-keyword">var</span> warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; <span class="hljs-comment">// In tests, we want to enforce a mocked scheduler.</span>

    <span class="hljs-keyword">var</span> didWarnAboutUnmockedScheduler = <span class="hljs-literal">false</span>; <span class="hljs-comment">// TODO Before we release concurrent mode, revisit this and decide whether a mocked</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1318" id="section-1318"></a>
</div>
<p>scheduler is the actual recommendation. The alternative could be a testing build,
a new lib, or whatever; we dunno just yet. This message is for early adopters
to get their tests right.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnIfUnmockedScheduler</span>(<span class="hljs-params">fiber</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (didWarnAboutUnmockedScheduler === <span class="hljs-literal">false</span> &amp;&amp; Scheduler.unstable_flushAllWithoutAsserting === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">if</span> (fiber.mode &amp; BlockingMode || fiber.mode &amp; ConcurrentMode) {
            didWarnAboutUnmockedScheduler = <span class="hljs-literal">true</span>;
            error(<span class="hljs-string">'In Concurrent or Sync modes, the "scheduler" module needs to be mocked '</span> + <span class="hljs-string">'to guarantee consistent behaviour across tests and browsers. '</span> + <span class="hljs-string">'For example, with jest: \n'</span> + <span class="hljs-string">"jest.mock('scheduler', () =&gt; require('scheduler/unstable_mock'));\n\n"</span> + <span class="hljs-string">'For more info, visit https://fb.me/react-mock-scheduler'</span>);
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeThreadID</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1319" id="section-1319"></a>
</div>
<p>Interaction threads are unique per root and expiration time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> expirationTime * <span class="hljs-number">1000</span> + root.interactionThreadID;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markSpawnedWork</span>(<span class="hljs-params">expirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (spawnedWorkDuringRender === <span class="hljs-literal">null</span>) {
        spawnedWorkDuringRender = [expirationTime];
      } <span class="hljs-keyword">else</span> {
        spawnedWorkDuringRender.push(expirationTime);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleInteractions</span>(<span class="hljs-params">root, expirationTime, interactions</span>) </span>{
      <span class="hljs-keyword">if</span> (interactions.size &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> pendingInteractionMap = root.pendingInteractionMap;
        <span class="hljs-keyword">var</span> pendingInteractions = pendingInteractionMap.get(expirationTime);

        <span class="hljs-keyword">if</span> (pendingInteractions != <span class="hljs-literal">null</span>) {
          interactions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) </span>{
            <span class="hljs-keyword">if</span> (!pendingInteractions.has(interaction)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1320" id="section-1320"></a>
</div>
<p>Update the pending async work count for previously unscheduled interaction.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              interaction.__count++;
            }

            pendingInteractions.add(interaction);
          });
        } <span class="hljs-keyword">else</span> {
          pendingInteractionMap.set(expirationTime, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(interactions)); <span class="hljs-comment">// Update the pending async work count for the current interactions.</span>

          interactions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) </span>{
            interaction.__count++;
          });
        }

        <span class="hljs-keyword">var</span> subscriber = tracing.__subscriberRef.current;

        <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> threadID = computeThreadID(root, expirationTime);
          subscriber.onWorkScheduled(interactions, threadID);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">schedulePendingInteractions</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
      scheduleInteractions(root, expirationTime, tracing.__interactionsRef.current);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWorkOnPendingInteractions</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1321" id="section-1321"></a>
</div>
<p>we can accurately attribute time spent working on it, And so that cascading
work triggered during the render phase will be associated with it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> interactions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      root.pendingInteractionMap.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scheduledInteractions, scheduledExpirationTime</span>) </span>{
        <span class="hljs-keyword">if</span> (scheduledExpirationTime &gt;= expirationTime) {
          scheduledInteractions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) </span>{
            <span class="hljs-keyword">return</span> interactions.add(interaction);
          });
        }
      }); <span class="hljs-comment">// Store the current set of interactions on the FiberRoot for a few reasons:</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1322" id="section-1322"></a>
</div>
<p>We can re-use it in hot functions like performConcurrentWorkOnRoot()
without having to recalculate it. We will also use it in commitWork() to
pass to any Profiler onRender() hooks. This also provides DevTools with a
way to access it when the onCommitRoot() hook is called.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      root.memoizedInteractions = interactions;

      <span class="hljs-keyword">if</span> (interactions.size &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> subscriber = tracing.__subscriberRef.current;

        <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> threadID = computeThreadID(root, expirationTime);

          <span class="hljs-keyword">try</span> {
            subscriber.onWorkStarted(interactions, threadID);
          } <span class="hljs-keyword">catch</span> (error) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1323" id="section-1323"></a>
</div>
<p>If the subscriber throws, rethrow it in a separate task</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            scheduleCallback(ImmediatePriority, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">throw</span> error;
            });
          }
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finishPendingInteractions</span>(<span class="hljs-params">root, committedExpirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> earliestRemainingTimeAfterCommit = root.firstPendingTime;
      <span class="hljs-keyword">var</span> subscriber;

      <span class="hljs-keyword">try</span> {
        subscriber = tracing.__subscriberRef.current;

        <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span> &amp;&amp; root.memoizedInteractions.size &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">var</span> threadID = computeThreadID(root, committedExpirationTime);
          subscriber.onWorkStopped(root.memoizedInteractions, threadID);
        }
      } <span class="hljs-keyword">catch</span> (error) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1324" id="section-1324"></a>
</div>
<p>If the subscriber throws, rethrow it in a separate task</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        scheduleCallback(ImmediatePriority, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">throw</span> error;
        });
      } <span class="hljs-keyword">finally</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1325" id="section-1325"></a>
</div>
<p>Clear completed interactions from the pending Map.
Unless the render was suspended or cascading work was scheduled,
In which case– leave pending interactions until the subsequent render.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> pendingInteractionMap = root.pendingInteractionMap;
        pendingInteractionMap.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scheduledInteractions, scheduledExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1326" id="section-1326"></a>
</div>
<p>Only decrement the pending interaction count if we're done.
If there's still work at the current priority,
That indicates that we are waiting for suspense data.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (scheduledExpirationTime &gt; earliestRemainingTimeAfterCommit) {
            pendingInteractionMap.delete(scheduledExpirationTime);
            scheduledInteractions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) </span>{
              interaction.__count--;

              <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span> &amp;&amp; interaction.__count === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">try</span> {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                } <span class="hljs-keyword">catch</span> (error) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1327" id="section-1327"></a>
</div>
<p>If the subscriber throws, rethrow it in a separate task</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                  scheduleCallback(ImmediatePriority, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">throw</span> error;
                  });
                }
              }
            });
          }
        });
      }
    }

    <span class="hljs-keyword">var</span> onScheduleFiberRoot = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> onCommitFiberRoot = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> onCommitFiberUnmount = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> hasLoggedError = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> isDevToolsPresent = <span class="hljs-keyword">typeof</span> __REACT_DEVTOOLS_GLOBAL_HOOK__ !== <span class="hljs-string">'undefined'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">injectInternals</span>(<span class="hljs-params">internals</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> __REACT_DEVTOOLS_GLOBAL_HOOK__ === <span class="hljs-string">'undefined'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1328" id="section-1328"></a>
</div>
<p>No DevTools</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

      <span class="hljs-keyword">if</span> (hook.isDisabled) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1329" id="section-1329"></a>
</div>
<p>This isn't a real property on the hook, but it can be set to opt out
of DevTools integration and associated warnings and logs.
https://github.com/facebook/react/issues/3877</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (!hook.supportsFiber) {
        {
          error(<span class="hljs-string">'The installed version of React DevTools is too old and will not work '</span> + <span class="hljs-string">'with the current version of React. Please update React DevTools. '</span> + <span class="hljs-string">'https://fb.me/react-devtools'</span>);
        } <span class="hljs-comment">// DevTools exists, even though it doesn't support Fiber.</span>

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> rendererID = hook.inject(internals); <span class="hljs-comment">// We have successfully injected, so now it is safe to set up hooks.</span>

        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1330" id="section-1330"></a>
</div>
<p>Only used by Fast Refresh</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> hook.onScheduleFiberRoot === <span class="hljs-string">'function'</span>) {
            onScheduleFiberRoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, children</span>) </span>{
              <span class="hljs-keyword">try</span> {
                hook.onScheduleFiberRoot(rendererID, root, children);
              } <span class="hljs-keyword">catch</span> (err) {
                <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> &amp;&amp; !hasLoggedError) {
                  hasLoggedError = <span class="hljs-literal">true</span>;
                  error(<span class="hljs-string">'React instrumentation encountered an error: %s'</span>, err);
                }
              }
            };
          }
        }

        onCommitFiberRoot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, expirationTime</span>) </span>{
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> didError = (root.current.effectTag &amp; DidCapture) === DidCapture;

            <span class="hljs-keyword">if</span> (enableProfilerTimer) {
              <span class="hljs-keyword">var</span> currentTime = getCurrentTime();
              <span class="hljs-keyword">var</span> priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime);
              hook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
            } <span class="hljs-keyword">else</span> {
              hook.onCommitFiberRoot(rendererID, root, <span class="hljs-literal">undefined</span>, didError);
            }
          } <span class="hljs-keyword">catch</span> (err) {
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
              <span class="hljs-keyword">if</span> (!hasLoggedError) {
                hasLoggedError = <span class="hljs-literal">true</span>;
                error(<span class="hljs-string">'React instrumentation encountered an error: %s'</span>, err);
              }
            }
          }
        };

        onCommitFiberUnmount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
          <span class="hljs-keyword">try</span> {
            hook.onCommitFiberUnmount(rendererID, fiber);
          } <span class="hljs-keyword">catch</span> (err) {
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
              <span class="hljs-keyword">if</span> (!hasLoggedError) {
                hasLoggedError = <span class="hljs-literal">true</span>;
                error(<span class="hljs-string">'React instrumentation encountered an error: %s'</span>, err);
              }
            }
          }
        };
      } <span class="hljs-keyword">catch</span> (err) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1331" id="section-1331"></a>
</div>
<p>Catch all errors because it is unsafe to throw during initialization.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        {
          error(<span class="hljs-string">'React instrumentation encountered an error: %s.'</span>, err);
        }
      } <span class="hljs-comment">// DevTools exists</span>


      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onScheduleRoot</span>(<span class="hljs-params">root, children</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onScheduleFiberRoot === <span class="hljs-string">'function'</span>) {
        onScheduleFiberRoot(root, children);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onCommitRoot</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onCommitFiberRoot === <span class="hljs-string">'function'</span>) {
        onCommitFiberRoot(root, expirationTime);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onCommitUnmount</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onCommitFiberUnmount === <span class="hljs-string">'function'</span>) {
        onCommitFiberUnmount(fiber);
      }
    }

    <span class="hljs-keyword">var</span> hasBadMapPolyfill;
    {
      hasBadMapPolyfill = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> nonExtensibleObject = <span class="hljs-built_in">Object</span>.preventExtensions({});
        <span class="hljs-keyword">var</span> testMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[nonExtensibleObject, <span class="hljs-literal">null</span>]]);
        <span class="hljs-keyword">var</span> testSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([nonExtensibleObject]); <span class="hljs-comment">// This is necessary for Rollup to not consider these unused.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1332" id="section-1332"></a>
</div>
<p>https://github.com/rollup/rollup/issues/1771
TODO: we can remove these if Rollup fixes the bug.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        testMap.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        testSet.add(<span class="hljs-number">0</span>);
      } <span class="hljs-keyword">catch</span> (e) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1333" id="section-1333"></a>
</div>
<p>TODO: Consider warning about bad polyfills</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        hasBadMapPolyfill = <span class="hljs-literal">true</span>;
      }
    }
    <span class="hljs-keyword">var</span> debugCounter = <span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FiberNode</span>(<span class="hljs-params">tag, pendingProps, key, mode</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1334" id="section-1334"></a>
</div>
<p>Instance</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">this</span>.tag = tag;
      <span class="hljs-keyword">this</span>.key = key;
      <span class="hljs-keyword">this</span>.elementType = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.type = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.stateNode = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Fiber</span>

      <span class="hljs-keyword">this</span>.return = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.child = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.sibling = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">this</span>.ref = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.pendingProps = pendingProps;
      <span class="hljs-keyword">this</span>.memoizedProps = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.updateQueue = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.memoizedState = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.dependencies = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.mode = mode; <span class="hljs-comment">// Effects</span>

      <span class="hljs-keyword">this</span>.effectTag = NoEffect;
      <span class="hljs-keyword">this</span>.nextEffect = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.firstEffect = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.lastEffect = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.expirationTime = NoWork;
      <span class="hljs-keyword">this</span>.childExpirationTime = NoWork;
      <span class="hljs-keyword">this</span>.alternate = <span class="hljs-literal">null</span>;
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1335" id="section-1335"></a>
</div>
<p>Note: The following is done to avoid a v8 performance cliff.</p>
<p>Initializing the fields below to smis and later updating them with
double values will cause Fibers to end up having separate shapes.
This behavior/bug has something to do with Object.preventExtension().
Fortunately this only impacts DEV builds.
Unfortunately it makes React unusably slow for some applications.
To work around this, initialize the fields below with doubles.</p>
<p>Learn more about this here:
https://github.com/facebook/react/issues/14365
https://bugs.chromium.org/p/v8/issues/detail?id=8538</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">this</span>.actualDuration = <span class="hljs-built_in">Number</span>.NaN;
        <span class="hljs-keyword">this</span>.actualStartTime = <span class="hljs-built_in">Number</span>.NaN;
        <span class="hljs-keyword">this</span>.selfBaseDuration = <span class="hljs-built_in">Number</span>.NaN;
        <span class="hljs-keyword">this</span>.treeBaseDuration = <span class="hljs-built_in">Number</span>.NaN; <span class="hljs-comment">// It's okay to replace the initial doubles with smis after initialization.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1336" id="section-1336"></a>
</div>
<p>This won't trigger the performance cliff mentioned above,
and it simplifies other profiler code (including DevTools).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">this</span>.actualDuration = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.actualStartTime = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">this</span>.selfBaseDuration = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.treeBaseDuration = <span class="hljs-number">0</span>;
      } <span class="hljs-comment">// This is normally DEV-only except www when it adds listeners.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1337" id="section-1337"></a>
</div>
<p>TODO: remove the User Timing integration in favor of Root Events.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      {
        <span class="hljs-keyword">this</span>._debugID = debugCounter++;
        <span class="hljs-keyword">this</span>._debugIsCurrentlyTiming = <span class="hljs-literal">false</span>;
      }
      {
        <span class="hljs-keyword">this</span>._debugSource = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>._debugOwner = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">this</span>._debugNeedsRemount = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>._debugHookTypes = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.preventExtensions === <span class="hljs-string">'function'</span>) {
          <span class="hljs-built_in">Object</span>.preventExtensions(<span class="hljs-keyword">this</span>);
        }
      }
    } <span class="hljs-comment">// This is a constructor function, rather than a POJO constructor, still</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1338" id="section-1338"></a>
</div>
<p>please ensure we do the following:</p>
<ol>
<li>Nobody should add any instance methods on this. Instance methods can be
more difficult to predict when they get optimized and they are almost
never inlined properly in static compilers.</li>
<li>Nobody should rely on <code>instanceof Fiber</code> for type testing. We should
always know when it is a fiber.</li>
<li>We might want to experiment with using numeric keys since they are easier
to optimize in a non-JIT environment.</li>
<li>We can easily go from a constructor to a createFiber object literal if that
is faster.</li>
<li>It should be easy to port this to a C struct and keep a C implementation
compatible.</li>
</ol>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> createFiber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag, pendingProps, key, mode</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1339" id="section-1339"></a>
</div>
<p>$FlowFixMe: the shapes are exact here but Flow doesn't like constructors</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FiberNode(tag, pendingProps, key, mode);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldConstruct</span>(<span class="hljs-params">Component</span>) </span>{
      <span class="hljs-keyword">var</span> prototype = Component.prototype;
      <span class="hljs-keyword">return</span> !!(prototype &amp;&amp; prototype.isReactComponent);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSimpleFunctionComponent</span>(<span class="hljs-params">type</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'function'</span> &amp;&amp; !shouldConstruct(type) &amp;&amp; type.defaultProps === <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveLazyComponentTag</span>(<span class="hljs-params">Component</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Component === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> shouldConstruct(Component) ? ClassComponent : FunctionComponent;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Component !== <span class="hljs-literal">undefined</span> &amp;&amp; Component !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> $$<span class="hljs-keyword">typeof</span> = Component.$$<span class="hljs-keyword">typeof</span>;

        <span class="hljs-keyword">if</span> ($$<span class="hljs-keyword">typeof</span> === REACT_FORWARD_REF_TYPE) {
          <span class="hljs-keyword">return</span> ForwardRef;
        }

        <span class="hljs-keyword">if</span> ($$<span class="hljs-keyword">typeof</span> === REACT_MEMO_TYPE) {
          <span class="hljs-keyword">return</span> MemoComponent;
        }
      }

      <span class="hljs-keyword">return</span> IndeterminateComponent;
    } <span class="hljs-comment">// This is used to create an alternate fiber to do work on.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWorkInProgress</span>(<span class="hljs-params">current, pendingProps</span>) </span>{
      <span class="hljs-keyword">var</span> workInProgress = current.alternate;

      <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1340" id="section-1340"></a>
</div>
<p>We use a double buffering pooling technique because we know that we'll
only ever need at most two versions of a tree. We pool the &quot;other&quot; unused
node that we're free to reuse. This is lazily created to avoid allocating
extra objects for things that are never updated. It also allow us to
reclaim the extra memory if needed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
        workInProgress.elementType = current.elementType;
        workInProgress.type = current.type;
        workInProgress.stateNode = current.stateNode;
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1341" id="section-1341"></a>
</div>
<p>DEV-only fields</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          {
            workInProgress._debugID = current._debugID;
          }
          workInProgress._debugSource = current._debugSource;
          workInProgress._debugOwner = current._debugOwner;
          workInProgress._debugHookTypes = current._debugHookTypes;
        }
        workInProgress.alternate = current;
        current.alternate = workInProgress;
      } <span class="hljs-keyword">else</span> {
        workInProgress.pendingProps = pendingProps; <span class="hljs-comment">// We already have an alternate.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1342" id="section-1342"></a>
</div>
<p>Reset the effect tag.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        workInProgress.effectTag = NoEffect; <span class="hljs-comment">// The effect list is no longer valid.</span>

        workInProgress.nextEffect = <span class="hljs-literal">null</span>;
        workInProgress.firstEffect = <span class="hljs-literal">null</span>;
        workInProgress.lastEffect = <span class="hljs-literal">null</span>;
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1343" id="section-1343"></a>
</div>
<p>We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.
This prevents time from endlessly accumulating in new commits.
This has the downside of resetting values for different priority renders,
But works for yielding (the common case) and should support resuming.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          workInProgress.actualDuration = <span class="hljs-number">0</span>;
          workInProgress.actualStartTime = <span class="hljs-number">-1</span>;
        }
      }

      workInProgress.childExpirationTime = current.childExpirationTime;
      workInProgress.expirationTime = current.expirationTime;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue; <span class="hljs-comment">// Clone the dependencies object. This is mutated during the render phase, so</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1344" id="section-1344"></a>
</div>
<p>it cannot be shared with the current fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> currentDependencies = current.dependencies;
      workInProgress.dependencies = currentDependencies === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : {
        <span class="hljs-attr">expirationTime</span>: currentDependencies.expirationTime,
        <span class="hljs-attr">firstContext</span>: currentDependencies.firstContext,
        <span class="hljs-attr">responders</span>: currentDependencies.responders
      }; <span class="hljs-comment">// These will be overridden during the parent's reconciliation</span>

      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      {
        workInProgress.selfBaseDuration = current.selfBaseDuration;
        workInProgress.treeBaseDuration = current.treeBaseDuration;
      }
      {
        workInProgress._debugNeedsRemount = current._debugNeedsRemount;

        <span class="hljs-keyword">switch</span> (workInProgress.tag) {
          <span class="hljs-keyword">case</span> IndeterminateComponent:
          <span class="hljs-keyword">case</span> FunctionComponent:
          <span class="hljs-keyword">case</span> SimpleMemoComponent:
            workInProgress.type = resolveFunctionForHotReloading(current.type);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> ClassComponent:
            workInProgress.type = resolveClassForHotReloading(current.type);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> ForwardRef:
            workInProgress.type = resolveForwardRefForHotReloading(current.type);
            <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">return</span> workInProgress;
    } <span class="hljs-comment">// Used to reuse a Fiber for a second pass.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetWorkInProgress</span>(<span class="hljs-params">workInProgress, renderExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1345" id="section-1345"></a>
</div>
<p>This resets the Fiber to what createFiber or createWorkInProgress would
have set the values to before during the first pass. Ideally this wouldn't
be necessary but unfortunately many code paths reads from the workInProgress
when they should be reading from current and writing to workInProgress.
We assume pendingProps, index, key, ref, return are still untouched to
avoid doing another reconciliation.
Reset the effect tag but keep any Placement tags, since that's something
that child fiber is setting, not the reconciliation.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      workInProgress.effectTag &amp;= Placement; <span class="hljs-comment">// The effect list is no longer valid.</span>

      workInProgress.nextEffect = <span class="hljs-literal">null</span>;
      workInProgress.firstEffect = <span class="hljs-literal">null</span>;
      workInProgress.lastEffect = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> current = workInProgress.alternate;

      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1346" id="section-1346"></a>
</div>
<p>Reset to createFiber's initial values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.childExpirationTime = NoWork;
        workInProgress.expirationTime = renderExpirationTime;
        workInProgress.child = <span class="hljs-literal">null</span>;
        workInProgress.memoizedProps = <span class="hljs-literal">null</span>;
        workInProgress.memoizedState = <span class="hljs-literal">null</span>;
        workInProgress.updateQueue = <span class="hljs-literal">null</span>;
        workInProgress.dependencies = <span class="hljs-literal">null</span>;
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1347" id="section-1347"></a>
</div>
<p>Note: We don't reset the actualTime counts. It's useful to accumulate
actual time across multiple render passes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          workInProgress.selfBaseDuration = <span class="hljs-number">0</span>;
          workInProgress.treeBaseDuration = <span class="hljs-number">0</span>;
        }
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1348" id="section-1348"></a>
</div>
<p>Reset to the cloned values that createWorkInProgress would've.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        workInProgress.childExpirationTime = current.childExpirationTime;
        workInProgress.expirationTime = current.expirationTime;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue; <span class="hljs-comment">// Clone the dependencies object. This is mutated during the render phase, so</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1349" id="section-1349"></a>
</div>
<p>it cannot be shared with the current fiber.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">var</span> currentDependencies = current.dependencies;
        workInProgress.dependencies = currentDependencies === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : {
          <span class="hljs-attr">expirationTime</span>: currentDependencies.expirationTime,
          <span class="hljs-attr">firstContext</span>: currentDependencies.firstContext,
          <span class="hljs-attr">responders</span>: currentDependencies.responders
        };
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1350" id="section-1350"></a>
</div>
<p>Note: We don't reset the actualTime counts. It's useful to accumulate
actual time across multiple render passes.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          workInProgress.selfBaseDuration = current.selfBaseDuration;
          workInProgress.treeBaseDuration = current.treeBaseDuration;
        }
      }

      <span class="hljs-keyword">return</span> workInProgress;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createHostRootFiber</span>(<span class="hljs-params">tag</span>) </span>{
      <span class="hljs-keyword">var</span> mode;

      <span class="hljs-keyword">if</span> (tag === ConcurrentRoot) {
        mode = ConcurrentMode | BlockingMode | StrictMode;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === BlockingRoot) {
        mode = BlockingMode | StrictMode;
      } <span class="hljs-keyword">else</span> {
        mode = NoMode;
      }

      <span class="hljs-keyword">if</span> (isDevToolsPresent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1351" id="section-1351"></a>
</div>
<p>Always collect profile timings when DevTools are present.
This enables DevTools to start capturing timing at any point–
Without some nodes in the tree having empty base times.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        mode |= ProfileMode;
      }

      <span class="hljs-keyword">return</span> createFiber(HostRoot, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, mode);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromTypeAndProps</span>(<span class="hljs-params">type, <span class="hljs-regexp">//</span> React$ElementType
    key, pendingProps, owner, mode, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> fiber;
      <span class="hljs-keyword">var</span> fiberTag = IndeterminateComponent; <span class="hljs-comment">// The resolved type is set if we know what the final type will be. I.e. it's not lazy.</span>

      <span class="hljs-keyword">var</span> resolvedType = type;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">if</span> (shouldConstruct(type)) {
          fiberTag = ClassComponent;
          {
            resolvedType = resolveClassForHotReloading(resolvedType);
          }
        } <span class="hljs-keyword">else</span> {
          {
            resolvedType = resolveFunctionForHotReloading(resolvedType);
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'string'</span>) {
        fiberTag = HostComponent;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-attr">getTag</span>: <span class="hljs-keyword">switch</span> (type) {
          <span class="hljs-keyword">case</span> REACT_FRAGMENT_TYPE:
            <span class="hljs-keyword">return</span> createFiberFromFragment(pendingProps.children, mode, expirationTime, key);

          <span class="hljs-keyword">case</span> REACT_CONCURRENT_MODE_TYPE:
            fiberTag = Mode;
            mode |= ConcurrentMode | BlockingMode | StrictMode;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> REACT_STRICT_MODE_TYPE:
            fiberTag = Mode;
            mode |= StrictMode;
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> REACT_PROFILER_TYPE:
            <span class="hljs-keyword">return</span> createFiberFromProfiler(pendingProps, mode, expirationTime, key);

          <span class="hljs-keyword">case</span> REACT_SUSPENSE_TYPE:
            <span class="hljs-keyword">return</span> createFiberFromSuspense(pendingProps, mode, expirationTime, key);

          <span class="hljs-keyword">case</span> REACT_SUSPENSE_LIST_TYPE:
            <span class="hljs-keyword">return</span> createFiberFromSuspenseList(pendingProps, mode, expirationTime, key);

          <span class="hljs-keyword">default</span>:
            {
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'object'</span> &amp;&amp; type !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">switch</span> (type.$$<span class="hljs-keyword">typeof</span>) {
                  <span class="hljs-keyword">case</span> REACT_PROVIDER_TYPE:
                    fiberTag = ContextProvider;
                    <span class="hljs-keyword">break</span> getTag;

                  <span class="hljs-keyword">case</span> REACT_CONTEXT_TYPE:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1352" id="section-1352"></a>
</div>
<p>This is a consumer</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">                    fiberTag = ContextConsumer;
                    <span class="hljs-keyword">break</span> getTag;

                  <span class="hljs-keyword">case</span> REACT_FORWARD_REF_TYPE:
                    fiberTag = ForwardRef;
                    {
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    }
                    <span class="hljs-keyword">break</span> getTag;

                  <span class="hljs-keyword">case</span> REACT_MEMO_TYPE:
                    fiberTag = MemoComponent;
                    <span class="hljs-keyword">break</span> getTag;

                  <span class="hljs-keyword">case</span> REACT_LAZY_TYPE:
                    fiberTag = LazyComponent;
                    resolvedType = <span class="hljs-literal">null</span>;
                    <span class="hljs-keyword">break</span> getTag;

                  <span class="hljs-keyword">case</span> REACT_BLOCK_TYPE:
                    fiberTag = Block;
                    <span class="hljs-keyword">break</span> getTag;
                }
              }

              <span class="hljs-keyword">var</span> info = <span class="hljs-string">''</span>;
              {
                <span class="hljs-keyword">if</span> (type === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">'object'</span> &amp;&amp; type !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys(type).length === <span class="hljs-number">0</span>) {
                  info += <span class="hljs-string">' You likely forgot to export your component from the file '</span> + <span class="hljs-string">"it's defined in, or you might have mixed up default and "</span> + <span class="hljs-string">'named imports.'</span>;
                }

                <span class="hljs-keyword">var</span> ownerName = owner ? getComponentName(owner.type) : <span class="hljs-literal">null</span>;

                <span class="hljs-keyword">if</span> (ownerName) {
                  info += <span class="hljs-string">'\n\nCheck the render method of `'</span> + ownerName + <span class="hljs-string">'`.'</span>;
                }
              }
              {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: "</span> + (type == <span class="hljs-literal">null</span> ? type : <span class="hljs-keyword">typeof</span> type) + <span class="hljs-string">"."</span> + info);
                }
              }
            }
        }
      }

      fiber = createFiber(fiberTag, pendingProps, key, mode);
      fiber.elementType = type;
      fiber.type = resolvedType;
      fiber.expirationTime = expirationTime;
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromElement</span>(<span class="hljs-params">element, mode, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> owner = <span class="hljs-literal">null</span>;
      {
        owner = element._owner;
      }
      <span class="hljs-keyword">var</span> type = element.type;
      <span class="hljs-keyword">var</span> key = element.key;
      <span class="hljs-keyword">var</span> pendingProps = element.props;
      <span class="hljs-keyword">var</span> fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
      {
        fiber._debugSource = element._source;
        fiber._debugOwner = element._owner;
      }
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromFragment</span>(<span class="hljs-params">elements, mode, expirationTime, key</span>) </span>{
      <span class="hljs-keyword">var</span> fiber = createFiber(Fragment, elements, key, mode);
      fiber.expirationTime = expirationTime;
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromProfiler</span>(<span class="hljs-params">pendingProps, mode, expirationTime, key</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pendingProps.id !== <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> pendingProps.onRender !== <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'Profiler must specify an "id" string and "onRender" function as props'</span>);
        }
      }
      <span class="hljs-keyword">var</span> fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> The Profiler fiber shouldn't have a type. It has a tag.</span>

      fiber.elementType = REACT_PROFILER_TYPE;
      fiber.type = REACT_PROFILER_TYPE;
      fiber.expirationTime = expirationTime;
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromSuspense</span>(<span class="hljs-params">pendingProps, mode, expirationTime, key</span>) </span>{
      <span class="hljs-keyword">var</span> fiber = createFiber(SuspenseComponent, pendingProps, key, mode); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> The SuspenseComponent fiber shouldn't have a type. It has a tag.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1353" id="section-1353"></a>
</div>
<p>This needs to be fixed in getComponentName so that it relies on the tag
instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      fiber.type = REACT_SUSPENSE_TYPE;
      fiber.elementType = REACT_SUSPENSE_TYPE;
      fiber.expirationTime = expirationTime;
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromSuspenseList</span>(<span class="hljs-params">pendingProps, mode, expirationTime, key</span>) </span>{
      <span class="hljs-keyword">var</span> fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1354" id="section-1354"></a>
</div>
<p>TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
This needs to be fixed in getComponentName so that it relies on the tag
instead.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        fiber.type = REACT_SUSPENSE_LIST_TYPE;
      }
      fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
      fiber.expirationTime = expirationTime;
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromText</span>(<span class="hljs-params">content, mode, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> fiber = createFiber(HostText, content, <span class="hljs-literal">null</span>, mode);
      fiber.expirationTime = expirationTime;
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromHostInstanceForDeletion</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> fiber = createFiber(HostComponent, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, NoMode); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> These should not need a type.</span>

      fiber.elementType = <span class="hljs-string">'DELETED'</span>;
      fiber.type = <span class="hljs-string">'DELETED'</span>;
      <span class="hljs-keyword">return</span> fiber;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberFromPortal</span>(<span class="hljs-params">portal, mode, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> pendingProps = portal.children !== <span class="hljs-literal">null</span> ? portal.children : [];
      <span class="hljs-keyword">var</span> fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
      fiber.expirationTime = expirationTime;
      fiber.stateNode = {
        <span class="hljs-attr">containerInfo</span>: portal.containerInfo,
        <span class="hljs-attr">pendingChildren</span>: <span class="hljs-literal">null</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1355" id="section-1355"></a>
</div>
<p>Used by persistent updates</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        implementation: portal.implementation
      };
      <span class="hljs-keyword">return</span> fiber;
    } <span class="hljs-comment">// Used for stashing WIP properties to replay failed work in DEV.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assignFiberPropertiesInDEV</span>(<span class="hljs-params">target, source</span>) </span>{
      <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1356" id="section-1356"></a>
</div>
<p>This Fiber's initial properties will always be overwritten.
We only use a Fiber to ensure the same hidden class so DEV isn't slow.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        target = createFiber(IndeterminateComponent, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, NoMode);
      } <span class="hljs-comment">// This is intentionally written as a list of all properties.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1357" id="section-1357"></a>
</div>
<p>We tried to use Object.assign() instead but this is called in
the hottest path, and Object.assign() was too slow:
https://github.com/facebook/react/issues/12502
This code is DEV-only so size is not a concern.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      target.tag = source.tag;
      target.key = source.key;
      target.elementType = source.elementType;
      target.type = source.type;
      target.stateNode = source.stateNode;
      target.return = source.return;
      target.child = source.child;
      target.sibling = source.sibling;
      target.index = source.index;
      target.ref = source.ref;
      target.pendingProps = source.pendingProps;
      target.memoizedProps = source.memoizedProps;
      target.updateQueue = source.updateQueue;
      target.memoizedState = source.memoizedState;
      target.dependencies = source.dependencies;
      target.mode = source.mode;
      target.effectTag = source.effectTag;
      target.nextEffect = source.nextEffect;
      target.firstEffect = source.firstEffect;
      target.lastEffect = source.lastEffect;
      target.expirationTime = source.expirationTime;
      target.childExpirationTime = source.childExpirationTime;
      target.alternate = source.alternate;
      {
        target.actualDuration = source.actualDuration;
        target.actualStartTime = source.actualStartTime;
        target.selfBaseDuration = source.selfBaseDuration;
        target.treeBaseDuration = source.treeBaseDuration;
      }
      {
        target._debugID = source._debugID;
      }
      target._debugSource = source._debugSource;
      target._debugOwner = source._debugOwner;
      target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
      target._debugNeedsRemount = source._debugNeedsRemount;
      target._debugHookTypes = source._debugHookTypes;
      <span class="hljs-keyword">return</span> target;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FiberRootNode</span>(<span class="hljs-params">containerInfo, tag, hydrate</span>) </span>{
      <span class="hljs-keyword">this</span>.tag = tag;
      <span class="hljs-keyword">this</span>.current = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.containerInfo = containerInfo;
      <span class="hljs-keyword">this</span>.pendingChildren = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.pingCache = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.finishedExpirationTime = NoWork;
      <span class="hljs-keyword">this</span>.finishedWork = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.timeoutHandle = noTimeout;
      <span class="hljs-keyword">this</span>.context = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.pendingContext = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.hydrate = hydrate;
      <span class="hljs-keyword">this</span>.callbackNode = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.callbackPriority = NoPriority;
      <span class="hljs-keyword">this</span>.firstPendingTime = NoWork;
      <span class="hljs-keyword">this</span>.firstSuspendedTime = NoWork;
      <span class="hljs-keyword">this</span>.lastSuspendedTime = NoWork;
      <span class="hljs-keyword">this</span>.nextKnownPendingLevel = NoWork;
      <span class="hljs-keyword">this</span>.lastPingedTime = NoWork;
      <span class="hljs-keyword">this</span>.lastExpiredTime = NoWork;
      {
        <span class="hljs-keyword">this</span>.interactionThreadID = tracing.unstable_getThreadID();
        <span class="hljs-keyword">this</span>.memoizedInteractions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
        <span class="hljs-keyword">this</span>.pendingInteractionMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFiberRoot</span>(<span class="hljs-params">containerInfo, tag, hydrate, hydrationCallbacks</span>) </span>{
      <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">new</span> FiberRootNode(containerInfo, tag, hydrate); <span class="hljs-comment">// stateNode is any.</span>

      <span class="hljs-keyword">var</span> uninitializedFiber = createHostRootFiber(tag);
      root.current = uninitializedFiber;
      uninitializedFiber.stateNode = root;
      initializeUpdateQueue(uninitializedFiber);
      <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRootSuspendedAtTime</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> firstSuspendedTime = root.firstSuspendedTime;
      <span class="hljs-keyword">var</span> lastSuspendedTime = root.lastSuspendedTime;
      <span class="hljs-keyword">return</span> firstSuspendedTime !== NoWork &amp;&amp; firstSuspendedTime &gt;= expirationTime &amp;&amp; lastSuspendedTime &lt;= expirationTime;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRootSuspendedAtTime</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> firstSuspendedTime = root.firstSuspendedTime;
      <span class="hljs-keyword">var</span> lastSuspendedTime = root.lastSuspendedTime;

      <span class="hljs-keyword">if</span> (firstSuspendedTime &lt; expirationTime) {
        root.firstSuspendedTime = expirationTime;
      }

      <span class="hljs-keyword">if</span> (lastSuspendedTime &gt; expirationTime || firstSuspendedTime === NoWork) {
        root.lastSuspendedTime = expirationTime;
      }

      <span class="hljs-keyword">if</span> (expirationTime &lt;= root.lastPingedTime) {
        root.lastPingedTime = NoWork;
      }

      <span class="hljs-keyword">if</span> (expirationTime &lt;= root.lastExpiredTime) {
        root.lastExpiredTime = NoWork;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRootUpdatedAtTime</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1358" id="section-1358"></a>
</div>
<p>Update the range of pending times</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> firstPendingTime = root.firstPendingTime;

      <span class="hljs-keyword">if</span> (expirationTime &gt; firstPendingTime) {
        root.firstPendingTime = expirationTime;
      } <span class="hljs-comment">// Update the range of suspended times. Treat everything lower priority or</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1359" id="section-1359"></a>
</div>
<p>equal to this update as unsuspended.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> firstSuspendedTime = root.firstSuspendedTime;

      <span class="hljs-keyword">if</span> (firstSuspendedTime !== NoWork) {
        <span class="hljs-keyword">if</span> (expirationTime &gt;= firstSuspendedTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1360" id="section-1360"></a>
</div>
<p>The entire suspended range is now unsuspended.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expirationTime &gt;= root.lastSuspendedTime) {
          root.lastSuspendedTime = expirationTime + <span class="hljs-number">1</span>;
        } <span class="hljs-comment">// This is a pending level. Check if it's higher priority than the next</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1361" id="section-1361"></a>
</div>
<p>known pending level.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (expirationTime &gt; root.nextKnownPendingLevel) {
          root.nextKnownPendingLevel = expirationTime;
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRootFinishedAtTime</span>(<span class="hljs-params">root, finishedExpirationTime, remainingExpirationTime</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1362" id="section-1362"></a>
</div>
<p>Update the range of pending times</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      root.firstPendingTime = remainingExpirationTime; <span class="hljs-comment">// Update the range of suspended times. Treat everything higher priority or</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1363" id="section-1363"></a>
</div>
<p>equal to this update as unsuspended.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">if</span> (finishedExpirationTime &lt;= root.lastSuspendedTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1364" id="section-1364"></a>
</div>
<p>The entire suspended range is now unsuspended.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (finishedExpirationTime &lt;= root.firstSuspendedTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1365" id="section-1365"></a>
</div>
<p>Part of the suspended range is now unsuspended. Narrow the range to
include everything between the unsuspended time (non-inclusive) and the
last suspended time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root.firstSuspendedTime = finishedExpirationTime - <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">if</span> (finishedExpirationTime &lt;= root.lastPingedTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1366" id="section-1366"></a>
</div>
<p>Clear the pinged time</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root.lastPingedTime = NoWork;
      }

      <span class="hljs-keyword">if</span> (finishedExpirationTime &lt;= root.lastExpiredTime) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1367" id="section-1367"></a>
</div>
<p>Clear the expired time</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root.lastExpiredTime = NoWork;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRootExpiredAtTime</span>(<span class="hljs-params">root, expirationTime</span>) </span>{
      <span class="hljs-keyword">var</span> lastExpiredTime = root.lastExpiredTime;

      <span class="hljs-keyword">if</span> (lastExpiredTime === NoWork || lastExpiredTime &gt; expirationTime) {
        root.lastExpiredTime = expirationTime;
      }
    }

    <span class="hljs-keyword">var</span> didWarnAboutNestedUpdates;
    <span class="hljs-keyword">var</span> didWarnAboutFindNodeInStrictMode;
    {
      didWarnAboutNestedUpdates = <span class="hljs-literal">false</span>;
      didWarnAboutFindNodeInStrictMode = {};
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContextForSubtree</span>(<span class="hljs-params">parentComponent</span>) </span>{
      <span class="hljs-keyword">if</span> (!parentComponent) {
        <span class="hljs-keyword">return</span> emptyContextObject;
      }

      <span class="hljs-keyword">var</span> fiber = <span class="hljs-keyword">get</span>(parentComponent);
      var parentContext = findCurrentUnmaskedContext(fiber);

      if (fiber.tag === ClassComponent) {
        <span class="hljs-keyword">var</span> Component = fiber.type;

        <span class="hljs-keyword">if</span> (isContextProvider(Component)) {
          <span class="hljs-keyword">return</span> processChildContext(fiber, Component, parentContext);
        }
      }

      <span class="hljs-keyword">return</span> parentContext;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findHostInstanceWithWarning</span>(<span class="hljs-params">component, methodName</span>) </span>{
      {
        <span class="hljs-keyword">var</span> fiber = <span class="hljs-keyword">get</span>(component);

        if (fiber === undefined) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> component.render === <span class="hljs-string">'function'</span>) {
            {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unable to find node on an unmounted component."</span>);
              }
            }
          } <span class="hljs-keyword">else</span> {
            {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Argument appears to not be a ReactComponent. Keys: "</span> + <span class="hljs-built_in">Object</span>.keys(component));
              }
            }
          }
        }

        <span class="hljs-keyword">var</span> hostFiber = findCurrentHostFiber(fiber);

        <span class="hljs-keyword">if</span> (hostFiber === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">if</span> (hostFiber.mode &amp; StrictMode) {
          <span class="hljs-keyword">var</span> componentName = getComponentName(fiber.type) || <span class="hljs-string">'Component'</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutFindNodeInStrictMode[componentName]) {
            didWarnAboutFindNodeInStrictMode[componentName] = <span class="hljs-literal">true</span>;

            <span class="hljs-keyword">if</span> (fiber.mode &amp; StrictMode) {
              error(<span class="hljs-string">'%s is deprecated in StrictMode. '</span> + <span class="hljs-string">'%s was passed an instance of %s which is inside StrictMode. '</span> + <span class="hljs-string">'Instead, add a ref directly to the element you want to reference. '</span> + <span class="hljs-string">'Learn more about using refs safely here: '</span> + <span class="hljs-string">'https://fb.me/react-strict-mode-find-node%s'</span>, methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
            } <span class="hljs-keyword">else</span> {
              error(<span class="hljs-string">'%s is deprecated in StrictMode. '</span> + <span class="hljs-string">'%s was passed an instance of %s which renders StrictMode children. '</span> + <span class="hljs-string">'Instead, add a ref directly to the element you want to reference. '</span> + <span class="hljs-string">'Learn more about using refs safely here: '</span> + <span class="hljs-string">'https://fb.me/react-strict-mode-find-node%s'</span>, methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
            }
          }
        }

        <span class="hljs-keyword">return</span> hostFiber.stateNode;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContainer</span>(<span class="hljs-params">containerInfo, tag, hydrate, hydrationCallbacks</span>) </span>{
      <span class="hljs-keyword">return</span> createFiberRoot(containerInfo, tag, hydrate);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateContainer</span>(<span class="hljs-params">element, container, parentComponent, callback</span>) </span>{
      {
        onScheduleRoot(container, element);
      }
      <span class="hljs-keyword">var</span> current$<span class="hljs-number">1</span> = container.current;
      <span class="hljs-keyword">var</span> currentTime = requestCurrentTimeForUpdate();
      {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1368" id="section-1368"></a>
</div>
<p>$FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-string">'undefined'</span> !== <span class="hljs-keyword">typeof</span> jest) {
          warnIfUnmockedScheduler(current$<span class="hljs-number">1</span>);
          warnIfNotScopedWithMatchingAct(current$<span class="hljs-number">1</span>);
        }
      }
      <span class="hljs-keyword">var</span> suspenseConfig = requestCurrentSuspenseConfig();
      <span class="hljs-keyword">var</span> expirationTime = computeExpirationForFiber(currentTime, current$<span class="hljs-number">1</span>, suspenseConfig);
      <span class="hljs-keyword">var</span> context = getContextForSubtree(parentComponent);

      <span class="hljs-keyword">if</span> (container.context === <span class="hljs-literal">null</span>) {
        container.context = context;
      } <span class="hljs-keyword">else</span> {
        container.pendingContext = context;
      }

      {
        <span class="hljs-keyword">if</span> (isRendering &amp;&amp; current !== <span class="hljs-literal">null</span> &amp;&amp; !didWarnAboutNestedUpdates) {
          didWarnAboutNestedUpdates = <span class="hljs-literal">true</span>;
          error(<span class="hljs-string">'Render methods should be a pure function of props and state; '</span> + <span class="hljs-string">'triggering nested component updates from render is not allowed. '</span> + <span class="hljs-string">'If necessary, trigger nested updates in componentDidUpdate.\n\n'</span> + <span class="hljs-string">'Check the render method of %s.'</span>, getComponentName(current.type) || <span class="hljs-string">'Unknown'</span>);
        }
      }
      <span class="hljs-keyword">var</span> update = createUpdate(expirationTime, suspenseConfig); <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1369" id="section-1369"></a>
</div>
<p>being called &quot;element&quot;.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      update.payload = {
        <span class="hljs-attr">element</span>: element
      };
      callback = callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback;

      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
            error(<span class="hljs-string">'render(...): Expected the last optional `callback` argument to be a '</span> + <span class="hljs-string">'function. Instead received: %s.'</span>, callback);
          }
        }
        update.callback = callback;
      }

      enqueueUpdate(current$<span class="hljs-number">1</span>, update);
      scheduleWork(current$<span class="hljs-number">1</span>, expirationTime);
      <span class="hljs-keyword">return</span> expirationTime;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPublicRootInstance</span>(<span class="hljs-params">container</span>) </span>{
      <span class="hljs-keyword">var</span> containerFiber = container.current;

      <span class="hljs-keyword">if</span> (!containerFiber.child) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">switch</span> (containerFiber.child.tag) {
        <span class="hljs-keyword">case</span> HostComponent:
          <span class="hljs-keyword">return</span> getPublicInstance(containerFiber.child.stateNode);

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> containerFiber.child.stateNode;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRetryTimeImpl</span>(<span class="hljs-params">fiber, retryTime</span>) </span>{
      <span class="hljs-keyword">var</span> suspenseState = fiber.memoizedState;

      <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span> &amp;&amp; suspenseState.dehydrated !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (suspenseState.retryTime &lt; retryTime) {
          suspenseState.retryTime = retryTime;
        }
      }
    } <span class="hljs-comment">// Increases the priority of thennables when they resolve within this boundary.</span>


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markRetryTimeIfNotHydrated</span>(<span class="hljs-params">fiber, retryTime</span>) </span>{
      markRetryTimeImpl(fiber, retryTime);
      <span class="hljs-keyword">var</span> alternate = fiber.alternate;

      <span class="hljs-keyword">if</span> (alternate) {
        markRetryTimeImpl(alternate, retryTime);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemptUserBlockingHydration$1</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (fiber.tag !== SuspenseComponent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1370" id="section-1370"></a>
</div>
<p>We ignore HostRoots here because we can't increase
their priority and they should not suspend on I/O,
since you have to wrap anything that might suspend in
Suspense.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());
      scheduleWork(fiber, expTime);
      markRetryTimeIfNotHydrated(fiber, expTime);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemptContinuousHydration$1</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (fiber.tag !== SuspenseComponent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1371" id="section-1371"></a>
</div>
<p>We ignore HostRoots here because we can't increase
their priority and they should not suspend on I/O,
since you have to wrap anything that might suspend in
Suspense.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      scheduleWork(fiber, ContinuousHydration);
      markRetryTimeIfNotHydrated(fiber, ContinuousHydration);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attemptHydrationAtCurrentPriority$1</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">if</span> (fiber.tag !== SuspenseComponent) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1372" id="section-1372"></a>
</div>
<p>We ignore HostRoots here because we can't increase
their priority other than synchronously flush it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> currentTime = requestCurrentTimeForUpdate();
      <span class="hljs-keyword">var</span> expTime = computeExpirationForFiber(currentTime, fiber, <span class="hljs-literal">null</span>);
      scheduleWork(fiber, expTime);
      markRetryTimeIfNotHydrated(fiber, expTime);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findHostInstanceWithNoPortals</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">var</span> hostFiber = findCurrentHostFiberWithNoPortals(fiber);

      <span class="hljs-keyword">if</span> (hostFiber === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (hostFiber.tag === FundamentalComponent) {
        <span class="hljs-keyword">return</span> hostFiber.stateNode.instance;
      }

      <span class="hljs-keyword">return</span> hostFiber.stateNode;
    }

    <span class="hljs-keyword">var</span> shouldSuspendImpl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldSuspend</span>(<span class="hljs-params">fiber</span>) </span>{
      <span class="hljs-keyword">return</span> shouldSuspendImpl(fiber);
    }

    <span class="hljs-keyword">var</span> overrideHookState = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> overrideProps = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> scheduleUpdate = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> setSuspenseHandler = <span class="hljs-literal">null</span>;
    {
      <span class="hljs-keyword">var</span> copyWithSetImpl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, path, idx, value</span>) </span>{
        <span class="hljs-keyword">if</span> (idx &gt;= path.length) {
          <span class="hljs-keyword">return</span> value;
        }

        <span class="hljs-keyword">var</span> key = path[idx];
        <span class="hljs-keyword">var</span> updated = <span class="hljs-built_in">Array</span>.isArray(obj) ? obj.slice() : _assign({}, obj); <span class="hljs-comment">// $FlowFixMe number or string is fine here</span>

        updated[key] = copyWithSetImpl(obj[key], path, idx + <span class="hljs-number">1</span>, value);
        <span class="hljs-keyword">return</span> updated;
      };

      <span class="hljs-keyword">var</span> copyWithSet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, path, value</span>) </span>{
        <span class="hljs-keyword">return</span> copyWithSetImpl(obj, path, <span class="hljs-number">0</span>, value);
      }; <span class="hljs-comment">// Support DevTools editable values for useState and useReducer.</span>


      overrideHookState = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, id, path, value</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1373" id="section-1373"></a>
</div>
<p>For now, the &quot;id&quot; of stateful hooks is just the stateful hook index.
This may change in the future with e.g. nested hooks.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> currentHook = fiber.memoizedState;

        <span class="hljs-keyword">while</span> (currentHook !== <span class="hljs-literal">null</span> &amp;&amp; id &gt; <span class="hljs-number">0</span>) {
          currentHook = currentHook.next;
          id--;
        }

        <span class="hljs-keyword">if</span> (currentHook !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> newState = copyWithSet(currentHook.memoizedState, path, value);
          currentHook.memoizedState = newState;
          currentHook.baseState = newState; <span class="hljs-comment">// We aren't actually adding an update to the queue,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1374" id="section-1374"></a>
</div>
<p>because there is no update we can add for useReducer hooks that won't trigger an error.
(There's no appropriate action type for DevTools overrides.)
As a result though, React will see the scheduled update as a noop and bailout.
Shallow cloning props works as a workaround for now to bypass the bailout check.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
          fiber.memoizedProps = _assign({}, fiber.memoizedProps);
          scheduleWork(fiber, Sync);
        }
      }; <span class="hljs-comment">// Support DevTools props for function components, forwardRef, memo, host components, etc.</span>


      overrideProps = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, path, value</span>) </span>{
        fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);

        <span class="hljs-keyword">if</span> (fiber.alternate) {
          fiber.alternate.pendingProps = fiber.pendingProps;
        }

        scheduleWork(fiber, Sync);
      };

      scheduleUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
        scheduleWork(fiber, Sync);
      };

      setSuspenseHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newShouldSuspendImpl</span>) </span>{
        shouldSuspendImpl = newShouldSuspendImpl;
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">injectIntoDevTools</span>(<span class="hljs-params">devToolsConfig</span>) </span>{
      <span class="hljs-keyword">var</span> findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
      <span class="hljs-keyword">var</span> ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      <span class="hljs-keyword">return</span> injectInternals(_assign({}, devToolsConfig, {
        <span class="hljs-attr">overrideHookState</span>: overrideHookState,
        <span class="hljs-attr">overrideProps</span>: overrideProps,
        <span class="hljs-attr">setSuspenseHandler</span>: setSuspenseHandler,
        <span class="hljs-attr">scheduleUpdate</span>: scheduleUpdate,
        <span class="hljs-attr">currentDispatcherRef</span>: ReactCurrentDispatcher,
        <span class="hljs-attr">findHostInstanceByFiber</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) </span>{
          <span class="hljs-keyword">var</span> hostFiber = findCurrentHostFiber(fiber);

          <span class="hljs-keyword">if</span> (hostFiber === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> hostFiber.stateNode;
        },
        <span class="hljs-attr">findFiberByHostInstance</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">instance</span>) </span>{
          <span class="hljs-keyword">if</span> (!findFiberByHostInstance) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1375" id="section-1375"></a>
</div>
<p>Might not be implemented by the renderer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> findFiberByHostInstance(instance);
        },
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1376" id="section-1376"></a>
</div>
<p>React Refresh</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        findHostInstancesForRefresh: findHostInstancesForRefresh,
        <span class="hljs-attr">scheduleRefresh</span>: scheduleRefresh,
        <span class="hljs-attr">scheduleRoot</span>: scheduleRoot,
        <span class="hljs-attr">setRefreshHandler</span>: setRefreshHandler,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1377" id="section-1377"></a>
</div>
<p>Enables DevTools to append owner stacks to error messages in DEV mode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        getCurrentFiber: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> current;
        }
      }));
    }

    <span class="hljs-keyword">var</span> IsSomeRendererActing$<span class="hljs-number">1</span> = ReactSharedInternals.IsSomeRendererActing;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReactDOMRoot</span>(<span class="hljs-params">container, options</span>) </span>{
      <span class="hljs-keyword">this</span>._internalRoot = createRootImpl(container, ConcurrentRoot, options);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReactDOMBlockingRoot</span>(<span class="hljs-params">container, tag, options</span>) </span>{
      <span class="hljs-keyword">this</span>._internalRoot = createRootImpl(container, tag, options);
    }

    ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">children</span>) </span>{
      <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">this</span>._internalRoot;
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'render(...): does not support the second callback argument. '</span> + <span class="hljs-string">'To execute a side effect after rendering, declare it in a component body with useEffect().'</span>);
        }

        <span class="hljs-keyword">var</span> container = root.containerInfo;

        <span class="hljs-keyword">if</span> (container.nodeType !== COMMENT_NODE) {
          <span class="hljs-keyword">var</span> hostInstance = findHostInstanceWithNoPortals(root.current);

          <span class="hljs-keyword">if</span> (hostInstance) {
            <span class="hljs-keyword">if</span> (hostInstance.parentNode !== container) {
              error(<span class="hljs-string">'render(...): It looks like the React-rendered content of the '</span> + <span class="hljs-string">'root container was removed without using React. This is not '</span> + <span class="hljs-string">'supported and will cause errors. Instead, call '</span> + <span class="hljs-string">"root.unmount() to empty a root's container."</span>);
            }
          }
        }
      }
      updateContainer(children, root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
    };

    ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] === <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'unmount(...): does not support a callback argument. '</span> + <span class="hljs-string">'To execute a side effect after rendering, declare it in a component body with useEffect().'</span>);
        }
      }
      <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">this</span>._internalRoot;
      <span class="hljs-keyword">var</span> container = root.containerInfo;
      updateContainer(<span class="hljs-literal">null</span>, root, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        unmarkContainerAsRoot(container);
      });
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRootImpl</span>(<span class="hljs-params">container, tag, options</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1378" id="section-1378"></a>
</div>
<p>Tag is either LegacyRoot or Concurrent Root</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> hydrate = options != <span class="hljs-literal">null</span> &amp;&amp; options.hydrate === <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> hydrationCallbacks = options != <span class="hljs-literal">null</span> &amp;&amp; options.hydrationOptions || <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> root = createContainer(container, tag, hydrate);
      markContainerAsRoot(root.current, container);

      <span class="hljs-keyword">if</span> (hydrate &amp;&amp; tag !== LegacyRoot) {
        <span class="hljs-keyword">var</span> doc = container.nodeType === DOCUMENT_NODE ? container : container.ownerDocument;
        eagerlyTrapReplayableEvents(container, doc);
      }

      <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createLegacyRoot</span>(<span class="hljs-params">container, options</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReactDOMBlockingRoot(container, LegacyRoot, options);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidContainer</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> !!(node &amp;&amp; (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE &amp;&amp; node.nodeValue === <span class="hljs-string">' react-mount-point-unstable '</span>));
    }

    <span class="hljs-keyword">var</span> ReactCurrentOwner$<span class="hljs-number">3</span> = ReactSharedInternals.ReactCurrentOwner;
    <span class="hljs-keyword">var</span> topLevelUpdateWarnings;
    <span class="hljs-keyword">var</span> warnedAboutHydrateAPI = <span class="hljs-literal">false</span>;
    {
      topLevelUpdateWarnings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) </span>{
        <span class="hljs-keyword">if</span> (container._reactRootContainer &amp;&amp; container.nodeType !== COMMENT_NODE) {
          <span class="hljs-keyword">var</span> hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);

          <span class="hljs-keyword">if</span> (hostInstance) {
            <span class="hljs-keyword">if</span> (hostInstance.parentNode !== container) {
              error(<span class="hljs-string">'render(...): It looks like the React-rendered content of this '</span> + <span class="hljs-string">'container was removed without using React. This is not '</span> + <span class="hljs-string">'supported and will cause errors. Instead, call '</span> + <span class="hljs-string">'ReactDOM.unmountComponentAtNode to empty a container.'</span>);
            }
          }
        }

        <span class="hljs-keyword">var</span> isRootRenderedBySomeReact = !!container._reactRootContainer;
        <span class="hljs-keyword">var</span> rootEl = getReactRootElementInContainer(container);
        <span class="hljs-keyword">var</span> hasNonRootReactChild = !!(rootEl &amp;&amp; getInstanceFromNode$<span class="hljs-number">1</span>(rootEl));

        <span class="hljs-keyword">if</span> (hasNonRootReactChild &amp;&amp; !isRootRenderedBySomeReact) {
          error(<span class="hljs-string">'render(...): Replacing React-rendered children with a new root '</span> + <span class="hljs-string">'component. If you intended to update the children of this node, '</span> + <span class="hljs-string">'you should instead have the existing children update their state '</span> + <span class="hljs-string">'and render the new components instead of calling ReactDOM.render.'</span>);
        }

        <span class="hljs-keyword">if</span> (container.nodeType === ELEMENT_NODE &amp;&amp; container.tagName &amp;&amp; container.tagName.toUpperCase() === <span class="hljs-string">'BODY'</span>) {
          error(<span class="hljs-string">'render(): Rendering components directly into document.body is '</span> + <span class="hljs-string">'discouraged, since its children are often manipulated by third-party '</span> + <span class="hljs-string">'scripts and browser extensions. This may lead to subtle '</span> + <span class="hljs-string">'reconciliation issues. Try rendering into a container element created '</span> + <span class="hljs-string">'for your app.'</span>);
        }
      };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getReactRootElementInContainer</span>(<span class="hljs-params">container</span>) </span>{
      <span class="hljs-keyword">if</span> (!container) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (container.nodeType === DOCUMENT_NODE) {
        <span class="hljs-keyword">return</span> container.documentElement;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> container.firstChild;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldHydrateDueToLegacyHeuristic</span>(<span class="hljs-params">container</span>) </span>{
      <span class="hljs-keyword">var</span> rootElement = getReactRootElementInContainer(container);
      <span class="hljs-keyword">return</span> !!(rootElement &amp;&amp; rootElement.nodeType === ELEMENT_NODE &amp;&amp; rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">legacyCreateRootFromDOMContainer</span>(<span class="hljs-params">container, forceHydrate</span>) </span>{
      <span class="hljs-keyword">var</span> shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); <span class="hljs-comment">// First clear any existing content.</span>

      <span class="hljs-keyword">if</span> (!shouldHydrate) {
        <span class="hljs-keyword">var</span> warned = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> rootSibling;

        <span class="hljs-keyword">while</span> (rootSibling = container.lastChild) {
          {
            <span class="hljs-keyword">if</span> (!warned &amp;&amp; rootSibling.nodeType === ELEMENT_NODE &amp;&amp; rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
              warned = <span class="hljs-literal">true</span>;
              error(<span class="hljs-string">'render(): Target node has markup rendered by React, but there '</span> + <span class="hljs-string">'are unrelated nodes as well. This is most commonly caused by '</span> + <span class="hljs-string">'white-space inserted around server-rendered markup.'</span>);
            }
          }
          container.removeChild(rootSibling);
        }
      }

      {
        <span class="hljs-keyword">if</span> (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) {
          warnedAboutHydrateAPI = <span class="hljs-literal">true</span>;
          warn(<span class="hljs-string">'render(): Calling ReactDOM.render() to hydrate server-rendered markup '</span> + <span class="hljs-string">'will stop working in React v17. Replace the ReactDOM.render() call '</span> + <span class="hljs-string">'with ReactDOM.hydrate() if you want React to attach to the server HTML.'</span>);
        }
      }
      <span class="hljs-keyword">return</span> createLegacyRoot(container, shouldHydrate ? {
        <span class="hljs-attr">hydrate</span>: <span class="hljs-literal">true</span>
      } : <span class="hljs-literal">undefined</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnOnInvalidCallback$1</span>(<span class="hljs-params">callback, callerName</span>) </span>{
      {
        <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
          error(<span class="hljs-string">'%s(...): Expected the last optional `callback` argument to be a '</span> + <span class="hljs-string">'function. Instead received: %s.'</span>, callerName, callback);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">legacyRenderSubtreeIntoContainer</span>(<span class="hljs-params">parentComponent, children, container, forceHydrate, callback</span>) </span>{
      {
        topLevelUpdateWarnings(container);
        warnOnInvalidCallback$<span class="hljs-number">1</span>(callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback, <span class="hljs-string">'render'</span>);
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Without `any` type, Flow says "Property cannot be accessed on any</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1379" id="section-1379"></a>
</div>
<p>member of intersection type.&quot; Whyyyyyy.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> root = container._reactRootContainer;
      <span class="hljs-keyword">var</span> fiberRoot;

      <span class="hljs-keyword">if</span> (!root) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1380" id="section-1380"></a>
</div>
<p>Initial mount</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
        fiberRoot = root._internalRoot;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">var</span> originalCallback = callback;

          callback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> instance = getPublicRootInstance(fiberRoot);
            originalCallback.call(instance);
          };
        } <span class="hljs-comment">// Initial mount should not be batched.</span>


        unbatchedUpdates(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          updateContainer(children, fiberRoot, parentComponent, callback);
        });
      } <span class="hljs-keyword">else</span> {
        fiberRoot = root._internalRoot;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">var</span> _originalCallback = callback;

          callback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> instance = getPublicRootInstance(fiberRoot);

            _originalCallback.call(instance);
          };
        } <span class="hljs-comment">// Update</span>


        updateContainer(children, fiberRoot, parentComponent, callback);
      }

      <span class="hljs-keyword">return</span> getPublicRootInstance(fiberRoot);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findDOMNode</span>(<span class="hljs-params">componentOrElement</span>) </span>{
      {
        <span class="hljs-keyword">var</span> owner = ReactCurrentOwner$<span class="hljs-number">3.</span>current;

        <span class="hljs-keyword">if</span> (owner !== <span class="hljs-literal">null</span> &amp;&amp; owner.stateNode !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;

          <span class="hljs-keyword">if</span> (!warnedAboutRefsInRender) {
            error(<span class="hljs-string">'%s is accessing findDOMNode inside its render(). '</span> + <span class="hljs-string">'render() should be a pure function of props and state. It should '</span> + <span class="hljs-string">'never access something that requires stale data from the previous '</span> + <span class="hljs-string">'render, such as refs. Move this logic to componentDidMount and '</span> + <span class="hljs-string">'componentDidUpdate instead.'</span>, getComponentName(owner.type) || <span class="hljs-string">'A component'</span>);
          }

          owner.stateNode._warnedAboutRefsInRender = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">if</span> (componentOrElement == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (componentOrElement.nodeType === ELEMENT_NODE) {
        <span class="hljs-keyword">return</span> componentOrElement;
      }

      {
        <span class="hljs-keyword">return</span> findHostInstanceWithWarning(componentOrElement, <span class="hljs-string">'findDOMNode'</span>);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hydrate</span>(<span class="hljs-params">element, container, callback</span>) </span>{
      <span class="hljs-keyword">if</span> (!isValidContainer(container)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Target container is not a DOM element."</span>);
        }
      }

      {
        <span class="hljs-keyword">var</span> isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === <span class="hljs-literal">undefined</span>;

        <span class="hljs-keyword">if</span> (isModernRoot) {
          error(<span class="hljs-string">'You are calling ReactDOM.hydrate() on a container that was previously '</span> + <span class="hljs-string">'passed to ReactDOM.createRoot(). This is not supported. '</span> + <span class="hljs-string">'Did you mean to call createRoot(container, {hydrate: true}).render(element)?'</span>);
        }
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> throw or warn if we couldn't hydrate?</span>

      <span class="hljs-keyword">return</span> legacyRenderSubtreeIntoContainer(<span class="hljs-literal">null</span>, element, container, <span class="hljs-literal">true</span>, callback);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">element, container, callback</span>) </span>{
      <span class="hljs-keyword">if</span> (!isValidContainer(container)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Target container is not a DOM element."</span>);
        }
      }

      {
        <span class="hljs-keyword">var</span> isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === <span class="hljs-literal">undefined</span>;

        <span class="hljs-keyword">if</span> (isModernRoot) {
          error(<span class="hljs-string">'You are calling ReactDOM.render() on a container that was previously '</span> + <span class="hljs-string">'passed to ReactDOM.createRoot(). This is not supported. '</span> + <span class="hljs-string">'Did you mean to call root.render(element)?'</span>);
        }
      }
      <span class="hljs-keyword">return</span> legacyRenderSubtreeIntoContainer(<span class="hljs-literal">null</span>, element, container, <span class="hljs-literal">false</span>, callback);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_renderSubtreeIntoContainer</span>(<span class="hljs-params">parentComponent, element, containerNode, callback</span>) </span>{
      <span class="hljs-keyword">if</span> (!isValidContainer(containerNode)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Target container is not a DOM element."</span>);
        }
      }

      <span class="hljs-keyword">if</span> (!(parentComponent != <span class="hljs-literal">null</span> &amp;&amp; has(parentComponent))) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"parentComponent must be a valid React Component"</span>);
        }
      }

      <span class="hljs-keyword">return</span> legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, <span class="hljs-literal">false</span>, callback);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmountComponentAtNode</span>(<span class="hljs-params">container</span>) </span>{
      <span class="hljs-keyword">if</span> (!isValidContainer(container)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"unmountComponentAtNode(...): Target container is not a DOM element."</span>);
        }
      }

      {
        <span class="hljs-keyword">var</span> isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === <span class="hljs-literal">undefined</span>;

        <span class="hljs-keyword">if</span> (isModernRoot) {
          error(<span class="hljs-string">'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '</span> + <span class="hljs-string">'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?'</span>);
        }
      }

      <span class="hljs-keyword">if</span> (container._reactRootContainer) {
        {
          <span class="hljs-keyword">var</span> rootEl = getReactRootElementInContainer(container);
          <span class="hljs-keyword">var</span> renderedByDifferentReact = rootEl &amp;&amp; !getInstanceFromNode$<span class="hljs-number">1</span>(rootEl);

          <span class="hljs-keyword">if</span> (renderedByDifferentReact) {
            error(<span class="hljs-string">"unmountComponentAtNode(): The node you're attempting to unmount "</span> + <span class="hljs-string">'was rendered by another copy of React.'</span>);
          }
        } <span class="hljs-comment">// Unmount should not be batched.</span>

        unbatchedUpdates(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          legacyRenderSubtreeIntoContainer(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, container, <span class="hljs-literal">false</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1381" id="section-1381"></a>
</div>
<p>$FlowFixMe This should probably use <code>delete container._reactRootContainer</code></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            container._reactRootContainer = <span class="hljs-literal">null</span>;
            unmarkContainerAsRoot(container);
          });
        }); <span class="hljs-comment">// If you call unmountComponentAtNode twice in quick succession, you'll</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1382" id="section-1382"></a>
</div>
<p>get <code>true</code> twice. That's probably fine?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        {
          <span class="hljs-keyword">var</span> _rootEl = getReactRootElementInContainer(container);

          <span class="hljs-keyword">var</span> hasNonRootReactChild = !!(_rootEl &amp;&amp; getInstanceFromNode$<span class="hljs-number">1</span>(_rootEl)); <span class="hljs-comment">// Check if the container itself is a React root node.</span>

          <span class="hljs-keyword">var</span> isContainerReactRoot = container.nodeType === ELEMENT_NODE &amp;&amp; isValidContainer(container.parentNode) &amp;&amp; !!container.parentNode._reactRootContainer;

          <span class="hljs-keyword">if</span> (hasNonRootReactChild) {
            error(<span class="hljs-string">"unmountComponentAtNode(): The node you're attempting to unmount "</span> + <span class="hljs-string">'was rendered by React and is not a top-level container. %s'</span>, isContainerReactRoot ? <span class="hljs-string">'You may have accidentally passed in a React root node instead '</span> + <span class="hljs-string">'of its container.'</span> : <span class="hljs-string">'Instead, have the parent component update its state and '</span> + <span class="hljs-string">'rerender in order to remove this component.'</span>);
          }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPortal</span>(<span class="hljs-params">children, containerInfo, <span class="hljs-regexp">//</span> TODO: figure out the API for cross-renderer implementation.
    implementation</span>) </span>{
      <span class="hljs-keyword">var</span> key = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>] : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1383" id="section-1383"></a>
</div>
<p>This tag allow us to uniquely identify this as a React Portal</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        $$<span class="hljs-keyword">typeof</span>: REACT_PORTAL_TYPE,
        <span class="hljs-attr">key</span>: key == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">''</span> + key,
        <span class="hljs-attr">children</span>: children,
        <span class="hljs-attr">containerInfo</span>: containerInfo,
        <span class="hljs-attr">implementation</span>: implementation
      };
    }

    <span class="hljs-keyword">var</span> ReactVersion = <span class="hljs-string">'16.13.1'</span>;
    setAttemptUserBlockingHydration(attemptUserBlockingHydration$<span class="hljs-number">1</span>);
    setAttemptContinuousHydration(attemptContinuousHydration$<span class="hljs-number">1</span>);
    setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$<span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> didWarnAboutUnstableCreatePortal = <span class="hljs-literal">false</span>;
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Map</span> !== <span class="hljs-string">'function'</span> || <span class="hljs-comment">// $FlowIssue Flow incorrectly thinks Map has no prototype</span>
      <span class="hljs-built_in">Map</span>.prototype == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Map</span>.prototype.forEach !== <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Set</span> !== <span class="hljs-string">'function'</span> || <span class="hljs-comment">// $FlowIssue Flow incorrectly thinks Set has no prototype</span>
      <span class="hljs-built_in">Set</span>.prototype == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Set</span>.prototype.clear !== <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Set</span>.prototype.forEach !== <span class="hljs-string">'function'</span>) {
        error(<span class="hljs-string">'React depends on Map and Set built-in types. Make sure that you load a '</span> + <span class="hljs-string">'polyfill in older browsers. https://fb.me/react-polyfills'</span>);
      }
    }
    setRestoreImplementation(restoreControlledState$<span class="hljs-number">3</span>);
    setBatchingImplementation(batchedUpdates$<span class="hljs-number">1</span>, discreteUpdates$<span class="hljs-number">1</span>, flushDiscreteUpdates, batchedEventUpdates$<span class="hljs-number">1</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPortal$1</span>(<span class="hljs-params">children, container</span>) </span>{
      <span class="hljs-keyword">var</span> key = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (!isValidContainer(container)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Target container is not a DOM element."</span>);
        }
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass ReactDOM portal implementation as third argument</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1384" id="section-1384"></a>
</div>
<p>$FlowFixMe The Flow type is opaque but there's no way to actually create it.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">return</span> createPortal(children, container, <span class="hljs-literal">null</span>, key);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSubtreeIntoContainer</span>(<span class="hljs-params">parentComponent, element, containerNode, callback</span>) </span>{
      <span class="hljs-keyword">return</span> unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unstable_createPortal</span>(<span class="hljs-params">children, container</span>) </span>{
      <span class="hljs-keyword">var</span> key = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] : <span class="hljs-literal">null</span>;
      {
        <span class="hljs-keyword">if</span> (!didWarnAboutUnstableCreatePortal) {
          didWarnAboutUnstableCreatePortal = <span class="hljs-literal">true</span>;
          warn(<span class="hljs-string">'The ReactDOM.unstable_createPortal() alias has been deprecated, '</span> + <span class="hljs-string">'and will be removed in React 17+. Update your code to use '</span> + <span class="hljs-string">'ReactDOM.createPortal() instead. It has the exact same API, '</span> + <span class="hljs-string">'but without the "unstable_" prefix.'</span>);
        }
      }
      <span class="hljs-keyword">return</span> createPortal$<span class="hljs-number">1</span>(children, container, key);
    }

    <span class="hljs-keyword">var</span> Internals = {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1385" id="section-1385"></a>
</div>
<p>Keep in sync with ReactDOMUnstableNativeDependencies.js
ReactTestUtils.js, and ReactTestUtilsAct.js. This is an array for better minification.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      Events: [getInstanceFromNode$<span class="hljs-number">1</span>, getNodeFromInstance$<span class="hljs-number">1</span>, getFiberCurrentPropsFromNode$<span class="hljs-number">1</span>, injectEventPluginsByName, eventNameDispatchConfigs, accumulateTwoPhaseDispatches, accumulateDirectDispatches, enqueueStateRestore, restoreStateIfNeeded, dispatchEvent, runEventsInBatch, flushPassiveEffects, IsThisRendererActing]
    };
    <span class="hljs-keyword">var</span> foundDevTools = injectIntoDevTools({
      <span class="hljs-attr">findFiberByHostInstance</span>: getClosestInstanceFromNode,
      <span class="hljs-attr">bundleType</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">version</span>: ReactVersion,
      <span class="hljs-attr">rendererPackageName</span>: <span class="hljs-string">'react-dom'</span>
    });
    {
      <span class="hljs-keyword">if</span> (!foundDevTools &amp;&amp; canUseDOM &amp;&amp; <span class="hljs-built_in">window</span>.top === <span class="hljs-built_in">window</span>.self) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1386" id="section-1386"></a>
</div>
<p>If we're in Chrome or Firefox, provide a download link if not installed.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (navigator.userAgent.indexOf(<span class="hljs-string">'Chrome'</span>) &gt; <span class="hljs-number">-1</span> &amp;&amp; navigator.userAgent.indexOf(<span class="hljs-string">'Edge'</span>) === <span class="hljs-number">-1</span> || navigator.userAgent.indexOf(<span class="hljs-string">'Firefox'</span>) &gt; <span class="hljs-number">-1</span>) {
          <span class="hljs-keyword">var</span> protocol = <span class="hljs-built_in">window</span>.location.protocol; <span class="hljs-comment">// Don't warn in exotic cases like chrome-extension://.</span>

          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(https?|file):$/</span>.test(protocol)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1387" id="section-1387"></a>
</div>
<p>eslint-disable-next-line react-internal/no-production-logging</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'%cDownload the React DevTools '</span> + <span class="hljs-string">'for a better development experience: '</span> + <span class="hljs-string">'https://fb.me/react-devtools'</span> + (protocol === <span class="hljs-string">'file:'</span> ? <span class="hljs-string">'\nYou might need to use a local HTTP server (instead of file://): '</span> + <span class="hljs-string">'https://fb.me/react-devtools-faq'</span> : <span class="hljs-string">''</span>), <span class="hljs-string">'font-weight:bold'</span>);
          }
        }
      }
    }
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
    exports.createPortal = createPortal$<span class="hljs-number">1</span>;
    exports.findDOMNode = findDOMNode;
    exports.flushSync = flushSync;
    exports.hydrate = hydrate;
    exports.render = render;
    exports.unmountComponentAtNode = unmountComponentAtNode;
    exports.unstable_batchedUpdates = batchedUpdates$<span class="hljs-number">1</span>;
    exports.unstable_createPortal = unstable_createPortal;
    exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
    exports.version = ReactVersion;
  })();
}
},{<span class="hljs-string">"react"</span>:<span class="hljs-string">"../node_modules/react/index.js"</span>,<span class="hljs-string">"object-assign"</span>:<span class="hljs-string">"../node_modules/object-assign/index.js"</span>,<span class="hljs-string">"scheduler"</span>:<span class="hljs-string">"../node_modules/scheduler/index.js"</span>,<span class="hljs-string">"prop-types/checkPropTypes"</span>:<span class="hljs-string">"../node_modules/prop-types/checkPropTypes.js"</span>,<span class="hljs-string">"scheduler/tracing"</span>:<span class="hljs-string">"../node_modules/scheduler/tracing.js"</span>}],<span class="hljs-string">"../node_modules/react-dom/index.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
<span class="hljs-meta">'use strict'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkDCE</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> __REACT_DEVTOOLS_GLOBAL_HOOK__ === <span class="hljs-string">'undefined'</span> || <span class="hljs-keyword">typeof</span> __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> !== <span class="hljs-string">'production'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1388" id="section-1388"></a>
</div>
<p>This branch is unreachable because this function is only called
in production, but the condition is true only in development.
Therefore if the branch is still here, dead code elimination wasn't
properly applied.
Don't change the message. React DevTools relies on it. Also make sure
this message doesn't occur elsewhere in this function, or it will cause
a false positive.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'^_^'</span>);
  }

  <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1389" id="section-1389"></a>
</div>
<p>Verify that the code above has been dead code eliminated (DCE'd).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } <span class="hljs-keyword">catch</span> (err) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1390" id="section-1390"></a>
</div>
<p>DevTools shouldn't crash React, no matter what.
We should still report in case we break this code.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-built_in">console</span>.error(err);
  }
}

<span class="hljs-keyword">if</span> (<span class="hljs-string">"development"</span> === <span class="hljs-string">'production'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1391" id="section-1391"></a>
</div>
<p>DCE check should happen before ReactDOM bundle executes so that
DevTools can report bad minification during injection.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  checkDCE();
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/react-dom.production.min.js'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs/react-dom.development.js'</span>);
}
},{<span class="hljs-string">"./cjs/react-dom.development.js"</span>:<span class="hljs-string">"../node_modules/react-dom/cjs/react-dom.development.js"</span>}],<span class="hljs-string">"index.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _react = _interopRequireDefault(<span class="hljs-built_in">require</span>(<span class="hljs-string">"react"</span>));

<span class="hljs-keyword">var</span> _reactDom = <span class="hljs-built_in">require</span>(<span class="hljs-string">"react-dom"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) </span>{ <span class="hljs-keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="hljs-attr">default</span>: obj }; }

(<span class="hljs-number">0</span>, _reactDom.render)( <span class="hljs-comment">/*#__PURE__*/</span>_react.default.createElement(<span class="hljs-string">"h1"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"Working"</span>), <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"app"</span>));
},{<span class="hljs-string">"react"</span>:<span class="hljs-string">"../node_modules/react/index.js"</span>,<span class="hljs-string">"react-dom"</span>:<span class="hljs-string">"../node_modules/react-dom/index.js"</span>}],<span class="hljs-string">"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js"</span>:[<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,module,exports</span>) </span>{
<span class="hljs-keyword">var</span> global = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> OVERLAY_ID = <span class="hljs-string">'__parcel__error__overlay__'</span>;
<span class="hljs-keyword">var</span> OldModule = <span class="hljs-built_in">module</span>.bundle.Module;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Module</span>(<span class="hljs-params">moduleName</span>) </span>{
  OldModule.call(<span class="hljs-keyword">this</span>, moduleName);
  <span class="hljs-keyword">this</span>.hot = {
    <span class="hljs-attr">data</span>: <span class="hljs-built_in">module</span>.bundle.hotData,
    <span class="hljs-attr">_acceptCallbacks</span>: [],
    <span class="hljs-attr">_disposeCallbacks</span>: [],
    <span class="hljs-attr">accept</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{
      <span class="hljs-keyword">this</span>._acceptCallbacks.push(fn || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{});
    },
    <span class="hljs-attr">dispose</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{
      <span class="hljs-keyword">this</span>._disposeCallbacks.push(fn);
    }
  };
  <span class="hljs-built_in">module</span>.bundle.hotData = <span class="hljs-literal">null</span>;
}

<span class="hljs-built_in">module</span>.bundle.Module = Module;
<span class="hljs-keyword">var</span> checkedAssets, assetsToAccept;
<span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">module</span>.bundle.parent;

<span class="hljs-keyword">if</span> ((!parent || !parent.isParcelRequire) &amp;&amp; <span class="hljs-keyword">typeof</span> WebSocket !== <span class="hljs-string">'undefined'</span>) {
  <span class="hljs-keyword">var</span> hostname = <span class="hljs-string">""</span> || location.hostname;
  <span class="hljs-keyword">var</span> protocol = location.protocol === <span class="hljs-string">'https:'</span> ? <span class="hljs-string">'wss'</span> : <span class="hljs-string">'ws'</span>;
  <span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(protocol + <span class="hljs-string">'://'</span> + hostname + <span class="hljs-string">':'</span> + <span class="hljs-string">"55612"</span> + <span class="hljs-string">'/'</span>);

  ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    checkedAssets = {};
    assetsToAccept = [];
    <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(event.data);

    <span class="hljs-keyword">if</span> (data.type === <span class="hljs-string">'update'</span>) {
      <span class="hljs-keyword">var</span> handled = <span class="hljs-literal">false</span>;
      data.assets.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">asset</span>) </span>{
        <span class="hljs-keyword">if</span> (!asset.isNew) {
          <span class="hljs-keyword">var</span> didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          <span class="hljs-keyword">if</span> (didAccept) {
            handled = <span class="hljs-literal">true</span>;
          }
        }
      }); <span class="hljs-comment">// Enable HMR for CSS by default.</span>

      handled = handled || data.assets.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">asset</span>) </span>{
        <span class="hljs-keyword">return</span> asset.type === <span class="hljs-string">'css'</span> &amp;&amp; asset.generated.js;
      });

      <span class="hljs-keyword">if</span> (handled) {
        <span class="hljs-built_in">console</span>.clear();
        data.assets.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">asset</span>) </span>{
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
          hmrAcceptRun(v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);
        });
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.reload) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1392" id="section-1392"></a>
</div>
<p><code>location</code> global exists in a web worker context but lacks <code>.reload()</code> function.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        location.reload();
      }
    }

    <span class="hljs-keyword">if</span> (data.type === <span class="hljs-string">'reload'</span>) {
      ws.close();

      ws.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        location.reload();
      };
    }

    <span class="hljs-keyword">if</span> (data.type === <span class="hljs-string">'error-resolved'</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'[parcel] ✨ Error resolved'</span>);
      removeErrorOverlay();
    }

    <span class="hljs-keyword">if</span> (data.type === <span class="hljs-string">'error'</span>) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'[parcel] 🚨  '</span> + data.error.message + <span class="hljs-string">'\n'</span> + data.error.stack);
      removeErrorOverlay();
      <span class="hljs-keyword">var</span> overlay = createErrorOverlay(data);
      <span class="hljs-built_in">document</span>.body.appendChild(overlay);
    }
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeErrorOverlay</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> overlay = <span class="hljs-built_in">document</span>.getElementById(OVERLAY_ID);

  <span class="hljs-keyword">if</span> (overlay) {
    overlay.remove();
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createErrorOverlay</span>(<span class="hljs-params">data</span>) </span>{
  <span class="hljs-keyword">var</span> overlay = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
  overlay.id = OVERLAY_ID; <span class="hljs-comment">// html encode message and stack trace</span>

  <span class="hljs-keyword">var</span> message = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
  <span class="hljs-keyword">var</span> stackTrace = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'pre'</span>);
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = <span class="hljs-string">'&lt;div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;"&gt;'</span> + <span class="hljs-string">'&lt;span style="background: red; padding: 2px 4px; border-radius: 2px;"&gt;ERROR&lt;/span&gt;'</span> + <span class="hljs-string">'&lt;span style="top: 2px; margin-left: 5px; position: relative;"&gt;🚨&lt;/span&gt;'</span> + <span class="hljs-string">'&lt;div style="font-size: 18px; font-weight: bold; margin-top: 20px;"&gt;'</span> + message.innerHTML + <span class="hljs-string">'&lt;/div&gt;'</span> + <span class="hljs-string">'&lt;pre&gt;'</span> + stackTrace.innerHTML + <span class="hljs-string">'&lt;/pre&gt;'</span> + <span class="hljs-string">'&lt;/div&gt;'</span>;
  <span class="hljs-keyword">return</span> overlay;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParents</span>(<span class="hljs-params">bundle, id</span>) </span>{
  <span class="hljs-keyword">var</span> modules = bundle.modules;

  <span class="hljs-keyword">if</span> (!modules) {
    <span class="hljs-keyword">return</span> [];
  }

  <span class="hljs-keyword">var</span> parents = [];
  <span class="hljs-keyword">var</span> k, d, dep;

  <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> modules) {
    <span class="hljs-keyword">for</span> (d <span class="hljs-keyword">in</span> modules[k][<span class="hljs-number">1</span>]) {
      dep = modules[k][<span class="hljs-number">1</span>][d];

      <span class="hljs-keyword">if</span> (dep === id || <span class="hljs-built_in">Array</span>.isArray(dep) &amp;&amp; dep[dep.length - <span class="hljs-number">1</span>] === id) {
        parents.push(k);
      }
    }
  }

  <span class="hljs-keyword">if</span> (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  <span class="hljs-keyword">return</span> parents;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hmrApply</span>(<span class="hljs-params">bundle, asset</span>) </span>{
  <span class="hljs-keyword">var</span> modules = bundle.modules;

  <span class="hljs-keyword">if</span> (!modules) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">if</span> (modules[asset.id] || !bundle.parent) {
    <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'require'</span>, <span class="hljs-string">'module'</span>, <span class="hljs-string">'exports'</span>, asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hmrAcceptCheck</span>(<span class="hljs-params">bundle, id</span>) </span>{
  <span class="hljs-keyword">var</span> modules = bundle.modules;

  <span class="hljs-keyword">if</span> (!modules) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">if</span> (!modules[id] &amp;&amp; bundle.parent) {
    <span class="hljs-keyword">return</span> hmrAcceptCheck(bundle.parent, id);
  }

  <span class="hljs-keyword">if</span> (checkedAssets[id]) {
    <span class="hljs-keyword">return</span>;
  }

  checkedAssets[id] = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">var</span> cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  <span class="hljs-keyword">if</span> (cached &amp;&amp; cached.hot &amp;&amp; cached.hot._acceptCallbacks.length) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">return</span> getParents(global.parcelRequire, id).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
    <span class="hljs-keyword">return</span> hmrAcceptCheck(global.parcelRequire, id);
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hmrAcceptRun</span>(<span class="hljs-params">bundle, id</span>) </span>{
  <span class="hljs-keyword">var</span> cached = bundle.cache[id];
  bundle.hotData = {};

  <span class="hljs-keyword">if</span> (cached) {
    cached.hot.data = bundle.hotData;
  }

  <span class="hljs-keyword">if</span> (cached &amp;&amp; cached.hot &amp;&amp; cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
      cb(bundle.hotData);
    });
  }

  <span class="hljs-keyword">delete</span> bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  <span class="hljs-keyword">if</span> (cached &amp;&amp; cached.hot &amp;&amp; cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
      cb();
    });

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
},{}]},{},[<span class="hljs-string">"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js"</span>,<span class="hljs-string">"index.js"</span>], <span class="hljs-literal">null</span>)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap" id="sourcemappingurlsrc.e31bb0bc.js.map">
  <h1>
    <a href="#sourcemappingurlsrc.e31bb0bc.js.map" name="sourcemappingurlsrc.e31bb0bc.js.map" class="pilcrow"></a>
sourceMappingURL=/src.e31bb0bc.js.map
  </h1>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"></pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
